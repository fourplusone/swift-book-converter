{"metadata":{"modules":[{"name":"Swift"}],"roleHeading":"Article","title":"Inheritance","role":"article"},"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"title":"Language Guide"}],"kind":"article","hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/inheritance"]}],"sections":[],"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","interfaceLanguage":"swift"},"abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"type":"text","text":"inherit"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"type":"text","text":"subclass"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","level":2,"anchor":"overview"},{"type":"paragraph","inlineContent":[{"text":"Classes in Swift can call and access methods, properties, and subscripts belonging to their superclass and can provide their own overriding versions of those methods, properties, and subscripts to refine or modify their behavior. Swift helps to ensure your overrides are correct by checking that the override definition has a matching superclass definition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Classes can also add property observers to inherited properties in order to be notified when the value of a property changes. Property observers can be added to any property, regardless of whether it was originally defined as a stored or computed property.","type":"text"}]},{"type":"heading","text":"Defining a Base Class","level":2,"anchor":"Defining-a-Base-Class"},{"type":"paragraph","inlineContent":[{"text":"Any class that doesn’t inherit from another class is known as a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"base class","type":"text"}]},{"text":".","type":"text"}]},{"type":"aside","name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Swift classes don’t inherit from a universal base class. Classes you define without specifying a superclass automatically become base classes for you to build upon.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"text":"The example below defines a base class called ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":". This base class defines a stored property called ","type":"text"},{"code":"currentSpeed","type":"codeVoice"},{"text":", with a default value of ","type":"text"},{"code":"0.0","type":"codeVoice"},{"text":" (inferring a property type of ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":"). The ","type":"text"},{"code":"currentSpeed","type":"codeVoice"},{"text":" property’s value is used by a read-only computed ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" property called ","type":"text"},{"code":"description","type":"codeVoice"},{"text":" to create a description of the vehicle.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" base class also defines a method called "},{"type":"codeVoice","code":"makeNoise"},{"type":"text","text":". This method doesn’t actually do anything for a base "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" instance, but will be customized by subclasses of "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" later on:"}]},{"type":"codeListing","syntax":"swift","code":["class Vehicle {","    var currentSpeed = 0.0","    var description: String {","        return \"traveling at \\(currentSpeed) miles per hour\"","    }","    func makeNoise() {","        \/\/ do nothing - an arbitrary vehicle doesn't necessarily make a noise","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"You create a new instance of ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":" with ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"initializer syntax","type":"text"}]},{"text":", which is written as a type name followed by empty parentheses:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let someVehicle = Vehicle()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Having created a new "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" instance, you can access its "},{"type":"codeVoice","code":"description"},{"type":"text","text":" property to print a human-readable description of the vehicle’s current speed:"}]},{"type":"codeListing","syntax":"swift","code":["print(\"Vehicle: \\(someVehicle.description)\")","\/\/ Vehicle: traveling at 0.0 miles per hour"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" class defines common characteristics for an arbitrary vehicle, but isn’t much use in itself. To make it more useful, you need to refine it to describe more specific kinds of vehicles."}]},{"type":"heading","text":"Subclassing","level":2,"anchor":"Subclassing"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Subclassing","type":"text"}],"type":"emphasis"},{"type":"text","text":" is the act of basing a new class on an existing class. The subclass inherits characteristics from the existing class, which you can then refine. You can also add new characteristics to the subclass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To indicate that a subclass has a superclass, write the subclass name before the superclass name, separated by a colon:"}]},{"type":"codeListing","syntax":"swift","code":["class SomeSubclass: SomeSuperclass {","    \/\/ subclass definition goes here","}"]},{"type":"paragraph","inlineContent":[{"text":"The following example defines a subclass called ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":", with a superclass of ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class Bicycle: Vehicle {","    var hasBasket = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new "},{"type":"codeVoice","code":"Bicycle"},{"type":"text","text":" class automatically gains all of the characteristics of "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":", such as its "},{"code":"currentSpeed","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"description","type":"codeVoice"},{"text":" properties and its ","type":"text"},{"code":"makeNoise()","type":"codeVoice"},{"text":" method.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to the characteristics it inherits, the "},{"type":"codeVoice","code":"Bicycle"},{"type":"text","text":" class defines a new stored property, "},{"type":"codeVoice","code":"hasBasket"},{"type":"text","text":", with a default value of "},{"type":"codeVoice","code":"false"},{"type":"text","text":" (inferring a type of "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" for the property)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, any new "},{"type":"codeVoice","code":"Bicycle"},{"type":"text","text":" instance you create will not have a basket. You can set the "},{"type":"codeVoice","code":"hasBasket"},{"type":"text","text":" property to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" for a particular "},{"type":"codeVoice","code":"Bicycle"},{"type":"text","text":" instance after that instance is created:"}]},{"type":"codeListing","syntax":"swift","code":["let bicycle = Bicycle()","bicycle.hasBasket = true"]},{"type":"paragraph","inlineContent":[{"text":"You can also modify the inherited ","type":"text"},{"code":"currentSpeed","type":"codeVoice"},{"text":" property of a ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":" instance, and query the instance’s inherited ","type":"text"},{"code":"description","type":"codeVoice"},{"text":" property:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["bicycle.currentSpeed = 15.0","print(\"Bicycle: \\(bicycle.description)\")","\/\/ Bicycle: traveling at 15.0 miles per hour"]},{"type":"paragraph","inlineContent":[{"text":"Subclasses can themselves be subclassed. The next example creates a subclass of ","type":"text"},{"type":"codeVoice","code":"Bicycle"},{"text":" for a two-seater bicycle known as a “tandem”:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class Tandem: Bicycle {","    var currentNumberOfPassengers = 0","}"]},{"type":"paragraph","inlineContent":[{"code":"Tandem","type":"codeVoice"},{"text":" inherits all of the properties and methods from ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":", which in turn inherits all of the properties and methods from ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"Tandem","type":"codeVoice"},{"text":" subclass also adds a new stored property called ","type":"text"},{"code":"currentNumberOfPassengers","type":"codeVoice"},{"text":", with a default value of ","type":"text"},{"code":"0","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you create an instance of "},{"type":"codeVoice","code":"Tandem"},{"type":"text","text":", you can work with any of its new and inherited properties, and query the read-only "},{"type":"codeVoice","code":"description"},{"type":"text","text":" property it inherits from "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let tandem = Tandem()","tandem.hasBasket = true","tandem.currentNumberOfPassengers = 2","tandem.currentSpeed = 22.0","print(\"Tandem: \\(tandem.description)\")","\/\/ Tandem: traveling at 22.0 miles per hour"]},{"type":"heading","text":"Overriding","level":2,"anchor":"Overriding"},{"type":"paragraph","inlineContent":[{"text":"A subclass can provide its own custom implementation of an instance method, type method, instance property, type property, or subscript that it would otherwise inherit from a superclass. This is known as ","type":"text"},{"inlineContent":[{"text":"overriding","type":"text"}],"type":"emphasis"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To override a characteristic that would otherwise be inherited, you prefix your overriding definition with the "},{"type":"codeVoice","code":"override"},{"type":"text","text":" keyword. Doing so clarifies that you intend to provide an override and haven’t provided a matching definition by mistake. Overriding by accident can cause unexpected behavior, and any overrides without the "},{"type":"codeVoice","code":"override"},{"type":"text","text":" keyword are diagnosed as an error when your code is compiled."}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"override"},{"text":" keyword also prompts the Swift compiler to check that your overriding class’s superclass (or one of its parents) has a declaration that matches the one you provided for the override. This check ensures that your overriding definition is correct.","type":"text"}]},{"type":"heading","text":"Accessing Superclass Methods, Properties, and Subscripts","level":3,"anchor":"Accessing-Superclass-Methods-Properties-and-Subscripts"},{"type":"paragraph","inlineContent":[{"text":"When you provide a method, property, or subscript override for a subclass, it’s sometimes useful to use the existing superclass implementation as part of your override. For example, you can refine the behavior of that existing implementation, or store a modified value in an existing inherited variable.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Where this is appropriate, you access the superclass version of a method, property, or subscript by using the ","type":"text"},{"code":"super","type":"codeVoice"},{"text":" prefix:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"An overridden method named ","type":"text"},{"code":"someMethod()","type":"codeVoice"},{"text":" can call the superclass version of ","type":"text"},{"code":"someMethod()","type":"codeVoice"},{"text":" by calling ","type":"text"},{"code":"super.someMethod()","type":"codeVoice"},{"text":" within the overriding method implementation.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"An overridden property called ","type":"text"},{"code":"someProperty","type":"codeVoice"},{"text":" can access the superclass version of ","type":"text"},{"code":"someProperty","type":"codeVoice"},{"text":" as ","type":"text"},{"code":"super.someProperty","type":"codeVoice"},{"text":" within the overriding getter or setter implementation.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An overridden subscript for "},{"type":"codeVoice","code":"someIndex"},{"type":"text","text":" can access the superclass version of the same subscript as "},{"type":"codeVoice","code":"super[someIndex]"},{"type":"text","text":" from within the overriding subscript implementation."}]}]}]},{"type":"heading","text":"Overriding Methods","level":3,"anchor":"Overriding-Methods"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can override an inherited instance or type method to provide a tailored or alternative implementation of the method within your subclass."}]},{"type":"paragraph","inlineContent":[{"text":"The following example defines a new subclass of ","type":"text"},{"type":"codeVoice","code":"Vehicle"},{"text":" called ","type":"text"},{"type":"codeVoice","code":"Train"},{"text":", which overrides the ","type":"text"},{"type":"codeVoice","code":"makeNoise()"},{"text":" method that ","type":"text"},{"type":"codeVoice","code":"Train"},{"text":" inherits from ","type":"text"},{"type":"codeVoice","code":"Vehicle"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class Train: Vehicle {","    override func makeNoise() {","        print(\"Choo Choo\")","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"If you create a new instance of ","type":"text"},{"code":"Train","type":"codeVoice"},{"text":" and call its ","type":"text"},{"code":"makeNoise()","type":"codeVoice"},{"text":" method, you can see that the ","type":"text"},{"code":"Train","type":"codeVoice"},{"text":" subclass version of the method is called:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let train = Train()","train.makeNoise()","\/\/ Prints \"Choo Choo\""]},{"type":"heading","text":"Overriding Properties","level":3,"anchor":"Overriding-Properties"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can override an inherited instance or type property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes."}]},{"type":"heading","text":"Overriding Property Getters and Setters","level":4,"anchor":"Overriding-Property-Getters-and-Setters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can provide a custom getter (and setter, if appropriate) to override "},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"type":"text","text":" inherited property, regardless of whether the inherited property is implemented as a stored or computed property at source. The stored or computed nature of an inherited property isn’t known by a subclass—it only knows that the inherited property has a certain name and type. You must always state both the name and the type of the property you are overriding, to enable the compiler to check that your override matches a superclass property with the same name and type."}]},{"type":"paragraph","inlineContent":[{"text":"You can present an inherited read-only property as a read-write property by providing both a getter and a setter in your subclass property override. You can’t, however, present an inherited read-write property as a read-only property.","type":"text"}]},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"text":"If you provide a setter as part of a property override, you must also provide a getter for that override. If you don’t want to modify the inherited property’s value within the overriding getter, you can simply pass through the inherited value by returning ","type":"text"},{"type":"codeVoice","code":"super.someProperty"},{"text":" from the getter, where ","type":"text"},{"type":"codeVoice","code":"someProperty"},{"text":" is the name of the property you are overriding.","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example defines a new class called "},{"type":"codeVoice","code":"Car"},{"type":"text","text":", which is a subclass of "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":". The "},{"type":"codeVoice","code":"Car"},{"type":"text","text":" class introduces a new stored property called "},{"type":"codeVoice","code":"gear"},{"type":"text","text":", with a default integer value of "},{"type":"codeVoice","code":"1"},{"type":"text","text":". The "},{"type":"codeVoice","code":"Car"},{"type":"text","text":" class also overrides the "},{"type":"codeVoice","code":"description"},{"type":"text","text":" property it inherits from "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":", to provide a custom description that includes the current gear:"}]},{"type":"codeListing","syntax":"swift","code":["class Car: Vehicle {","    var gear = 1","    override var description: String {","        return super.description + \" in gear \\(gear)\"","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The override of the "},{"type":"codeVoice","code":"description"},{"type":"text","text":" property starts by calling "},{"type":"codeVoice","code":"super.description"},{"type":"text","text":", which returns the "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" class’s "},{"type":"codeVoice","code":"description"},{"type":"text","text":" property. The "},{"type":"codeVoice","code":"Car"},{"type":"text","text":" class’s version of "},{"type":"codeVoice","code":"description"},{"type":"text","text":" then adds some extra text onto the end of this description to provide information about the current gear."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you create an instance of the "},{"code":"Car","type":"codeVoice"},{"type":"text","text":" class and set its "},{"code":"gear","type":"codeVoice"},{"type":"text","text":" and "},{"code":"currentSpeed","type":"codeVoice"},{"type":"text","text":" properties, you can see that its "},{"code":"description","type":"codeVoice"},{"type":"text","text":" property returns the tailored description defined within the "},{"code":"Car","type":"codeVoice"},{"type":"text","text":" class:"}]},{"type":"codeListing","syntax":"swift","code":["let car = Car()","car.currentSpeed = 25.0","car.gear = 3","print(\"Car: \\(car.description)\")","\/\/ Car: traveling at 25.0 miles per hour in gear 3"]},{"type":"heading","text":"Overriding Property Observers","level":4,"anchor":"Overriding-Property-Observers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use property overriding to add property observers to an inherited property. This enables you to be notified when the value of an inherited property changes, regardless of how that property was originally implemented. For more information on property observers, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties#Property-Observers","isActive":true},{"type":"text","text":"."}]},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"text":"You can’t add property observers to inherited constant stored properties or inherited read-only computed properties. The value of these properties can’t be set, and so it isn’t appropriate to provide a ","type":"text"},{"code":"willSet","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"didSet","type":"codeVoice"},{"text":" implementation as part of an override.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note also that you can’t provide both an overriding setter and an overriding property observer for the same property. If you want to observe changes to a property’s value, and you are already providing a custom setter for that property, you can simply observe any value changes from within the custom setter."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"text":"The following example defines a new class called ","type":"text"},{"type":"codeVoice","code":"AutomaticCar"},{"text":", which is a subclass of ","type":"text"},{"type":"codeVoice","code":"Car"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"AutomaticCar"},{"text":" class represents a car with an automatic gearbox, which automatically selects an appropriate gear to use based on the current speed:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class AutomaticCar: Car {","    override var currentSpeed: Double {","        didSet {","            gear = Int(currentSpeed \/ 10.0) + 1","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Whenever you set the ","type":"text"},{"code":"currentSpeed","type":"codeVoice"},{"text":" property of an ","type":"text"},{"code":"AutomaticCar","type":"codeVoice"},{"text":" instance, the property’s ","type":"text"},{"code":"didSet","type":"codeVoice"},{"text":" observer sets the instance’s ","type":"text"},{"code":"gear","type":"codeVoice"},{"text":" property to an appropriate choice of gear for the new speed. Specifically, the property observer chooses a gear that’s the new ","type":"text"},{"code":"currentSpeed","type":"codeVoice"},{"text":" value divided by ","type":"text"},{"code":"10","type":"codeVoice"},{"text":", rounded down to the nearest integer, plus ","type":"text"},{"code":"1","type":"codeVoice"},{"text":". A speed of ","type":"text"},{"code":"35.0","type":"codeVoice"},{"text":" produces a gear of ","type":"text"},{"code":"4","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let automatic = AutomaticCar()","automatic.currentSpeed = 35.0","print(\"AutomaticCar: \\(automatic.description)\")","\/\/ AutomaticCar: traveling at 35.0 miles per hour in gear 4"]},{"type":"heading","text":"Preventing Overrides","level":2,"anchor":"Preventing-Overrides"},{"type":"paragraph","inlineContent":[{"text":"You can prevent a method, property, or subscript from being overridden by marking it as ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"final"}]},{"text":". Do this by writing the ","type":"text"},{"type":"codeVoice","code":"final"},{"text":" modifier before the method, property, or subscript’s introducer keyword (such as ","type":"text"},{"type":"codeVoice","code":"final var"},{"text":", ","type":"text"},{"type":"codeVoice","code":"final func"},{"text":", ","type":"text"},{"type":"codeVoice","code":"final class func"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"final subscript"},{"text":").","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Any attempt to override a final method, property, or subscript in a subclass is reported as a compile-time error. Methods, properties, or subscripts that you add to a class in an extension can also be marked as final within the extension’s definition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can mark an entire class as final by writing the ","type":"text"},{"code":"final","type":"codeVoice"},{"text":" modifier before the ","type":"text"},{"type":"codeVoice","code":"class"},{"type":"text","text":" keyword in its class definition ("},{"type":"codeVoice","code":"final class"},{"type":"text","text":"). Any attempt to subclass a final class is reported as a compile-time error."}]}]}],"references":{"doc://com.apple.Swift/documentation/Swift/Enumerations":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic","role":"article","title":"Enumerations","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Methods":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"type":"topic","title":"Methods","role":"article","url":"\/documentation\/swift\/methods"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"url":"\/documentation\/swift\/functions"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","abstract":[{"type":"text","text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t."}],"url":"\/documentation\/swift\/opaquetypes","type":"topic","role":"article","title":"Opaque Types","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"type":"topic","kind":"article","title":"Extensions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"url":"\/documentation\/swift\/extensions"},"doc://com.apple.Swift/documentation/Swift/Properties":{"role":"article","type":"topic","url":"\/documentation\/swift\/properties","abstract":[{"inlineContent":[{"type":"text","text":"Properties"}],"type":"emphasis"},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","title":"Properties","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"type":"text","text":"deinitializer"}],"type":"emphasis"},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword, similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","title":"Deinitialization","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","type":"topic","url":"\/documentation\/swift\/classesandstructures","abstract":[{"inlineContent":[{"type":"text","text":"Structures"}],"type":"emphasis"},{"type":"text","text":" and "},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","title":"Structures and Classes","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"type":"topic","title":"Subscripts","role":"article","url":"\/documentation\/swift\/subscripts"},"doc://com.apple.Swift/documentation/Swift/Closures":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"url":"\/documentation\/swift\/closures","type":"topic","role":"article","title":"Closures","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"type":"topic","title":"Error Handling","role":"article","url":"\/documentation\/swift\/errorhandling"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","abstract":[{"type":"text","text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"type":"text","text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. "},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"url":"\/documentation\/swift\/automaticreferencecounting","type":"topic","role":"article","title":"Automatic Reference Counting","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Generics":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner."}],"url":"\/documentation\/swift\/generics","type":"topic","role":"article","title":"Generics","kind":"article"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"role":"article","type":"topic","url":"\/documentation\/swift\/stringsandcharacters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"type":"text","text":" type. The contents of a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" can be accessed in various ways, including as a collection of "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" values."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","title":"Strings and Characters","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"type":"text","text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to "},{"inlineContent":[{"type":"text","text":"conform"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","title":"Protocols","role":"article","url":"\/documentation\/swift\/protocols"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","abstract":[{"inlineContent":[{"type":"text","text":"Access control"}],"type":"emphasis"},{"type":"text","text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used."}],"type":"topic","title":"Access Control","role":"article","url":"\/documentation\/swift\/accesscontrol"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"type":"topic","title":"Memory Safety","role":"article","url":"\/documentation\/swift\/memorysafety"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"inlineContent":[{"type":"text","text":"Optional chaining"}],"type":"emphasis"},{"text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", the property, method, or subscript call returns ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic","role":"article","title":"Optional Chaining","kind":"article"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"url":"\/documentation\/swift\/nestedtypes","type":"topic","title":"Nested Types","abstract":[{"type":"text","text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"nested types"}]},{"type":"text","text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"type":"topic","kind":"article","title":"Basic Operators","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","role":"article","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator"}]},{"type":"text","text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") adds two numbers, as in "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/basicoperators"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements. These include "},{"code":"while","type":"codeVoice"},{"type":"text","text":" loops to perform a task multiple times; "},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"type":"topic","title":"Control Flow","role":"article","url":"\/documentation\/swift\/controlflow"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"url":"\/documentation\/swift\/thebasics","type":"topic","role":"article","title":"The Basics","kind":"article"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"type":"topic","title":"Swift","role":"collection","url":"\/documentation\/swift"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"abstract":[{"type":"text","text":"In addition to the operators described in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators"},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","title":"Advanced Operators","type":"topic","kind":"article","role":"article","url":"\/documentation\/swift\/advancedoperators"},"doc://com.apple.Swift/documentation/Swift/Properties#Property-Observers":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties#Property-Observers","url":"\/documentation\/swift\/properties#Property-Observers","abstract":[],"type":"topic","title":"Property Observers","kind":"section"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","url":"\/documentation\/swift\/collectiontypes","abstract":[{"type":"text","text":"Swift provides three primary "},{"inlineContent":[{"type":"text","text":"collection types"}],"type":"emphasis"},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","title":"Collection Types","kind":"article"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","title":"Type Casting","type":"topic","kind":"article","role":"article","url":"\/documentation\/swift\/typecasting"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use."}],"url":"\/documentation\/swift\/initialization","type":"topic","role":"article","title":"Initialization","kind":"article"}}}