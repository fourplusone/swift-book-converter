{"kind":"article","hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"sections":[],"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/properties"]}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"title":"Language Guide"}],"abstract":[{"inlineContent":[{"type":"text","text":"Properties"}],"type":"emphasis"},{"text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures.","type":"text"}],"metadata":{"roleHeading":"Article","modules":[{"name":"Swift"}],"role":"article","title":"Properties"},"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","text":"Overview","level":2,"type":"heading"},{"inlineContent":[{"text":"Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In addition, you can define property observers to monitor changes in a property’s value, which you can respond to with custom actions. Property observers can be added to stored properties you define yourself, and also to properties that a subclass inherits from its superclass.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You can also use a property wrapper to reuse code in the getter and setter of multiple properties.","type":"text"}],"type":"paragraph"},{"anchor":"Stored-Properties","text":"Stored Properties","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"In its simplest form, a stored property is a constant or variable that’s stored as part of an instance of a particular class or structure. Stored properties can be either "},{"inlineContent":[{"type":"text","text":"variable stored properties"}],"type":"emphasis"},{"type":"text","text":" (introduced by the "},{"code":"var","type":"codeVoice"},{"type":"text","text":" keyword) or "},{"inlineContent":[{"text":"constant stored properties","type":"text"}],"type":"emphasis"},{"type":"text","text":" (introduced by the "},{"code":"let","type":"codeVoice"},{"type":"text","text":" keyword)."}],"type":"paragraph"},{"inlineContent":[{"text":"You can provide a default value for a stored property as part of its definition, as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Default-Property-Values","isActive":true},{"text":". You can also set and modify the initial value for a stored property during initialization. This is true even for constant stored properties, as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Assigning-Constant-Properties-During-Initialization","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines a structure called ","type":"text"},{"type":"codeVoice","code":"FixedLengthRange"},{"type":"text","text":", which describes a range of integers whose range length can’t be changed after it’s created:"}],"type":"paragraph"},{"code":["struct FixedLengthRange {","    var firstValue: Int","    let length: Int","}","var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)","\/\/ the range represents integer values 0, 1, and 2","rangeOfThreeItems.firstValue = 6","\/\/ the range now represents integer values 6, 7, and 8"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Instances of ","type":"text"},{"type":"codeVoice","code":"FixedLengthRange"},{"text":" have a variable stored property called ","type":"text"},{"type":"codeVoice","code":"firstValue"},{"text":" and a constant stored property called ","type":"text"},{"type":"codeVoice","code":"length"},{"text":". In the example above, ","type":"text"},{"type":"codeVoice","code":"length"},{"text":" is initialized when the new range is created and can’t be changed thereafter, because it’s a constant property.","type":"text"}],"type":"paragraph"},{"anchor":"Stored-Properties-of-Constant-Structure-Instances","text":"Stored Properties of Constant Structure Instances","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"If you create an instance of a structure and assign that instance to a constant, you can’t modify the instance’s properties, even if they were declared as variable properties:"}],"type":"paragraph"},{"code":["let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)","\/\/ this range represents integer values 0, 1, 2, and 3","rangeOfFourItems.firstValue = 6","\/\/ this will report an error, even though firstValue is a variable property"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Because "},{"code":"rangeOfFourItems","type":"codeVoice"},{"type":"text","text":" is declared as a constant (with the "},{"code":"let","type":"codeVoice"},{"type":"text","text":" keyword), it isn’t possible to change its "},{"code":"firstValue","type":"codeVoice"},{"type":"text","text":" property, even though "},{"code":"firstValue","type":"codeVoice"},{"type":"text","text":" is a variable property."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This behavior is due to structures being "},{"type":"emphasis","inlineContent":[{"text":"value types","type":"text"}]},{"type":"text","text":". When an instance of a value type is marked as a constant, so are all of its properties."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The same isn’t true for classes, which are "},{"inlineContent":[{"type":"text","text":"reference types"}],"type":"emphasis"},{"type":"text","text":". If you assign an instance of a reference type to a constant, you can still change that instance’s variable properties."}],"type":"paragraph"},{"anchor":"Lazy-Stored-Properties","text":"Lazy Stored Properties","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"lazy stored property"}]},{"type":"text","text":" is a property whose initial value isn’t calculated until the first time it’s used. You indicate a lazy stored property by writing the "},{"type":"codeVoice","code":"lazy"},{"type":"text","text":" modifier before its declaration."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"You must always declare a lazy property as a variable (with the ","type":"text"},{"code":"var","type":"codeVoice"},{"text":" keyword), because its initial value might not be retrieved until after instance initialization completes. Constant properties must always have a value ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"text":" initialization completes, and therefore can’t be declared as lazy.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"Lazy properties are useful when the initial value for a property is dependent on outside factors whose values aren’t known until after an instance’s initialization is complete. Lazy properties are also useful when the initial value for a property requires complex or computationally expensive setup that shouldn’t be performed unless or until it’s needed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The example below uses a lazy stored property to avoid unnecessary initialization of a complex class. This example defines two classes called ","type":"text"},{"type":"codeVoice","code":"DataImporter"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"DataManager"},{"text":", neither of which is shown in full:","type":"text"}],"type":"paragraph"},{"code":["class DataImporter {","    \/*","    DataImporter is a class to import data from an external file.","    The class is assumed to take a nontrivial amount of time to initialize.","    *\/","    var filename = \"data.txt\"","    \/\/ the DataImporter class would provide data importing functionality here","}","","class DataManager {","    lazy var importer = DataImporter()","    var data: [String] = []","    \/\/ the DataManager class would provide data management functionality here","}","","let manager = DataManager()","manager.data.append(\"Some data\")","manager.data.append(\"Some more data\")","\/\/ the DataImporter instance for the importer property hasn't yet been created"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"DataManager"},{"text":" class has a stored property called ","type":"text"},{"type":"codeVoice","code":"data"},{"text":", which is initialized with a new, empty array of ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" values. Although the rest of its functionality isn’t shown, the purpose of this ","type":"text"},{"type":"codeVoice","code":"DataManager"},{"text":" class is to manage and provide access to this array of ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" data.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Part of the functionality of the ","type":"text"},{"type":"codeVoice","code":"DataManager"},{"text":" class is the ability to import data from a file. This functionality is provided by the ","type":"text"},{"type":"codeVoice","code":"DataImporter"},{"type":"text","text":" class, which is assumed to take a nontrivial amount of time to initialize. This might be because a "},{"type":"codeVoice","code":"DataImporter"},{"type":"text","text":" instance needs to open a file and read its contents into memory when the "},{"type":"codeVoice","code":"DataImporter"},{"type":"text","text":" instance is initialized."}],"type":"paragraph"},{"inlineContent":[{"text":"Because it’s possible for a ","type":"text"},{"code":"DataManager","type":"codeVoice"},{"text":" instance to manage its data without ever importing data from a file, ","type":"text"},{"code":"DataManager","type":"codeVoice"},{"text":" doesn’t create a new ","type":"text"},{"code":"DataImporter","type":"codeVoice"},{"text":" instance when the ","type":"text"},{"code":"DataManager","type":"codeVoice"},{"text":" itself is created. Instead, it makes more sense to create the ","type":"text"},{"code":"DataImporter","type":"codeVoice"},{"text":" instance if and when it’s first used.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Because it’s marked with the ","type":"text"},{"type":"codeVoice","code":"lazy"},{"text":" modifier, the ","type":"text"},{"type":"codeVoice","code":"DataImporter"},{"text":" instance for the ","type":"text"},{"type":"codeVoice","code":"importer"},{"text":" property is only created when the ","type":"text"},{"type":"codeVoice","code":"importer"},{"text":" property is first accessed, such as when its ","type":"text"},{"type":"codeVoice","code":"filename"},{"type":"text","text":" property is queried:"}],"type":"paragraph"},{"code":["print(manager.importer.filename)","\/\/ the DataImporter instance for the importer property has now been created","\/\/ Prints \"data.txt\""],"syntax":"swift","type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a property marked with the "},{"code":"lazy","type":"codeVoice"},{"type":"text","text":" modifier is accessed by multiple threads simultaneously and the property hasn’t yet been initialized, there’s no guarantee that the property will be initialized only once."}]}],"style":"note","name":"Note","type":"aside"},{"anchor":"Stored-Properties-and-Instance-Variables","text":"Stored Properties and Instance Variables","level":3,"type":"heading"},{"inlineContent":[{"text":"If you have experience with Objective-C, you may know that it provides ","type":"text"},{"inlineContent":[{"type":"text","text":"two"}],"type":"emphasis"},{"text":" ways to store values and references as part of a class instance. In addition to properties, you can use instance variables as a backing store for the values stored in a property.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift unifies these concepts into a single property declaration. A Swift property doesn’t have a corresponding instance variable, and the backing store for a property isn’t accessed directly. This approach avoids confusion about how the value is accessed in different contexts and simplifies the property’s declaration into a single, definitive statement. All information about the property—including its name, type, and memory management characteristics—is defined in a single location as part of the type’s definition.","type":"text"}],"type":"paragraph"},{"anchor":"Computed-Properties","text":"Computed Properties","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"In addition to stored properties, classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"computed properties","type":"text"}]},{"type":"text","text":", which don’t actually store a value. Instead, they provide a getter and an optional setter to retrieve and set other properties and values indirectly."}],"type":"paragraph"},{"code":["struct Point {","    var x = 0.0, y = 0.0","}","struct Size {","    var width = 0.0, height = 0.0","}","struct Rect {","    var origin = Point()","    var size = Size()","    var center: Point {","        get {","            let centerX = origin.x + (size.width \/ 2)","            let centerY = origin.y + (size.height \/ 2)","            return Point(x: centerX, y: centerY)","        }","        set(newCenter) {","            origin.x = newCenter.x - (size.width \/ 2)","            origin.y = newCenter.y - (size.height \/ 2)","        }","    }","}","var square = Rect(origin: Point(x: 0.0, y: 0.0),","                  size: Size(width: 10.0, height: 10.0))","let initialSquareCenter = square.center","\/\/ initialSquareCenter is at (5.0, 5.0)","square.center = Point(x: 15.0, y: 15.0)","print(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")","\/\/ Prints \"square.origin is now at (10.0, 10.0)\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This example defines three structures for working with geometric shapes:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"code":"Point","type":"codeVoice"},{"type":"text","text":" encapsulates the x- and y-coordinate of a point."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"Size"},{"type":"text","text":" encapsulates a "},{"type":"codeVoice","code":"width"},{"type":"text","text":" and a "},{"type":"codeVoice","code":"height"},{"type":"text","text":"."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"Rect","type":"codeVoice"},{"type":"text","text":" defines a rectangle by an origin point and a size."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The "},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" structure also provides a computed property called "},{"code":"center","type":"codeVoice"},{"type":"text","text":". The current center position of a "},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" can always be determined from its "},{"code":"origin","type":"codeVoice"},{"type":"text","text":" and "},{"code":"size","type":"codeVoice"},{"type":"text","text":", and so you don’t need to store the center point as an explicit "},{"code":"Point","type":"codeVoice"},{"type":"text","text":" value. Instead, "},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" defines a custom getter and setter for a computed variable called "},{"code":"center","type":"codeVoice"},{"type":"text","text":", to enable you to work with the rectangle’s "},{"code":"center","type":"codeVoice"},{"type":"text","text":" as if it were a real stored property."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example above creates a new "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" variable called "},{"type":"codeVoice","code":"square"},{"type":"text","text":". The "},{"type":"codeVoice","code":"square"},{"type":"text","text":" variable is initialized with an origin point of "},{"type":"codeVoice","code":"(0, 0)"},{"type":"text","text":", and a width and height of "},{"type":"codeVoice","code":"10"},{"type":"text","text":". This square is represented by the light green square in the diagram below."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"square","type":"codeVoice"},{"text":" variable’s ","type":"text"},{"code":"center","type":"codeVoice"},{"text":" property is then accessed through dot syntax (","type":"text"},{"code":"square.center","type":"codeVoice"},{"text":"), which causes the getter for ","type":"text"},{"code":"center","type":"codeVoice"},{"text":" to be called, to retrieve the current property value. Rather than returning an existing value, the getter actually calculates and returns a new ","type":"text"},{"code":"Point","type":"codeVoice"},{"text":" to represent the center of the square. As can be seen above, the getter correctly returns a center point of ","type":"text"},{"code":"(5, 5)","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"center"},{"type":"text","text":" property is then set to a new value of "},{"type":"codeVoice","code":"(15, 15)"},{"type":"text","text":", which moves the square up and to the right, to the new position shown by the dark green square in the diagram below. Setting the "},{"type":"codeVoice","code":"center"},{"type":"text","text":" property calls the setter for "},{"type":"codeVoice","code":"center"},{"type":"text","text":", which modifies the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" values of the stored "},{"type":"codeVoice","code":"origin"},{"type":"text","text":" property, and moves the square to its new position."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"computedProperties"}],"type":"paragraph"},{"anchor":"Shorthand-Setter-Declaration","text":"Shorthand Setter Declaration","level":3,"type":"heading"},{"inlineContent":[{"text":"If a computed property’s setter doesn’t define a name for the new value to be set, a default name of ","type":"text"},{"type":"codeVoice","code":"newValue"},{"text":" is used. Here’s an alternative version of the ","type":"text"},{"type":"codeVoice","code":"Rect"},{"text":" structure that takes advantage of this shorthand notation:","type":"text"}],"type":"paragraph"},{"code":["struct AlternativeRect {","    var origin = Point()","    var size = Size()","    var center: Point {","        get {","            let centerX = origin.x + (size.width \/ 2)","            let centerY = origin.y + (size.height \/ 2)","            return Point(x: centerX, y: centerY)","        }","        set {","            origin.x = newValue.x - (size.width \/ 2)","            origin.y = newValue.y - (size.height \/ 2)","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Shorthand-Getter-Declaration","text":"Shorthand Getter Declaration","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"If the entire body of a getter is a single expression, the getter implicitly returns that expression. Here’s an another version of the "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" structure that takes advantage of this shorthand notation and the shorthand notation for setters:"}],"type":"paragraph"},{"code":["struct CompactRect {","    var origin = Point()","    var size = Size()","    var center: Point {","        get {","            Point(x: origin.x + (size.width \/ 2),","                  y: origin.y + (size.height \/ 2))","        }","        set {","            origin.x = newValue.x - (size.width \/ 2)","            origin.y = newValue.y - (size.height \/ 2)","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Omitting the "},{"type":"codeVoice","code":"return"},{"type":"text","text":" from a getter follows the same rules as omitting "},{"type":"codeVoice","code":"return"},{"type":"text","text":" from a function, as described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Functions-With-an-Implicit-Return","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Read-Only-Computed-Properties","text":"Read-Only Computed Properties","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"A computed property with a getter but no setter is known as a "},{"inlineContent":[{"type":"text","text":"read-only computed property"}],"type":"emphasis"},{"type":"text","text":". A read-only computed property always returns a value, and can be accessed through dot syntax, but can’t be set to a different value."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You must declare computed properties—including read-only computed properties—as variable properties with the "},{"type":"codeVoice","code":"var"},{"type":"text","text":" keyword, because their value isn’t fixed. The "},{"type":"codeVoice","code":"let"},{"type":"text","text":" keyword is only used for constant properties, to indicate that their values can’t be changed once they’re set as part of instance initialization."}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"type":"text","text":"You can simplify the declaration of a read-only computed property by removing the "},{"type":"codeVoice","code":"get"},{"type":"text","text":" keyword and its braces:"}],"type":"paragraph"},{"code":["struct Cuboid {","    var width = 0.0, height = 0.0, depth = 0.0","    var volume: Double {","        return width * height * depth","    }","}","let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)","print(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")","\/\/ Prints \"the volume of fourByFiveByTwo is 40.0\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example defines a new structure called "},{"code":"Cuboid","type":"codeVoice"},{"type":"text","text":", which represents a 3D rectangular box with "},{"code":"width","type":"codeVoice"},{"type":"text","text":", "},{"code":"height","type":"codeVoice"},{"type":"text","text":", and "},{"code":"depth","type":"codeVoice"},{"type":"text","text":" properties. This structure also has a read-only computed property called "},{"code":"volume","type":"codeVoice"},{"type":"text","text":", which calculates and returns the current volume of the cuboid. It doesn’t make sense for "},{"code":"volume","type":"codeVoice"},{"type":"text","text":" to be settable, because it would be ambiguous as to which values of "},{"code":"width","type":"codeVoice"},{"type":"text","text":", "},{"code":"height","type":"codeVoice"},{"type":"text","text":", and "},{"code":"depth","type":"codeVoice"},{"type":"text","text":" should be used for a particular "},{"type":"codeVoice","code":"volume"},{"type":"text","text":" value. Nonetheless, it’s useful for a "},{"type":"codeVoice","code":"Cuboid"},{"type":"text","text":" to provide a read-only computed property to enable external users to discover its current calculated volume."}],"type":"paragraph"},{"anchor":"Property-Observers","text":"Property Observers","level":2,"type":"heading"},{"inlineContent":[{"text":"Property observers observe and respond to changes in a property’s value. Property observers are called every time a property’s value is set, even if the new value is the same as the property’s current value.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You can add property observers in the following places:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Stored properties that you define"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Stored properties that you inherit"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Computed properties that you inherit","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"For an inherited property, you add a property observer by overriding that property in a subclass. For a computed property that you define, use the property’s setter to observe and respond to value changes, instead of trying to create an observer. Overriding properties is described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance#Overriding"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You have the option to define either or both of these observers on a property:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"willSet"},{"type":"text","text":" is called just before the value is stored."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"didSet"},{"type":"text","text":" is called immediately after the new value is stored."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"If you implement a "},{"type":"codeVoice","code":"willSet"},{"type":"text","text":" observer, it’s passed the new property value as a constant parameter. You can specify a name for this parameter as part of your "},{"type":"codeVoice","code":"willSet"},{"type":"text","text":" implementation. If you don’t write the parameter name and parentheses within your implementation, the parameter is made available with a default parameter name of "},{"type":"codeVoice","code":"newValue"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Similarly, if you implement a "},{"type":"codeVoice","code":"didSet"},{"type":"text","text":" observer, it’s passed a constant parameter containing the old property value. You can name the parameter or use the default parameter name of "},{"type":"codeVoice","code":"oldValue"},{"type":"text","text":". If you assign a value to a property within its own "},{"type":"codeVoice","code":"didSet"},{"type":"text","text":" observer, the new value that you assign replaces the one that was just set."}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"willSet","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"didSet","type":"codeVoice"},{"text":" observers of superclass properties are called when a property is set in a subclass initializer, after the superclass initializer has been called. They aren’t called while a class is setting its own properties, before the superclass initializer has been called.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For more information about initializer delegation, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Delegation-for-Value-Types","isActive":true,"type":"reference"},{"text":" and ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Delegation-for-Class-Types","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"Here’s an example of ","type":"text"},{"code":"willSet","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"didSet","type":"codeVoice"},{"text":" in action. The example below defines a new class called ","type":"text"},{"code":"StepCounter","type":"codeVoice"},{"text":", which tracks the total number of steps that a person takes while walking. This class might be used with input data from a pedometer or other step counter to keep track of a person’s exercise during their daily routine.","type":"text"}],"type":"paragraph"},{"code":["class StepCounter {","    var totalSteps: Int = 0 {","        willSet(newTotalSteps) {","            print(\"About to set totalSteps to \\(newTotalSteps)\")","        }","        didSet {","            if totalSteps > oldValue  {","                print(\"Added \\(totalSteps - oldValue) steps\")","            }","        }","    }","}","let stepCounter = StepCounter()","stepCounter.totalSteps = 200","\/\/ About to set totalSteps to 200","\/\/ Added 200 steps","stepCounter.totalSteps = 360","\/\/ About to set totalSteps to 360","\/\/ Added 160 steps","stepCounter.totalSteps = 896","\/\/ About to set totalSteps to 896","\/\/ Added 536 steps"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"StepCounter","type":"codeVoice"},{"text":" class declares a ","type":"text"},{"code":"totalSteps","type":"codeVoice"},{"text":" property of type ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":". This is a stored property with ","type":"text"},{"code":"willSet","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"didSet","type":"codeVoice"},{"text":" observers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"willSet","type":"codeVoice"},{"type":"text","text":" and "},{"code":"didSet","type":"codeVoice"},{"type":"text","text":" observers for "},{"code":"totalSteps","type":"codeVoice"},{"type":"text","text":" are called whenever the property is assigned a new value. This is true even if the new value is the same as the current value."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This example’s "},{"type":"codeVoice","code":"willSet"},{"type":"text","text":" observer uses a custom parameter name of "},{"type":"codeVoice","code":"newTotalSteps"},{"type":"text","text":" for the upcoming new value. In this example, it simply prints out the value that’s about to be set."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"didSet"},{"type":"text","text":" observer is called after the value of "},{"type":"codeVoice","code":"totalSteps"},{"type":"text","text":" is updated. It compares the new value of "},{"type":"codeVoice","code":"totalSteps"},{"type":"text","text":" against the old value. If the total number of steps has increased, a message is printed to indicate how many new steps have been taken. The "},{"type":"codeVoice","code":"didSet"},{"type":"text","text":" observer doesn’t provide a custom parameter name for the old value, and the default name of "},{"type":"codeVoice","code":"oldValue"},{"type":"text","text":" is used instead."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"If you pass a property that has observers to a function as an in-out parameter, the ","type":"text"},{"type":"codeVoice","code":"willSet"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"didSet"},{"text":" observers are always called. This is because of the copy-in copy-out memory model for in-out parameters: The value is always written back to the property at the end of the function. For a detailed discussion of the behavior of in-out parameters, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#In-Out-Parameters","type":"reference","isActive":true},{"text":".","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"anchor":"Property-Wrappers","text":"Property Wrappers","level":2,"type":"heading"},{"inlineContent":[{"text":"A property wrapper adds a layer of separation between code that manages how a property is stored and the code that defines a property. For example, if you have properties that provide thread-safety checks or store their underlying data in a database, you have to write that code on every property. When you use a property wrapper, you write the management code once when you define the wrapper, and then reuse that management code by applying it to multiple properties.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To define a property wrapper, you make a structure, enumeration, or class that defines a ","type":"text"},{"code":"wrappedValue","type":"codeVoice"},{"text":" property. In the code below, the ","type":"text"},{"code":"TwelveOrLess","type":"codeVoice"},{"text":" structure ensures that the value it wraps always contains a number less than or equal to 12. If you ask it to store a larger number, it stores 12 instead.","type":"text"}],"type":"paragraph"},{"code":["@propertyWrapper","struct TwelveOrLess {","    private var number = 0","    var wrappedValue: Int {","        get { return number }","        set { number = min(newValue, 12) }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The setter ensures that new values are less than or equal to 12, and the getter returns the stored value.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"The declaration for ","type":"text"},{"type":"codeVoice","code":"number"},{"text":" in the example above marks the variable as ","type":"text"},{"type":"codeVoice","code":"private"},{"text":", which ensures ","type":"text"},{"type":"codeVoice","code":"number"},{"text":" is used only in the implementation of ","type":"text"},{"type":"codeVoice","code":"TwelveOrLess"},{"text":". Code that’s written anywhere else accesses the value using the getter and setter for ","type":"text"},{"type":"codeVoice","code":"wrappedValue"},{"text":", and can’t use ","type":"text"},{"type":"codeVoice","code":"number"},{"text":" directly. For information about ","type":"text"},{"type":"codeVoice","code":"private"},{"text":", see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},{"text":".","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"type":"text","text":"You apply a wrapper to a property by writing the wrapper’s name before the property as an attribute. Here’s a structure that stores a rectangle that uses the "},{"type":"codeVoice","code":"TwelveOrLess"},{"type":"text","text":" property wrapper to ensure its dimensions are always 12 or less:"}],"type":"paragraph"},{"code":["struct SmallRectangle {","    @TwelveOrLess var height: Int","    @TwelveOrLess var width: Int","}","","var rectangle = SmallRectangle()","print(rectangle.height)","\/\/ Prints \"0\"","","rectangle.height = 10","print(rectangle.height)","\/\/ Prints \"10\"","","rectangle.height = 24","print(rectangle.height)","\/\/ Prints \"12\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"width","type":"codeVoice"},{"type":"text","text":" properties get their initial values from the definition of "},{"code":"TwelveOrLess","type":"codeVoice"},{"type":"text","text":", which sets "},{"code":"TwelveOrLess.number","type":"codeVoice"},{"type":"text","text":" to zero. The setter in "},{"code":"TwelveOrLess","type":"codeVoice"},{"type":"text","text":" treats 10 as a valid value so storing the number 10 in "},{"code":"rectangle.height","type":"codeVoice"},{"type":"text","text":" proceeds as written. However, 24 is larger than "},{"code":"TwelveOrLess","type":"codeVoice"},{"type":"text","text":" allows, so trying to store 24 end up setting "},{"code":"rectangle.height","type":"codeVoice"},{"type":"text","text":" to 12 instead, the largest allowed value."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"When you apply a wrapper to a property, the compiler synthesizes code that provides storage for the wrapper and code that provides access to the property through the wrapper. (The property wrapper is responsible for storing the wrapped value, so there’s no synthesized code for that.) You could write code that uses the behavior of a property wrapper, without taking advantage of the special attribute syntax. For example, here’s a version of "},{"code":"SmallRectangle","type":"codeVoice"},{"type":"text","text":" from the previous code listing that wraps its properties in the "},{"code":"TwelveOrLess","type":"codeVoice"},{"type":"text","text":" structure explicitly, instead of writing "},{"code":"@TwelveOrLess","type":"codeVoice"},{"type":"text","text":" as an attribute:"}],"type":"paragraph"},{"code":["struct SmallRectangle {","    private var _height = TwelveOrLess()","    private var _width = TwelveOrLess()","    var height: Int {","        get { return _height.wrappedValue }","        set { _height.wrappedValue = newValue }","    }","    var width: Int {","        get { return _width.wrappedValue }","        set { _width.wrappedValue = newValue }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"_height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"_width","type":"codeVoice"},{"type":"text","text":" properties store an instance of the property wrapper, "},{"code":"TwelveOrLess","type":"codeVoice"},{"type":"text","text":". The getter and setter for "},{"code":"height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"width","type":"codeVoice"},{"type":"text","text":" wrap access to the "},{"code":"wrappedValue","type":"codeVoice"},{"type":"text","text":" property."}],"type":"paragraph"},{"anchor":"Setting-Initial-Values-for-Wrapped-Properties","text":"Setting Initial Values for Wrapped Properties","level":3,"type":"heading"},{"inlineContent":[{"text":"The code in the examples above sets the initial value for the wrapped property by giving ","type":"text"},{"code":"number","type":"codeVoice"},{"text":" an initial value in the definition of ","type":"text"},{"code":"TwelveOrLess","type":"codeVoice"},{"text":". Code that uses this property wrapper can’t specify a different initial value for a property that’s wrapped by ","type":"text"},{"code":"TwelveOrLess","type":"codeVoice"},{"text":"—for example, the definition of ","type":"text"},{"code":"SmallRectangle","type":"codeVoice"},{"text":" can’t give ","type":"text"},{"code":"height","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"width","type":"codeVoice"},{"text":" initial values. To support setting an initial value or other customization, the property wrapper needs to add an initializer. Here’s an expanded version of ","type":"text"},{"code":"TwelveOrLess","type":"codeVoice"},{"text":" called ","type":"text"},{"code":"SmallNumber","type":"codeVoice"},{"text":" that defines initializers that set the wrapped and maximum value:","type":"text"}],"type":"paragraph"},{"code":["@propertyWrapper","struct SmallNumber {","    private var maximum: Int","    private var number: Int","","    var wrappedValue: Int {","        get { return number }","        set { number = min(newValue, maximum) }","    }","","    init() {","        maximum = 12","        number = 0","    }","    init(wrappedValue: Int) {","        maximum = 12","        number = min(wrappedValue, maximum)","    }","    init(wrappedValue: Int, maximum: Int) {","        self.maximum = maximum","        number = min(wrappedValue, maximum)","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The definition of "},{"code":"SmallNumber","type":"codeVoice"},{"type":"text","text":" includes three initializers—"},{"code":"init()","type":"codeVoice"},{"type":"text","text":", "},{"code":"init(wrappedValue:)","type":"codeVoice"},{"type":"text","text":", and "},{"code":"init(wrappedValue:maximum:)","type":"codeVoice"},{"type":"text","text":"—which the examples below use to set the wrapped value and the maximum value. For information about initialization and initializer syntax, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"When you apply a wrapper to a property and you don’t specify an initial value, Swift uses the "},{"type":"codeVoice","code":"init()"},{"type":"text","text":" initializer to set up the wrapper. For example:"}],"type":"paragraph"},{"code":["struct ZeroRectangle {","    @SmallNumber var height: Int","    @SmallNumber var width: Int","}","","var zeroRectangle = ZeroRectangle()","print(zeroRectangle.height, zeroRectangle.width)","\/\/ Prints \"0 0\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The instances of "},{"code":"SmallNumber","type":"codeVoice"},{"type":"text","text":" that wrap "},{"code":"height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"width","type":"codeVoice"},{"type":"text","text":" are created by calling "},{"code":"SmallNumber()","type":"codeVoice"},{"type":"text","text":". The code inside that initializer sets the initial wrapped value and the initial maximum value, using the default values of zero and 12. The property wrapper still provides all of the initial values, like the earlier example that used "},{"code":"TwelveOrLess","type":"codeVoice"},{"type":"text","text":" in "},{"code":"SmallRectangle","type":"codeVoice"},{"type":"text","text":". Unlike that example, "},{"code":"SmallNumber","type":"codeVoice"},{"type":"text","text":" also supports writing those initial values as part of declaring the property."}],"type":"paragraph"},{"inlineContent":[{"text":"When you specify an initial value for the property, Swift uses the ","type":"text"},{"type":"codeVoice","code":"init(wrappedValue:)"},{"text":" initializer to set up the wrapper. For example:","type":"text"}],"type":"paragraph"},{"code":["struct UnitRectangle {","    @SmallNumber var height: Int = 1","    @SmallNumber var width: Int = 1","}","","var unitRectangle = UnitRectangle()","print(unitRectangle.height, unitRectangle.width)","\/\/ Prints \"1 1\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"When you write ","type":"text"},{"code":"= 1","type":"codeVoice"},{"text":" on a property with a wrapper, that’s translated into a call to the ","type":"text"},{"code":"init(wrappedValue:)","type":"codeVoice"},{"text":" initializer. The instances of ","type":"text"},{"code":"SmallNumber","type":"codeVoice"},{"text":" that wrap ","type":"text"},{"code":"height","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"width","type":"codeVoice"},{"text":" are created by calling ","type":"text"},{"code":"SmallNumber(wrappedValue: 1)","type":"codeVoice"},{"text":". The initializer uses the wrapped value that’s specified here, and it uses the default maximum value of 12.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"When you write arguments in parentheses after the custom attribute, Swift uses the initializer that accepts those arguments to set up the wrapper. For example, if you provide an initial value and a maximum value, Swift uses the ","type":"text"},{"code":"init(wrappedValue:maximum:)","type":"codeVoice"},{"text":" initializer:","type":"text"}],"type":"paragraph"},{"code":["struct NarrowRectangle {","    @SmallNumber(wrappedValue: 2, maximum: 5) var height: Int","    @SmallNumber(wrappedValue: 3, maximum: 4) var width: Int","}","","var narrowRectangle = NarrowRectangle()","print(narrowRectangle.height, narrowRectangle.width)","\/\/ Prints \"2 3\"","","narrowRectangle.height = 100","narrowRectangle.width = 100","print(narrowRectangle.height, narrowRectangle.width)","\/\/ Prints \"5 4\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The instance of ","type":"text"},{"type":"codeVoice","code":"SmallNumber"},{"text":" that wraps ","type":"text"},{"type":"codeVoice","code":"height"},{"text":" is created by calling ","type":"text"},{"type":"codeVoice","code":"SmallNumber(wrappedValue: 2, maximum: 5)"},{"text":", and the instance that wraps ","type":"text"},{"type":"codeVoice","code":"width"},{"text":" is created by calling ","type":"text"},{"type":"codeVoice","code":"SmallNumber(wrappedValue: 3, maximum: 4)"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"By including arguments to the property wrapper, you can set up the initial state in the wrapper or pass other options to the wrapper when it’s created. This syntax is the most general way to use a property wrapper. You can provide whatever arguments you need to the attribute, and they’re passed to the initializer.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"When you include property wrapper arguments, you can also specify an initial value using assignment. Swift treats the assignment like a "},{"type":"codeVoice","code":"wrappedValue"},{"type":"text","text":" argument and uses the initializer that accepts the arguments you include. For example:"}],"type":"paragraph"},{"code":["struct MixedRectangle {","    @SmallNumber var height: Int = 1","    @SmallNumber(maximum: 9) var width: Int = 2","}","","var mixedRectangle = MixedRectangle()","print(mixedRectangle.height)","\/\/ Prints \"1\"","","mixedRectangle.height = 20","print(mixedRectangle.height)","\/\/ Prints \"12\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The instance of ","type":"text"},{"type":"codeVoice","code":"SmallNumber"},{"text":" that wraps ","type":"text"},{"type":"codeVoice","code":"height"},{"text":" is created by calling ","type":"text"},{"type":"codeVoice","code":"SmallNumber(wrappedValue: 1)"},{"text":", which uses the default maximum value of 12. The instance that wraps ","type":"text"},{"type":"codeVoice","code":"width"},{"text":" is created by calling ","type":"text"},{"type":"codeVoice","code":"SmallNumber(wrappedValue: 2, maximum: 9)"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Projecting-a-Value-From-a-Property-Wrapper","text":"Projecting a Value From a Property Wrapper","level":3,"type":"heading"},{"inlineContent":[{"text":"In addition to the wrapped value, a property wrapper can expose additional functionality by defining a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"projected value"}]},{"text":"—for example, a property wrapper that manages access to a database can expose a ","type":"text"},{"code":"flushDatabaseConnection()","type":"codeVoice"},{"text":" method on its projected value. The name of the projected value is the same as the wrapped value, except it begins with a dollar sign (","type":"text"},{"code":"$","type":"codeVoice"},{"text":"). Because your code can’t define properties that start with ","type":"text"},{"code":"$","type":"codeVoice"},{"text":" the projected value never interferes with properties you define.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In the ","type":"text"},{"code":"SmallNumber","type":"codeVoice"},{"text":" example above, if you try to set the property to a number that’s too large, the property wrapper adjusts the number before storing it. The code below adds a ","type":"text"},{"code":"projectedValue","type":"codeVoice"},{"text":" property to the ","type":"text"},{"code":"SmallNumber","type":"codeVoice"},{"text":" structure to keep track of whether the property wrapper adjusted the new value for the property before storing that new value.","type":"text"}],"type":"paragraph"},{"code":["@propertyWrapper","struct SmallNumber {","    private var number: Int","    private(set) var projectedValue: Bool","","    var wrappedValue: Int {","        get { return number }","        set {","            if newValue > 12 {","                number = 12","                projectedValue = true","            } else {","                number = newValue","                projectedValue = false","            }","        }","    }","","    init() {","        self.number = 0","        self.projectedValue = false","    }","}","struct SomeStructure {","    @SmallNumber var someNumber: Int","}","var someStructure = SomeStructure()","","someStructure.someNumber = 4","print(someStructure.$someNumber)","\/\/ Prints \"false\"","","someStructure.someNumber = 55","print(someStructure.$someNumber)","\/\/ Prints \"true\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Writing ","type":"text"},{"code":"someStructure.$someNumber","type":"codeVoice"},{"text":" accesses the wrapper’s projected value. After storing a small number like four, the value of ","type":"text"},{"code":"someStructure.$someNumber","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"false","type":"codeVoice"},{"text":". However, the projected value is ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" after trying to store a number that’s too large, like 55.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A property wrapper can return a value of any type as its projected value. In this example, the property wrapper exposes only one piece of information—whether the number was adjusted—so it exposes that Boolean value as its projected value. A wrapper that needs to expose more information can return an instance of some other data type, or it can return "},{"code":"self","type":"codeVoice"},{"type":"text","text":" to expose the instance of the wrapper as its projected value."}],"type":"paragraph"},{"inlineContent":[{"text":"When you access a projected value from code that’s part of the type, like a property getter or an instance method, you can omit ","type":"text"},{"code":"self.","type":"codeVoice"},{"text":" before the property name, just like accessing other properties. The code in the following example refers to the projected value of the wrapper around ","type":"text"},{"code":"height","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"width","type":"codeVoice"},{"text":" as ","type":"text"},{"code":"$height","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"$width","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["enum Size {","    case small, large","}","","struct SizedRectangle {","    @SmallNumber var height: Int","    @SmallNumber var width: Int","","    mutating func resize(to size: Size) -> Bool {","        switch size {","        case .small:","            height = 10","            width = 20","        case .large:","            height = 100","            width = 100","        }","        return $height || $width","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Because property wrapper syntax is just syntactic sugar for a property with a getter and a setter, accessing "},{"code":"height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"width","type":"codeVoice"},{"type":"text","text":" behaves the same as accessing any other property. For example, the code in "},{"code":"resize(to:)","type":"codeVoice"},{"type":"text","text":" accesses "},{"code":"height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"width","type":"codeVoice"},{"type":"text","text":" using their property wrapper. If you call "},{"code":"resize(to: .large)","type":"codeVoice"},{"type":"text","text":", the switch case for "},{"code":".large","type":"codeVoice"},{"type":"text","text":" sets the rectangle’s height and width to 100. The wrapper prevents the value of those properties from being larger than 12, and it sets the projected value to "},{"code":"true","type":"codeVoice"},{"type":"text","text":", to record the fact that it adjusted their values. At the end of "},{"code":"resize(to:)","type":"codeVoice"},{"type":"text","text":", the return statement checks "},{"code":"$height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"$width","type":"codeVoice"},{"type":"text","text":" to determine whether the property wrapper adjusted either "},{"code":"height","type":"codeVoice"},{"type":"text","text":" or "},{"code":"width","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Global-and-Local-Variables","text":"Global and Local Variables","level":2,"type":"heading"},{"inlineContent":[{"text":"The capabilities described above for computing and observing properties are also available to ","type":"text"},{"inlineContent":[{"type":"text","text":"global variables"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"local variables","type":"text"}],"type":"emphasis"},{"text":". Global variables are variables that are defined outside of any function, method, closure, or type context. Local variables are variables that are defined within a function, method, or closure context.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The global and local variables you have encountered in previous chapters have all been "},{"type":"emphasis","inlineContent":[{"type":"text","text":"stored variables"}]},{"type":"text","text":". Stored variables, like stored properties, provide storage for a value of a certain type and allow that value to be set and retrieved."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, you can also define "},{"inlineContent":[{"type":"text","text":"computed variables"}],"type":"emphasis"},{"type":"text","text":" and define observers for stored variables, in either a global or local scope. Computed variables calculate their value, rather than storing it, and they’re written in the same way as computed properties."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Global constants and variables are always computed lazily, in a similar manner to ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties#Lazy-Stored-Properties"},{"text":". Unlike lazy stored properties, global constants and variables don’t need to be marked with the ","type":"text"},{"type":"codeVoice","code":"lazy"},{"text":" modifier.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Local constants and variables are never computed lazily.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"type":"text","text":"You can apply a property wrapper to a local stored variable, but not to a global variable or a computed variable. For example, in the code below, "},{"type":"codeVoice","code":"myNumber"},{"type":"text","text":" uses "},{"type":"codeVoice","code":"SmallNumber"},{"type":"text","text":" as a property wrapper."}],"type":"paragraph"},{"code":["func someFunction() {","    @SmallNumber var myNumber: Int = 0","","    myNumber = 10","    \/\/ now myNumber is 10","","    myNumber = 24","    \/\/ now myNumber is 12","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Like when you apply ","type":"text"},{"type":"codeVoice","code":"SmallNumber"},{"text":" to a property, setting the value of ","type":"text"},{"type":"codeVoice","code":"myNumber"},{"text":" to 10 is valid. Because the property wrapper doesn’t allow values higher than 12, it sets ","type":"text"},{"type":"codeVoice","code":"myNumber"},{"text":" to 12 instead of 24.","type":"text"}],"type":"paragraph"},{"anchor":"Type-Properties","text":"Type Properties","level":2,"type":"heading"},{"inlineContent":[{"text":"Instance properties are properties that belong to an instance of a particular type. Every time you create a new instance of that type, it has its own set of property values, separate from any other instance.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can also define properties that belong to the type itself, not to any one instance of that type. There will only ever be one copy of these properties, no matter how many instances of that type you create. These kinds of properties are called "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type properties"}]},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Type properties are useful for defining values that are universal to "},{"inlineContent":[{"type":"text","text":"all"}],"type":"emphasis"},{"type":"text","text":" instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that’s global to all instances of that type (like a static variable in C)."}],"type":"paragraph"},{"inlineContent":[{"text":"Stored type properties can be variables or constants. Computed type properties are always declared as variable properties, in the same way as computed instance properties.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"Unlike stored instance properties, you must always give stored type properties a default value. This is because the type itself doesn’t have an initializer that can assign a value to a stored type property at initialization time."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Stored type properties are lazily initialized on their first access. They’re guaranteed to be initialized only once, even when accessed by multiple threads simultaneously, and they don’t need to be marked with the "},{"type":"codeVoice","code":"lazy"},{"type":"text","text":" modifier."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"anchor":"Type-Property-Syntax","text":"Type Property Syntax","level":3,"type":"heading"},{"inlineContent":[{"text":"In C and Objective-C, you define static constants and variables associated with a type as ","type":"text"},{"inlineContent":[{"type":"text","text":"global"}],"type":"emphasis"},{"text":" static variables. In Swift, however, type properties are written as part of the type’s definition, within the type’s outer curly braces, and each type property is explicitly scoped to the type it supports.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You define type properties with the "},{"type":"codeVoice","code":"static"},{"type":"text","text":" keyword. For computed type properties for class types, you can use the "},{"type":"codeVoice","code":"class"},{"type":"text","text":" keyword instead to allow subclasses to override the superclass’s implementation. The example below shows the syntax for stored and computed type properties:"}],"type":"paragraph"},{"code":["struct SomeStructure {","    static var storedTypeProperty = \"Some value.\"","    static var computedTypeProperty: Int {","        return 1","    }","}","enum SomeEnumeration {","    static var storedTypeProperty = \"Some value.\"","    static var computedTypeProperty: Int {","        return 6","    }","}","class SomeClass {","    static var storedTypeProperty = \"Some value.\"","    static var computedTypeProperty: Int {","        return 27","    }","    class var overrideableComputedTypeProperty: Int {","        return 107","    }","}"],"syntax":"swift","type":"codeListing"},{"content":[{"inlineContent":[{"text":"The computed type property examples above are for read-only computed type properties, but you can also define read-write computed type properties with the same syntax as for computed instance properties.","type":"text"}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"anchor":"Querying-and-Setting-Type-Properties","text":"Querying and Setting Type Properties","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"Type properties are queried and set with dot syntax, just like instance properties. However, type properties are queried and set on the "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":", not on an instance of that type. For example:"}],"type":"paragraph"},{"code":["print(SomeStructure.storedTypeProperty)","\/\/ Prints \"Some value.\"","SomeStructure.storedTypeProperty = \"Another value.\"","print(SomeStructure.storedTypeProperty)","\/\/ Prints \"Another value.\"","print(SomeEnumeration.computedTypeProperty)","\/\/ Prints \"6\"","print(SomeClass.computedTypeProperty)","\/\/ Prints \"27\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The examples that follow use two stored type properties as part of a structure that models an audio level meter for a number of audio channels. Each channel has an integer audio level between "},{"type":"codeVoice","code":"0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"10"},{"type":"text","text":" inclusive."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The figure below illustrates how two of these audio channels can be combined to model a stereo audio level meter. When a channel’s audio level is "},{"code":"0","type":"codeVoice"},{"type":"text","text":", none of the lights for that channel are lit. When the audio level is "},{"code":"10","type":"codeVoice"},{"type":"text","text":", all of the lights for that channel are lit. In this figure, the left channel has a current level of "},{"code":"9","type":"codeVoice"},{"type":"text","text":", and the right channel has a current level of "},{"code":"7","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"inlineContent":[{"identifier":"staticPropertiesVUMeter","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The audio channels described above are represented by instances of the "},{"type":"codeVoice","code":"AudioChannel"},{"type":"text","text":" structure:"}],"type":"paragraph"},{"code":["struct AudioChannel {","    static let thresholdLevel = 10","    static var maxInputLevelForAllChannels = 0","    var currentLevel: Int = 0 {","        didSet {","            if currentLevel > AudioChannel.thresholdLevel {","                \/\/ cap the new audio level to the threshold level","                currentLevel = AudioChannel.thresholdLevel","            }","            if currentLevel > AudioChannel.maxInputLevelForAllChannels {","                \/\/ store this as the new overall maximum input level","                AudioChannel.maxInputLevelForAllChannels = currentLevel","            }","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"AudioChannel"},{"type":"text","text":" structure defines two stored type properties to support its functionality. The first, "},{"type":"codeVoice","code":"thresholdLevel"},{"type":"text","text":", defines the maximum threshold value an audio level can take. This is a constant value of "},{"type":"codeVoice","code":"10"},{"type":"text","text":" for all "},{"type":"codeVoice","code":"AudioChannel"},{"type":"text","text":" instances. If an audio signal comes in with a higher value than "},{"type":"codeVoice","code":"10"},{"type":"text","text":", it will be capped to this threshold value (as described below)."}],"type":"paragraph"},{"inlineContent":[{"text":"The second type property is a variable stored property called ","type":"text"},{"type":"codeVoice","code":"maxInputLevelForAllChannels"},{"text":". This keeps track of the maximum input value that has been received by ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"text":" ","type":"text"},{"type":"codeVoice","code":"AudioChannel"},{"text":" instance. It starts with an initial value of ","type":"text"},{"type":"codeVoice","code":"0"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"AudioChannel","type":"codeVoice"},{"text":" structure also defines a stored instance property called ","type":"text"},{"code":"currentLevel","type":"codeVoice"},{"text":", which represents the channel’s current audio level on a scale of ","type":"text"},{"code":"0","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"10","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"currentLevel"},{"type":"text","text":" property has a "},{"type":"codeVoice","code":"didSet"},{"type":"text","text":" property observer to check the value of "},{"type":"codeVoice","code":"currentLevel"},{"type":"text","text":" whenever it’s set. This observer performs two checks:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the new value of "},{"code":"currentLevel","type":"codeVoice"},{"type":"text","text":" is greater than the allowed "},{"code":"thresholdLevel","type":"codeVoice"},{"type":"text","text":", the property observer caps "},{"code":"currentLevel","type":"codeVoice"},{"type":"text","text":" to "},{"code":"thresholdLevel","type":"codeVoice"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"If the new value of ","type":"text"},{"type":"codeVoice","code":"currentLevel"},{"text":" (after any capping) is higher than any value previously received by ","type":"text"},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"codeVoice","code":"AudioChannel"},{"text":" instance, the property observer stores the new ","type":"text"},{"type":"codeVoice","code":"currentLevel"},{"text":" value in the ","type":"text"},{"type":"codeVoice","code":"maxInputLevelForAllChannels"},{"text":" type property.","type":"text"}]}]}],"type":"unorderedList"},{"content":[{"inlineContent":[{"type":"text","text":"In the first of these two checks, the "},{"code":"didSet","type":"codeVoice"},{"type":"text","text":" observer sets "},{"code":"currentLevel","type":"codeVoice"},{"type":"text","text":" to a different value. This doesn’t, however, cause the observer to be called again."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"You can use the ","type":"text"},{"code":"AudioChannel","type":"codeVoice"},{"text":" structure to create two new audio channels called ","type":"text"},{"code":"leftChannel","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"rightChannel","type":"codeVoice"},{"text":", to represent the audio levels of a stereo sound system:","type":"text"}],"type":"paragraph"},{"code":["var leftChannel = AudioChannel()","var rightChannel = AudioChannel()"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"If you set the ","type":"text"},{"type":"codeVoice","code":"currentLevel"},{"text":" of the ","type":"text"},{"inlineContent":[{"text":"left","type":"text"}],"type":"emphasis"},{"text":" channel to ","type":"text"},{"type":"codeVoice","code":"7"},{"text":", you can see that the ","type":"text"},{"type":"codeVoice","code":"maxInputLevelForAllChannels"},{"text":" type property is updated to equal ","type":"text"},{"type":"codeVoice","code":"7"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["leftChannel.currentLevel = 7","print(leftChannel.currentLevel)","\/\/ Prints \"7\"","print(AudioChannel.maxInputLevelForAllChannels)","\/\/ Prints \"7\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If you try to set the "},{"type":"codeVoice","code":"currentLevel"},{"type":"text","text":" of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"right"}]},{"type":"text","text":" channel to "},{"type":"codeVoice","code":"11"},{"type":"text","text":", you can see that the right channel’s "},{"type":"codeVoice","code":"currentLevel"},{"type":"text","text":" property is capped to the maximum value of "},{"type":"codeVoice","code":"10"},{"type":"text","text":", and the "},{"type":"codeVoice","code":"maxInputLevelForAllChannels"},{"type":"text","text":" type property is updated to equal "},{"type":"codeVoice","code":"10"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["rightChannel.currentLevel = 11","print(rightChannel.currentLevel)","\/\/ Prints \"10\"","print(AudioChannel.maxInputLevelForAllChannels)","\/\/ Prints \"10\""],"syntax":"swift","type":"codeListing"}]}],"references":{"doc://com.apple.Swift/documentation/Swift/Initialization#Initializer-Delegation-for-Class-Types":{"type":"topic","title":"Initializer Delegation for Class Types","url":"\/documentation\/swift\/initialization#Initializer-Delegation-for-Class-Types","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Delegation-for-Class-Types","kind":"section"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"url":"\/documentation\/swift\/stringsandcharacters","role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","kind":"article","url":"\/documentation\/swift\/extensions","title":"Extensions"},"doc://com.apple.Swift/documentation/Swift/Declarations#In-Out-Parameters":{"type":"topic","kind":"section","title":"In-Out Parameters","url":"\/documentation\/swift\/declarations#In-Out-Parameters","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#In-Out-Parameters","abstract":[]},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"title":"Initialization","url":"\/documentation\/swift\/initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","url":"\/documentation\/swift\/concurrency","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"type":"text","text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"text":"inherit","type":"text"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"text":"subclass","type":"text"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/inheritance","title":"Inheritance","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/Generics":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"url":"\/documentation\/swift\/generics","role":"article","title":"Generics","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"url":"\/documentation\/swift\/collectiontypes","role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Closures":{"url":"\/documentation\/swift\/closures","role":"article","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"url":"\/documentation\/swift\/advancedoperators","role":"article","title":"Advanced Operators","abstract":[{"type":"text","text":"In addition to the operators described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"title":"Automatic Reference Counting","url":"\/documentation\/swift\/automaticreferencecounting","abstract":[{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"text":"conform","type":"text"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","url":"\/documentation\/swift\/protocols","title":"Protocols"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"title":"Nested Types","url":"\/documentation\/swift\/nestedtypes","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nested types","type":"text"}]},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"role":"article","abstract":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","kind":"article","url":"\/documentation\/swift\/enumerations","title":"Enumerations"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"text":" is called immediately before a class instance is deallocated. You write deinitializers with the ","type":"text"},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","kind":"article","url":"\/documentation\/swift\/deinitialization","title":"Deinitialization"},"doc://com.apple.Swift/documentation/Swift/Inheritance#Overriding":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance#Overriding","abstract":[],"title":"Overriding","kind":"section","type":"topic","url":"\/documentation\/swift\/inheritance#Overriding"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","url":"\/documentation\/swift\/functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","abstract":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") adds two numbers, as in ","type":"text"},{"code":"let i = 1 + 2","type":"codeVoice"},{"text":", and the logical AND operator (","type":"text"},{"code":"&&","type":"codeVoice"},{"text":") combines two Boolean values, as in ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"text":".","type":"text"}],"kind":"article","url":"\/documentation\/swift\/basicoperators","title":"Basic Operators","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"title":"Subscripts","url":"\/documentation\/swift\/subscripts","abstract":[{"text":"Classes, structures, and enumerations can define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instance as "},{"code":"someArray[index]","type":"codeVoice"},{"type":"text","text":" and elements in a "},{"code":"Dictionary","type":"codeVoice"},{"text":" instance as ","type":"text"},{"type":"codeVoice","code":"someDictionary[key]"},{"text":".","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","url":"\/documentation\/swift\/accesscontrol","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/swift\/optionalchaining","role":"article","title":"Optional Chaining","abstract":[{"inlineContent":[{"text":"Optional chaining","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", the property, method, or subscript call returns "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},"computedProperties":{"type":"image","variants":[{"traits":["2x","light"],"url":"\/images\/computedProperties@2x.png"}],"alt":null,"identifier":"computedProperties"},"doc://com.apple.Swift/documentation/Swift/Properties#Lazy-Stored-Properties":{"kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties#Lazy-Stored-Properties","title":"Lazy Stored Properties","url":"\/documentation\/swift\/properties#Lazy-Stored-Properties","type":"topic","abstract":[]},"doc://com.apple.Swift/documentation/Swift/Initialization#Assigning-Constant-Properties-During-Initialization":{"type":"topic","title":"Assigning Constant Properties During Initialization","url":"\/documentation\/swift\/initialization#Assigning-Constant-Properties-During-Initialization","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Assigning-Constant-Properties-During-Initialization","kind":"section"},"staticPropertiesVUMeter":{"variants":[{"traits":["2x","light"],"url":"\/images\/staticPropertiesVUMeter@2x.png"}],"type":"image","alt":null,"identifier":"staticPropertiesVUMeter"},"doc://com.apple.Swift/documentation/Swift/Functions#Functions-With-an-Implicit-Return":{"title":"Functions With an Implicit Return","url":"\/documentation\/swift\/functions#Functions-With-an-Implicit-Return","abstract":[],"kind":"section","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Functions-With-an-Implicit-Return"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"title":"Opaque Types","role":"article","kind":"article","url":"\/documentation\/swift\/opaquetypes","type":"topic","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"classes","type":"text"}]},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","kind":"article","url":"\/documentation\/swift\/classesandstructures","title":"Structures and Classes"},"doc://com.apple.Swift/documentation/Swift/Initialization#Initializer-Delegation-for-Value-Types":{"type":"topic","title":"Initializer Delegation for Value Types","url":"\/documentation\/swift\/initialization#Initializer-Delegation-for-Value-Types","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Delegation-for-Value-Types","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Initialization#Default-Property-Values":{"type":"topic","title":"Default Property Values","url":"\/documentation\/swift\/initialization#Default-Property-Values","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Default-Property-Values","kind":"section"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"title":"Memory Safety","url":"\/documentation\/swift\/memorysafety","abstract":[{"text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"url":"\/documentation\/swift\/typecasting","role":"article","title":"Type Casting","abstract":[{"inlineContent":[{"type":"text","text":"Type casting"}],"type":"emphasis"},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"url":"\/documentation\/swift\/errorhandling","role":"article","title":"Error Handling","abstract":[{"inlineContent":[{"type":"text","text":"Error handling"}],"type":"emphasis"},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","role":"article","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","type":"topic"}}}