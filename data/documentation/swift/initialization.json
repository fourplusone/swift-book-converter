{"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"text":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"You implement this initialization process by defining "},{"inlineContent":[{"text":"initializers","type":"text"}],"type":"emphasis"},{"type":"text","text":", which are like special methods that can be called to create a new instance of a particular type. Unlike Objective-C initializers, Swift initializers don’t return a value. Their primary role is to ensure that new instances of a type are correctly initialized before they’re used for the first time."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Instances of class types can also implement a "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":", which performs any custom cleanup just before an instance of that class is deallocated. For more information about deinitializers, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Setting-Initial-Values-for-Stored-Properties","level":2,"text":"Setting Initial Values for Stored Properties","type":"heading"},{"inlineContent":[{"type":"text","text":"Classes and structures "},{"inlineContent":[{"type":"text","text":"must"}],"type":"emphasis"},{"type":"text","text":" set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties can’t be left in an indeterminate state."}],"type":"paragraph"},{"inlineContent":[{"text":"You can set an initial value for a stored property within an initializer, or by assigning a default property value as part of the property’s definition. These actions are described in the following sections.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When you assign a default value to a stored property, or set its initial value within an initializer, the value of that property is set directly, without calling any property observers."}]}],"style":"note","name":"Note","type":"aside"},{"anchor":"Initializers","level":3,"text":"Initializers","type":"heading"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Initializers"}],"type":"emphasis"},{"text":" are called to create a new instance of a particular type. In its simplest form, an initializer is like an instance method with no parameters, written using the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["init() {","    \/\/ perform some initialization here","}"]},{"inlineContent":[{"text":"The example below defines a new structure called ","type":"text"},{"code":"Fahrenheit","type":"codeVoice"},{"text":" to store temperatures expressed in the Fahrenheit scale. The ","type":"text"},{"code":"Fahrenheit","type":"codeVoice"},{"text":" structure has one stored property, ","type":"text"},{"code":"temperature","type":"codeVoice"},{"text":", which is of type ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Fahrenheit {","    var temperature: Double","    init() {","        temperature = 32.0","    }","}","var f = Fahrenheit()","print(\"The default temperature is \\(f.temperature)° Fahrenheit\")","\/\/ Prints \"The default temperature is 32.0° Fahrenheit\""]},{"inlineContent":[{"type":"text","text":"The structure defines a single initializer, "},{"code":"init","type":"codeVoice"},{"type":"text","text":", with no parameters, which initializes the stored temperature with a value of "},{"code":"32.0","type":"codeVoice"},{"type":"text","text":" (the freezing point of water in degrees Fahrenheit)."}],"type":"paragraph"},{"anchor":"Default-Property-Values","level":3,"text":"Default Property Values","type":"heading"},{"inlineContent":[{"type":"text","text":"You can set the initial value of a stored property from within an initializer, as shown above. Alternatively, specify a "},{"type":"emphasis","inlineContent":[{"text":"default property value","type":"text"}]},{"type":"text","text":" as part of the property’s declaration. You specify a default property value by assigning an initial value to the property when it’s defined."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"If a property always takes the same initial value, provide a default value rather than setting a value within an initializer. The end result is the same, but the default value ties the property’s initialization more closely to its declaration. It makes for shorter, clearer initializers and enables you to infer the type of the property from its default value. The default value also makes it easier for you to take advantage of default initializers and initializer inheritance, as described later in this chapter.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"You can write the ","type":"text"},{"code":"Fahrenheit","type":"codeVoice"},{"text":" structure from above in a simpler form by providing a default value for its ","type":"text"},{"code":"temperature","type":"codeVoice"},{"text":" property at the point that the property is declared:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Fahrenheit {","    var temperature = 32.0","}"]},{"anchor":"Customizing-Initialization","level":2,"text":"Customizing Initialization","type":"heading"},{"inlineContent":[{"text":"You can customize the initialization process with input parameters and optional property types, or by assigning constant properties during initialization, as described in the following sections.","type":"text"}],"type":"paragraph"},{"anchor":"Initialization-Parameters","level":3,"text":"Initialization Parameters","type":"heading"},{"inlineContent":[{"type":"text","text":"You can provide "},{"type":"emphasis","inlineContent":[{"text":"initialization parameters","type":"text"}]},{"type":"text","text":" as part of an initializer’s definition, to define the types and names of values that customize the initialization process. Initialization parameters have the same capabilities and syntax as function and method parameters."}],"type":"paragraph"},{"inlineContent":[{"text":"The following example defines a structure called ","type":"text"},{"code":"Celsius","type":"codeVoice"},{"text":", which stores temperatures expressed in degrees Celsius. The ","type":"text"},{"code":"Celsius","type":"codeVoice"},{"text":" structure implements two custom initializers called ","type":"text"},{"code":"init(fromFahrenheit:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"init(fromKelvin:)","type":"codeVoice"},{"text":", which initialize a new instance of the structure with a value from a different temperature scale:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Celsius {","    var temperatureInCelsius: Double","    init(fromFahrenheit fahrenheit: Double) {","        temperatureInCelsius = (fahrenheit - 32.0) \/ 1.8","    }","    init(fromKelvin kelvin: Double) {","        temperatureInCelsius = kelvin - 273.15","    }","}","let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)","\/\/ boilingPointOfWater.temperatureInCelsius is 100.0","let freezingPointOfWater = Celsius(fromKelvin: 273.15)","\/\/ freezingPointOfWater.temperatureInCelsius is 0.0"]},{"inlineContent":[{"text":"The first initializer has a single initialization parameter with an argument label of ","type":"text"},{"code":"fromFahrenheit","type":"codeVoice"},{"text":" and a parameter name of ","type":"text"},{"code":"fahrenheit","type":"codeVoice"},{"text":". The second initializer has a single initialization parameter with an argument label of ","type":"text"},{"code":"fromKelvin","type":"codeVoice"},{"text":" and a parameter name of ","type":"text"},{"code":"kelvin","type":"codeVoice"},{"text":". Both initializers convert their single argument into the corresponding Celsius value and store this value in a property called ","type":"text"},{"code":"temperatureInCelsius","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Parameter-Names-and-Argument-Labels","level":3,"text":"Parameter Names and Argument Labels","type":"heading"},{"inlineContent":[{"text":"As with function and method parameters, initialization parameters can have both a parameter name for use within the initializer’s body and an argument label for use when calling the initializer.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, initializers don’t have an identifying function name before their parentheses in the way that functions and methods do. Therefore, the names and types of an initializer’s parameters play a particularly important role in identifying which initializer should be called. Because of this, Swift provides an automatic argument label for "},{"type":"emphasis","inlineContent":[{"type":"text","text":"every"}]},{"type":"text","text":" parameter in an initializer if you don’t provide one."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following example defines a structure called "},{"type":"codeVoice","code":"Color"},{"type":"text","text":", with three constant properties called "},{"type":"codeVoice","code":"red"},{"type":"text","text":", "},{"type":"codeVoice","code":"green"},{"type":"text","text":", and "},{"type":"codeVoice","code":"blue"},{"type":"text","text":". These properties store a value between "},{"type":"codeVoice","code":"0.0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"1.0"},{"type":"text","text":" to indicate the amount of red, green, and blue in the color."}],"type":"paragraph"},{"inlineContent":[{"code":"Color","type":"codeVoice"},{"text":" provides an initializer with three appropriately named parameters of type ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" for its red, green, and blue components. ","type":"text"},{"code":"Color","type":"codeVoice"},{"text":" also provides a second initializer with a single ","type":"text"},{"code":"white","type":"codeVoice"},{"text":" parameter, which is used to provide the same value for all three color components.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Color {","    let red, green, blue: Double","    init(red: Double, green: Double, blue: Double) {","        self.red   = red","        self.green = green","        self.blue  = blue","    }","    init(white: Double) {","        red   = white","        green = white","        blue  = white","    }","}"]},{"inlineContent":[{"type":"text","text":"Both initializers can be used to create a new "},{"type":"codeVoice","code":"Color"},{"type":"text","text":" instance, by providing named values for each initializer parameter:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)","let halfGray = Color(white: 0.5)"]},{"inlineContent":[{"text":"Note that it isn’t possible to call these initializers without using argument labels. Argument labels must always be used in an initializer if they’re defined, and omitting them is a compile-time error:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let veryGreen = Color(0.0, 1.0, 0.0)","\/\/ this reports a compile-time error - argument labels are required"]},{"anchor":"Initializer-Parameters-Without-Argument-Labels","level":3,"text":"Initializer Parameters Without Argument Labels","type":"heading"},{"inlineContent":[{"type":"text","text":"If you don’t want to use an argument label for an initializer parameter, write an underscore ("},{"type":"codeVoice","code":"_"},{"type":"text","text":") instead of an explicit argument label for that parameter to override the default behavior."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s an expanded version of the "},{"code":"Celsius","type":"codeVoice"},{"type":"text","text":" example from "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initialization-Parameters","isActive":true,"type":"reference"},{"type":"text","text":" above, with an additional initializer to create a new "},{"code":"Celsius","type":"codeVoice"},{"type":"text","text":" instance from a "},{"code":"Double","type":"codeVoice"},{"type":"text","text":" value that’s already in the Celsius scale:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Celsius {","    var temperatureInCelsius: Double","    init(fromFahrenheit fahrenheit: Double) {","        temperatureInCelsius = (fahrenheit - 32.0) \/ 1.8","    }","    init(fromKelvin kelvin: Double) {","        temperatureInCelsius = kelvin - 273.15","    }","    init(_ celsius: Double) {","        temperatureInCelsius = celsius","    }","}","let bodyTemperature = Celsius(37.0)","\/\/ bodyTemperature.temperatureInCelsius is 37.0"]},{"inlineContent":[{"text":"The initializer call ","type":"text"},{"type":"codeVoice","code":"Celsius(37.0)"},{"text":" is clear in its intent without the need for an argument label. It’s therefore appropriate to write this initializer as ","type":"text"},{"type":"codeVoice","code":"init(_ celsius: Double)"},{"text":" so that it can be called by providing an unnamed ","type":"text"},{"type":"codeVoice","code":"Double"},{"text":" value.","type":"text"}],"type":"paragraph"},{"anchor":"Optional-Property-Types","level":3,"text":"Optional Property Types","type":"heading"},{"inlineContent":[{"text":"If your custom type has a stored property that’s logically allowed to have “no value”—perhaps because its value can’t be set during initialization, or because it’s allowed to have “no value” at some later point—declare the property with an ","type":"text"},{"inlineContent":[{"type":"text","text":"optional"}],"type":"emphasis"},{"text":" type. Properties of optional type are automatically initialized with a value of ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", indicating that the property is deliberately intended to have “no value yet” during initialization.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following example defines a class called "},{"code":"SurveyQuestion","type":"codeVoice"},{"type":"text","text":", with an optional "},{"code":"String","type":"codeVoice"},{"type":"text","text":" property called "},{"code":"response","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class SurveyQuestion {","    var text: String","    var response: String?","    init(text: String) {","        self.text = text","    }","    func ask() {","        print(text)","    }","}","let cheeseQuestion = SurveyQuestion(text: \"Do you like cheese?\")","cheeseQuestion.ask()","\/\/ Prints \"Do you like cheese?\"","cheeseQuestion.response = \"Yes, I do like cheese.\""]},{"inlineContent":[{"type":"text","text":"The response to a survey question can’t be known until it’s asked, and so the "},{"type":"codeVoice","code":"response"},{"type":"text","text":" property is declared with a type of "},{"type":"codeVoice","code":"String?"},{"type":"text","text":", or “optional "},{"type":"codeVoice","code":"String"},{"type":"text","text":"”. It’s automatically assigned a default value of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", meaning “no string yet”, when a new instance of "},{"type":"codeVoice","code":"SurveyQuestion"},{"type":"text","text":" is initialized."}],"type":"paragraph"},{"anchor":"Assigning-Constant-Properties-During-Initialization","level":3,"text":"Assigning Constant Properties During Initialization","type":"heading"},{"inlineContent":[{"type":"text","text":"You can assign a value to a constant property at any point during initialization, as long as it’s set to a definite value by the time initialization finishes. Once a constant property is assigned a value, it can’t be further modified."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"For class instances, a constant property can be modified during initialization only by the class that introduces it. It can’t be modified by a subclass."}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"You can revise the ","type":"text"},{"code":"SurveyQuestion","type":"codeVoice"},{"text":" example from above to use a constant property rather than a variable property for the ","type":"text"},{"type":"codeVoice","code":"text"},{"type":"text","text":" property of the question, to indicate that the question doesn’t change once an instance of "},{"type":"codeVoice","code":"SurveyQuestion"},{"type":"text","text":" is created. Even though the "},{"type":"codeVoice","code":"text"},{"type":"text","text":" property is now a constant, it can still be set within the class’s initializer:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class SurveyQuestion {","    let text: String","    var response: String?","    init(text: String) {","        self.text = text","    }","    func ask() {","        print(text)","    }","}","let beetsQuestion = SurveyQuestion(text: \"How about beets?\")","beetsQuestion.ask()","\/\/ Prints \"How about beets?\"","beetsQuestion.response = \"I also like beets. (But not with cheese.)\""]},{"anchor":"Default-Initializers","level":2,"text":"Default Initializers","type":"heading"},{"inlineContent":[{"type":"text","text":"Swift provides a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"default initializer"}]},{"type":"text","text":" for any structure or class that provides default values for all of its properties and doesn’t provide at least one initializer itself. The default initializer simply creates a new instance with all of its properties set to their default values."}],"type":"paragraph"},{"inlineContent":[{"text":"This example defines a class called ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":", which encapsulates the name, quantity, and purchase state of an item in a shopping list:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class ShoppingListItem {","    var name: String?","    var quantity = 1","    var purchased = false","}","var item = ShoppingListItem()"]},{"inlineContent":[{"text":"Because all properties of the ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" class have default values, and because it’s a base class with no superclass, ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" automatically gains a default initializer implementation that creates a new instance with all of its properties set to their default values. (The ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" property is an optional ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" property, and so it automatically receives a default value of ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":", even though this value isn’t written in the code.) The example above uses the default initializer for the ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" class to create a new instance of the class with initializer syntax, written as ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem()"},{"text":", and assigns this new instance to a variable called ","type":"text"},{"type":"codeVoice","code":"item"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Memberwise-Initializers-for-Structure-Types","level":3,"text":"Memberwise Initializers for Structure Types","type":"heading"},{"inlineContent":[{"type":"text","text":"Structure types automatically receive a "},{"inlineContent":[{"type":"text","text":"memberwise initializer"}],"type":"emphasis"},{"type":"text","text":" if they don’t define any of their own custom initializers. Unlike a default initializer, the structure receives a memberwise initializer even if it has stored properties that don’t have default values."}],"type":"paragraph"},{"inlineContent":[{"text":"The memberwise initializer is a shorthand way to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines a structure called ","type":"text"},{"code":"Size","type":"codeVoice"},{"text":" with two properties called ","type":"text"},{"code":"width","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"height","type":"codeVoice"},{"text":". Both properties are inferred to be of type ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" by assigning a default value of ","type":"text"},{"code":"0.0","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"Size","type":"codeVoice"},{"text":" structure automatically receives an ","type":"text"},{"code":"init(width:height:)","type":"codeVoice"},{"text":" memberwise initializer, which you can use to initialize a new ","type":"text"},{"code":"Size","type":"codeVoice"},{"text":" instance:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Size {","    var width = 0.0, height = 0.0","}","let twoByTwo = Size(width: 2.0, height: 2.0)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"When you call a memberwise initializer, you can omit values for any properties that have default values. In the example above, the "},{"code":"Size","type":"codeVoice"},{"type":"text","text":" structure has a default value for both its "},{"code":"height","type":"codeVoice"},{"type":"text","text":" and "},{"code":"width","type":"codeVoice"},{"type":"text","text":" properties. You can omit either property or both properties, and the initializer uses the default value for anything you omit. For example:"}],"type":"paragraph"},{"syntax":"swift","code":["let zeroByTwo = Size(height: 2.0)","print(zeroByTwo.width, zeroByTwo.height)","\/\/ Prints \"0.0 2.0\"","","let zeroByZero = Size()","print(zeroByZero.width, zeroByZero.height)","\/\/ Prints \"0.0 0.0\""],"type":"codeListing"},{"text":"Initializer Delegation for Value Types","anchor":"Initializer-Delegation-for-Value-Types","type":"heading","level":2},{"inlineContent":[{"text":"Initializers can call other initializers to perform part of an instance’s initialization. This process, known as ","type":"text"},{"inlineContent":[{"type":"text","text":"initializer delegation"}],"type":"emphasis"},{"text":", avoids duplicating code across multiple initializers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The rules for how initializer delegation works, and for what forms of delegation are allowed, are different for value types and class types. Value types (structures and enumerations) don’t support inheritance, and so their initializer delegation process is relatively simple, because they can only delegate to another initializer that they provide themselves. Classes, however, can inherit from other classes, as described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","isActive":true},{"type":"text","text":". This means that classes have additional responsibilities for ensuring that all stored properties they inherit are assigned a suitable value during initialization. These responsibilities are described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Class-Inheritance-and-Initialization","isActive":true},{"type":"text","text":" below."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For value types, you use "},{"type":"codeVoice","code":"self.init"},{"type":"text","text":" to refer to other initializers from the same value type when writing your own custom initializers. You can call "},{"type":"codeVoice","code":"self.init"},{"type":"text","text":" only from within an initializer."}],"type":"paragraph"},{"inlineContent":[{"text":"Note that if you define a custom initializer for a value type, you will no longer have access to the default initializer (or the memberwise initializer, if it’s a structure) for that type. This constraint prevents a situation in which additional essential setup provided in a more complex initializer is accidentally circumvented by someone using one of the automatic initializers.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"If you want your custom value type to be initializable with the default initializer and memberwise initializer, and also with your own custom initializers, write your custom initializers in an extension rather than as part of the value type’s original implementation. For more information, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","isActive":true,"type":"reference"},{"text":".","type":"text"}]}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"The following example defines a custom ","type":"text"},{"code":"Rect","type":"codeVoice"},{"text":" structure to represent a geometric rectangle. The example requires two supporting structures called ","type":"text"},{"code":"Size","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Point","type":"codeVoice"},{"text":", both of which provide default values of ","type":"text"},{"code":"0.0","type":"codeVoice"},{"text":" for all of their properties:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Size {","    var width = 0.0, height = 0.0","}","struct Point {","    var x = 0.0, y = 0.0","}"],"type":"codeListing"},{"inlineContent":[{"text":"You can initialize the ","type":"text"},{"code":"Rect","type":"codeVoice"},{"text":" structure below in one of three ways—by using its default zero-initialized ","type":"text"},{"code":"origin","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"size","type":"codeVoice"},{"text":" property values, by providing a specific origin point and size, or by providing a specific center point and size. These initialization options are represented by three custom initializers that are part of the ","type":"text"},{"code":"Rect","type":"codeVoice"},{"text":" structure’s definition:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Rect {","    var origin = Point()","    var size = Size()","    init() {}","    init(origin: Point, size: Size) {","        self.origin = origin","        self.size = size","    }","    init(center: Point, size: Size) {","        let originX = center.x - (size.width \/ 2)","        let originY = center.y - (size.height \/ 2)","        self.init(origin: Point(x: originX, y: originY), size: size)","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The first "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" initializer, "},{"type":"codeVoice","code":"init()"},{"type":"text","text":", is functionally the same as the default initializer that the structure would have received if it didn’t have its own custom initializers. This initializer has an empty body, represented by an empty pair of curly braces "},{"type":"codeVoice","code":"{}"},{"type":"text","text":". Calling this initializer returns a "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" instance whose "},{"type":"codeVoice","code":"origin"},{"type":"text","text":" and "},{"type":"codeVoice","code":"size"},{"type":"text","text":" properties are both initialized with the default values of "},{"type":"codeVoice","code":"Point(x: 0.0, y: 0.0)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Size(width: 0.0, height: 0.0)"},{"type":"text","text":" from their property definitions:"}],"type":"paragraph"},{"syntax":"swift","code":["let basicRect = Rect()","\/\/ basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)"],"type":"codeListing"},{"inlineContent":[{"text":"The second ","type":"text"},{"code":"Rect","type":"codeVoice"},{"text":" initializer, ","type":"text"},{"code":"init(origin:size:)","type":"codeVoice"},{"text":", is functionally the same as the memberwise initializer that the structure would have received if it didn’t have its own custom initializers. This initializer simply assigns the ","type":"text"},{"code":"origin","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"size","type":"codeVoice"},{"text":" argument values to the appropriate stored properties:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let originRect = Rect(origin: Point(x: 2.0, y: 2.0),","                      size: Size(width: 5.0, height: 5.0))","\/\/ originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The third "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" initializer, "},{"type":"codeVoice","code":"init(center:size:)"},{"type":"text","text":", is slightly more complex. It starts by calculating an appropriate origin point based on a "},{"type":"codeVoice","code":"center"},{"type":"text","text":" point and a "},{"type":"codeVoice","code":"size"},{"type":"text","text":" value. It then calls (or "},{"type":"emphasis","inlineContent":[{"text":"delegates","type":"text"}]},{"type":"text","text":") to the "},{"type":"codeVoice","code":"init(origin:size:)"},{"type":"text","text":" initializer, which stores the new origin and size values in the appropriate properties:"}],"type":"paragraph"},{"syntax":"swift","code":["let centerRect = Rect(center: Point(x: 4.0, y: 4.0),","                      size: Size(width: 3.0, height: 3.0))","\/\/ centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"init(center:size:)"},{"type":"text","text":" initializer could have assigned the new values of "},{"type":"codeVoice","code":"origin"},{"type":"text","text":" and "},{"type":"codeVoice","code":"size"},{"type":"text","text":" to the appropriate properties itself. However, it’s more convenient (and clearer in intent) for the "},{"type":"codeVoice","code":"init(center:size:)"},{"type":"text","text":" initializer to take advantage of an existing initializer that already provides exactly that functionality."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"For an alternative way to write this example without defining the ","type":"text"},{"code":"init()","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"init(origin:size:)","type":"codeVoice"},{"text":" initializers yourself, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions"},{"text":".","type":"text"}]}],"name":"Note","type":"aside","style":"note"},{"text":"Class Inheritance and Initialization","anchor":"Class-Inheritance-and-Initialization","type":"heading","level":2},{"inlineContent":[{"text":"All of a class’s stored properties—including any properties the class inherits from its superclass—","type":"text"},{"inlineContent":[{"text":"must","type":"text"}],"type":"emphasis"},{"text":" be assigned an initial value during initialization.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift defines two kinds of initializers for class types to help ensure all stored properties receive an initial value. These are known as designated initializers and convenience initializers.","type":"text"}],"type":"paragraph"},{"text":"Designated Initializers and Convenience Initializers","anchor":"Designated-Initializers-and-Convenience-Initializers","type":"heading","level":3},{"inlineContent":[{"inlineContent":[{"text":"Designated initializers","type":"text"}],"type":"emphasis"},{"text":" are the primary initializers for a class. A designated initializer fully initializes all properties introduced by that class and calls an appropriate superclass initializer to continue the initialization process up the superclass chain.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Classes tend to have very few designated initializers, and it’s quite common for a class to have only one. Designated initializers are “funnel” points through which initialization takes place, and through which the initialization process continues up the superclass chain."}],"type":"paragraph"},{"inlineContent":[{"text":"Every class must have at least one designated initializer. In some cases, this requirement is satisfied by inheriting one or more designated initializers from a superclass, as described in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Automatic-Initializer-Inheritance","type":"reference","isActive":true},{"text":" below.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Convenience initializers","type":"text"}]},{"text":" are secondary, supporting initializers for a class. You can define a convenience initializer to call a designated initializer from the same class as the convenience initializer with some of the designated initializer’s parameters set to default values. You can also define a convenience initializer to create an instance of that class for a specific use case or input value type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You don’t have to provide convenience initializers if your class doesn’t require them. Create convenience initializers whenever a shortcut to a common initialization pattern will save time or make initialization of the class clearer in intent."}],"type":"paragraph"},{"text":"Syntax for Designated and Convenience Initializers","anchor":"Syntax-for-Designated-and-Convenience-Initializers","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Designated initializers for classes are written in the same way as simple initializers for value types:"}],"type":"paragraph"},{"syntax":"swift","code":["init(parameters) {","    statements","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Convenience initializers are written in the same style, but with the "},{"code":"convenience","type":"codeVoice"},{"type":"text","text":" modifier placed before the "},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword, separated by a space:"}],"type":"paragraph"},{"syntax":"swift","code":["convenience init(parameters) {","    statements","}"],"type":"codeListing"},{"text":"Initializer Delegation for Class Types","anchor":"Initializer-Delegation-for-Class-Types","type":"heading","level":3},{"inlineContent":[{"text":"To simplify the relationships between designated and convenience initializers, Swift applies the following three rules for delegation calls between initializers:","type":"text"}],"type":"paragraph"},{"items":[{"term":{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Rule 1","type":"text"}]}]},"definition":{"content":[{"inlineContent":[{"type":"text","text":"A designated initializer must call a designated initializer from its immediate superclass."}],"type":"paragraph"}]}},{"term":{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Rule 2","type":"text"}]}]},"definition":{"content":[{"inlineContent":[{"type":"text","text":"A convenience initializer must call another initializer from the "},{"inlineContent":[{"text":"same","type":"text"}],"type":"emphasis"},{"type":"text","text":" class."}],"type":"paragraph"}]}},{"term":{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Rule 3"}]}]},"definition":{"content":[{"inlineContent":[{"text":"A convenience initializer must ultimately call a designated initializer.","type":"text"}],"type":"paragraph"}]}}],"type":"termList"},{"inlineContent":[{"type":"text","text":"A simple way to remember this is:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Designated initializers must always delegate ","type":"text"},{"inlineContent":[{"type":"text","text":"up"}],"type":"emphasis"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Convenience initializers must always delegate ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"across"}]},{"text":".","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"These rules are illustrated in the figure below:"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"initializerDelegation01"}],"type":"paragraph"},{"inlineContent":[{"text":"Here, the superclass has a single designated initializer and two convenience initializers. One convenience initializer calls another convenience initializer, which in turn calls the single designated initializer. This satisfies rules 2 and 3 from above. The superclass doesn’t itself have a further superclass, and so rule 1 doesn’t apply.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The subclass in this figure has two designated initializers and one convenience initializer. The convenience initializer must call one of the two designated initializers, because it can only call another initializer from the same class. This satisfies rules 2 and 3 from above. Both designated initializers must call the single designated initializer from the superclass, to satisfy rule 1 from above.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"These rules don’t affect how users of your classes ","type":"text"},{"inlineContent":[{"type":"text","text":"create"}],"type":"emphasis"},{"text":" instances of each class. Any initializer in the diagram above can be used to create a fully initialized instance of the class they belong to. The rules only affect how you write the implementation of the class’s initializers.","type":"text"}]}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"The figure below shows a more complex class hierarchy for four classes. It illustrates how the designated initializers in this hierarchy act as “funnel” points for class initialization, simplifying the interrelationships among classes in the chain:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"initializerDelegation02"}],"type":"paragraph"},{"text":"Two-Phase Initialization","anchor":"Two-Phase-Initialization","type":"heading","level":3},{"inlineContent":[{"text":"Class initialization in Swift is a two-phase process. In the first phase, each stored property is assigned an initial value by the class that introduced it. Once the initial state for every stored property has been determined, the second phase begins, and each class is given the opportunity to customize its stored properties further before the new instance is considered ready for use.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The use of a two-phase initialization process makes initialization safe, while still giving complete flexibility to each class in a class hierarchy. Two-phase initialization prevents property values from being accessed before they’re initialized, and prevents property values from being set to a different value by another initializer unexpectedly.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s two-phase initialization process is similar to initialization in Objective-C. The main difference is that during phase 1, Objective-C assigns zero or null values (such as "},{"type":"codeVoice","code":"0"},{"type":"text","text":" or "},{"type":"codeVoice","code":"nil"},{"type":"text","text":") to every property. Swift’s initialization flow is more flexible in that it lets you set custom initial values, and can cope with types for which "},{"type":"codeVoice","code":"0"},{"type":"text","text":" or "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" isn’t a valid default value."}]}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"Swift’s compiler performs four helpful safety-checks to make sure that two-phase initialization is completed without error:"}],"type":"paragraph"},{"items":[{"definition":{"content":[{"inlineContent":[{"text":"A designated initializer must ensure that all of the properties introduced by its class are initialized before it delegates up to a superclass initializer.","type":"text"}],"type":"paragraph"}]},"term":{"inlineContent":[{"inlineContent":[{"text":"Safety check 1","type":"text"}],"type":"strong"}]}}],"type":"termList"},{"inlineContent":[{"type":"text","text":"As mentioned above, the memory for an object is only considered fully initialized once the initial state of all of its stored properties is known. In order for this rule to be satisfied, a designated initializer must make sure that all of its own properties are initialized before it hands off up the chain."}],"type":"paragraph"},{"items":[{"definition":{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A designated initializer must delegate up to a superclass initializer before assigning a value to an inherited property. If it doesn’t, the new value the designated initializer assigns will be overwritten by the superclass as part of its own initialization."}]}]},"term":{"inlineContent":[{"inlineContent":[{"type":"text","text":"Safety check 2"}],"type":"strong"}]}},{"definition":{"content":[{"inlineContent":[{"type":"text","text":"A convenience initializer must delegate to another initializer before assigning a value to "},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"type":"text","text":" property (including properties defined by the same class). If it doesn’t, the new value the convenience initializer assigns will be overwritten by its own class’s designated initializer."}],"type":"paragraph"}]},"term":{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Safety check 3","type":"text"}]}]}},{"definition":{"content":[{"inlineContent":[{"type":"text","text":"An initializer can’t call any instance methods, read the values of any instance properties, or refer to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" as a value until after the first phase of initialization is complete."}],"type":"paragraph"}]},"term":{"inlineContent":[{"inlineContent":[{"text":"Safety check 4","type":"text"}],"type":"strong"}]}}],"type":"termList"},{"inlineContent":[{"text":"The class instance isn’t fully valid until the first phase ends. Properties can only be accessed, and methods can only be called, once the class instance is known to be valid at the end of the first phase.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s how two-phase initialization plays out, based on the four safety checks above:"}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"Phase 1","type":"text"}],"type":"strong"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"A designated or convenience initializer is called on a class.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Memory for a new instance of that class is allocated. The memory isn’t yet initialized.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"A designated initializer for that class confirms that all stored properties introduced by that class have a value. The memory for these stored properties is now initialized.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The designated initializer hands off to a superclass initializer to perform the same task for its own stored properties."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"This continues up the class inheritance chain until the top of the chain is reached.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Once the top of the chain is reached, and the final class in the chain has ensured that all of its stored properties have a value, the instance’s memory is considered to be fully initialized, and phase 1 is complete."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Phase 2"}]}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Working back down from the top of the chain, each designated initializer in the chain has the option to customize the instance further. Initializers are now able to access "},{"type":"codeVoice","code":"self"},{"type":"text","text":" and can modify its properties, call its instance methods, and so on."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, any convenience initializers in the chain have the option to customize the instance and to work with "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Here’s how phase 1 looks for an initialization call for a hypothetical subclass and superclass:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"twoPhaseInitialization01"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this example, initialization begins with a call to a convenience initializer on the subclass. This convenience initializer can’t yet modify any properties. It delegates across to a designated initializer from the same class."}],"type":"paragraph"},{"inlineContent":[{"text":"The designated initializer makes sure that all of the subclass’s properties have a value, as per safety check 1. It then calls a designated initializer on its superclass to continue the initialization up the chain.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The superclass’s designated initializer makes sure that all of the superclass properties have a value. There are no further superclasses to initialize, and so no further delegation is needed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As soon as all properties of the superclass have an initial value, its memory is considered fully initialized, and phase 1 is complete."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s how phase 2 looks for the same initialization call:"}],"type":"paragraph"},{"inlineContent":[{"identifier":"twoPhaseInitialization02","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The superclass’s designated initializer now has an opportunity to customize the instance further (although it doesn’t have to)."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Once the superclass’s designated initializer is finished, the subclass’s designated initializer can perform additional customization (although again, it doesn’t have to)."}],"type":"paragraph"},{"inlineContent":[{"text":"Finally, once the subclass’s designated initializer is finished, the convenience initializer that was originally called can perform additional customization.","type":"text"}],"type":"paragraph"},{"text":"Initializer Inheritance and Overriding","anchor":"Initializer-Inheritance-and-Overriding","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Unlike subclasses in Objective-C, Swift subclasses don’t inherit their superclass initializers by default. Swift’s approach prevents a situation in which a simple initializer from a superclass is inherited by a more specialized subclass and is used to create a new instance of the subclass that isn’t fully or correctly initialized."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Superclass initializers ","type":"text"},{"inlineContent":[{"type":"text","text":"are"}],"type":"emphasis"},{"text":" inherited in certain circumstances, but only when it’s safe and appropriate to do so. For more information, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Automatic-Initializer-Inheritance","isActive":true,"type":"reference"},{"text":" below.","type":"text"}]}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"If you want a custom subclass to present one or more of the same initializers as its superclass, you can provide a custom implementation of those initializers within the subclass."}],"type":"paragraph"},{"inlineContent":[{"text":"When you write a subclass initializer that matches a superclass ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"designated"}]},{"text":" initializer, you are effectively providing an override of that designated initializer. Therefore, you must write the ","type":"text"},{"code":"override","type":"codeVoice"},{"text":" modifier before the subclass’s initializer definition. This is true even if you are overriding an automatically provided default initializer, as described in ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Default-Initializers"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As with an overridden property, method or subscript, the presence of the "},{"code":"override","type":"codeVoice"},{"type":"text","text":" modifier prompts Swift to check that the superclass has a matching designated initializer to be overridden, and validates that the parameters for your overriding initializer have been specified as intended."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You always write the "},{"type":"codeVoice","code":"override"},{"type":"text","text":" modifier when overriding a superclass designated initializer, even if your subclass’s implementation of the initializer is a convenience initializer."}]}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"type":"text","text":"Conversely, if you write a subclass initializer that matches a superclass "},{"inlineContent":[{"text":"convenience","type":"text"}],"type":"emphasis"},{"type":"text","text":" initializer, that superclass convenience initializer can never be called directly by your subclass, as per the rules described above in "},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Delegation-for-Class-Types","type":"reference"},{"type":"text","text":". Therefore, your subclass is not (strictly speaking) providing an override of the superclass initializer. As a result, you don’t write the "},{"type":"codeVoice","code":"override"},{"type":"text","text":" modifier when providing a matching implementation of a superclass convenience initializer."}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines a base class called ","type":"text"},{"type":"codeVoice","code":"Vehicle"},{"text":". This base class declares a stored property called ","type":"text"},{"type":"codeVoice","code":"numberOfWheels"},{"text":", with a default ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" value of ","type":"text"},{"type":"codeVoice","code":"0"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"numberOfWheels"},{"text":" property is used by a computed property called ","type":"text"},{"type":"codeVoice","code":"description"},{"text":" to create a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" description of the vehicle’s characteristics:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class Vehicle {","    var numberOfWheels = 0","    var description: String {","        return \"\\(numberOfWheels) wheel(s)\"","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" class provides a default value for its only stored property, and doesn’t provide any custom initializers itself. As a result, it automatically receives a default initializer, as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Default-Initializers"},{"type":"text","text":". The default initializer (when available) is always a designated initializer for a class, and can be used to create a new "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" instance with a "},{"type":"codeVoice","code":"numberOfWheels"},{"type":"text","text":" of "},{"type":"codeVoice","code":"0"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["let vehicle = Vehicle()","print(\"Vehicle: \\(vehicle.description)\")","\/\/ Vehicle: 0 wheel(s)"],"type":"codeListing"},{"inlineContent":[{"text":"The next example defines a subclass of ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":" called ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class Bicycle: Vehicle {","    override init() {","        super.init()","        numberOfWheels = 2","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"Bicycle","type":"codeVoice"},{"type":"text","text":" subclass defines a custom designated initializer, "},{"code":"init()","type":"codeVoice"},{"type":"text","text":". This designated initializer matches a designated initializer from the superclass of "},{"code":"Bicycle","type":"codeVoice"},{"type":"text","text":", and so the "},{"code":"Bicycle","type":"codeVoice"},{"type":"text","text":" version of this initializer is marked with the "},{"code":"override","type":"codeVoice"},{"type":"text","text":" modifier."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"init()","type":"codeVoice"},{"text":" initializer for ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":" starts by calling ","type":"text"},{"code":"super.init()","type":"codeVoice"},{"text":", which calls the default initializer for the ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":" class’s superclass, ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":". This ensures that the ","type":"text"},{"code":"numberOfWheels","type":"codeVoice"},{"text":" inherited property is initialized by ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":" before ","type":"text"},{"code":"Bicycle","type":"codeVoice"},{"text":" has the opportunity to modify the property. After calling ","type":"text"},{"code":"super.init()","type":"codeVoice"},{"text":", the original value of ","type":"text"},{"code":"numberOfWheels","type":"codeVoice"},{"text":" is replaced with a new value of ","type":"text"},{"code":"2","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you create an instance of "},{"type":"codeVoice","code":"Bicycle"},{"type":"text","text":", you can call its inherited "},{"type":"codeVoice","code":"description"},{"type":"text","text":" computed property to see how its "},{"type":"codeVoice","code":"numberOfWheels"},{"type":"text","text":" property has been updated:"}],"type":"paragraph"},{"syntax":"swift","code":["let bicycle = Bicycle()","print(\"Bicycle: \\(bicycle.description)\")","\/\/ Bicycle: 2 wheel(s)"],"type":"codeListing"},{"inlineContent":[{"text":"If a subclass initializer performs no customization in phase 2 of the initialization process, and the superclass has a synchronous, zero-argument designated initializer, you can omit a call to ","type":"text"},{"code":"super.init()","type":"codeVoice"},{"text":" after assigning values to all of the subclass’s stored properties. If the superclass’s initializer is asynchronous, you need to write ","type":"text"},{"code":"await super.init()","type":"codeVoice"},{"text":" explicitly.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"This example defines another subclass of ","type":"text"},{"code":"Vehicle","type":"codeVoice"},{"text":", called ","type":"text"},{"code":"Hoverboard","type":"codeVoice"},{"text":". In its initializer, the ","type":"text"},{"code":"Hoverboard","type":"codeVoice"},{"text":" class sets only its ","type":"text"},{"code":"color","type":"codeVoice"},{"text":" property. Instead of making an explicit call to ","type":"text"},{"code":"super.init()","type":"codeVoice"},{"text":", this initializer relies on an implicit call to its superclass’s initializer to complete the process.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class Hoverboard: Vehicle {","    var color: String","    init(color: String) {","        self.color = color","        \/\/ super.init() implicitly called here","    }","    override var description: String {","        return \"\\(super.description) in a beautiful \\(color)\"","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"An instance of "},{"type":"codeVoice","code":"Hoverboard"},{"type":"text","text":" uses the default number of wheels supplied by the "},{"type":"codeVoice","code":"Vehicle"},{"type":"text","text":" initializer."}],"type":"paragraph"},{"syntax":"swift","code":["let hoverboard = Hoverboard(color: \"silver\")","print(\"Hoverboard: \\(hoverboard.description)\")","\/\/ Hoverboard: 0 wheel(s) in a beautiful silver"],"type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Subclasses can modify inherited variable properties during initialization, but can’t modify inherited constant properties."}]}],"name":"Note","type":"aside","style":"note"},{"text":"Automatic Initializer Inheritance","anchor":"Automatic-Initializer-Inheritance","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"As mentioned above, subclasses don’t inherit their superclass initializers by default. However, superclass initializers "},{"type":"emphasis","inlineContent":[{"text":"are","type":"text"}]},{"type":"text","text":" automatically inherited if certain conditions are met. In practice, this means that you don’t need to write initializer overrides in many common scenarios, and can inherit your superclass initializers with minimal effort whenever it’s safe to do so."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Assuming that you provide default values for any new properties you introduce in a subclass, the following two rules apply:"}],"type":"paragraph"},{"items":[{"definition":{"content":[{"inlineContent":[{"type":"text","text":"If your subclass doesn’t define any designated initializers, it automatically inherits all of its superclass designated initializers."}],"type":"paragraph"}]},"term":{"inlineContent":[{"inlineContent":[{"type":"text","text":"Rule 1"}],"type":"strong"}]}},{"definition":{"content":[{"inlineContent":[{"type":"text","text":"If your subclass provides an implementation of "},{"inlineContent":[{"text":"all","type":"text"}],"type":"emphasis"},{"type":"text","text":" of its superclass designated initializers—either by inheriting them as per rule 1, or by providing a custom implementation as part of its definition—then it automatically inherits all of the superclass convenience initializers."}],"type":"paragraph"}]},"term":{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Rule 2"}]}]}}],"type":"termList"},{"inlineContent":[{"text":"These rules apply even if your subclass adds further convenience initializers.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A subclass can implement a superclass designated initializer as a subclass convenience initializer as part of satisfying rule 2."}]}],"name":"Note","type":"aside","style":"note"},{"text":"Designated and Convenience Initializers in Action","anchor":"Designated-and-Convenience-Initializers-in-Action","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"The following example shows designated initializers, convenience initializers, and automatic initializer inheritance in action. This example defines a hierarchy of three classes called "},{"type":"codeVoice","code":"Food"},{"type":"text","text":", "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":", and "},{"type":"codeVoice","code":"ShoppingListItem"},{"type":"text","text":", and demonstrates how their initializers interact."}],"type":"paragraph"},{"inlineContent":[{"text":"The base class in the hierarchy is called ","type":"text"},{"type":"codeVoice","code":"Food"},{"text":", which is a simple class to encapsulate the name of a foodstuff. The ","type":"text"},{"type":"codeVoice","code":"Food"},{"text":" class introduces a single ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" property called ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" and provides two initializers for creating ","type":"text"},{"type":"codeVoice","code":"Food"},{"text":" instances:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class Food {","    var name: String","    init(name: String) {","        self.name = name","    }","    convenience init() {","        self.init(name: \"[Unnamed]\")","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The figure below shows the initializer chain for the ","type":"text"},{"type":"codeVoice","code":"Food"},{"text":" class:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"initializersExample01","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"Classes don’t have a default memberwise initializer, and so the ","type":"text"},{"code":"Food","type":"codeVoice"},{"text":" class provides a designated initializer that takes a single argument called ","type":"text"},{"code":"name","type":"codeVoice"},{"text":". This initializer can be used to create a new ","type":"text"},{"code":"Food","type":"codeVoice"},{"text":" instance with a specific name:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let namedMeat = Food(name: \"Bacon\")","\/\/ namedMeat's name is \"Bacon\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":" initializer from the "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" class is provided as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"designated"}]},{"type":"text","text":" initializer, because it ensures that all stored properties of a new "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" instance are fully initialized. The "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" class doesn’t have a superclass, and so the "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":" initializer doesn’t need to call "},{"type":"codeVoice","code":"super.init()"},{"type":"text","text":" to complete its initialization."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"Food","type":"codeVoice"},{"type":"text","text":" class also provides a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"convenience"}]},{"type":"text","text":" initializer, "},{"code":"init()","type":"codeVoice"},{"type":"text","text":", with no arguments. The "},{"code":"init()","type":"codeVoice"},{"type":"text","text":" initializer provides a default placeholder name for a new food by delegating across to the "},{"code":"Food","type":"codeVoice"},{"type":"text","text":" class’s "},{"code":"init(name: String)","type":"codeVoice"},{"type":"text","text":" with a "},{"code":"name","type":"codeVoice"},{"type":"text","text":" value of "},{"code":"[Unnamed]","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["let mysteryMeat = Food()","\/\/ mysteryMeat's name is \"[Unnamed]\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The second class in the hierarchy is a subclass of "},{"code":"Food","type":"codeVoice"},{"type":"text","text":" called "},{"code":"RecipeIngredient","type":"codeVoice"},{"type":"text","text":". The "},{"code":"RecipeIngredient","type":"codeVoice"},{"type":"text","text":" class models an ingredient in a cooking recipe. It introduces an "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" property called "},{"code":"quantity","type":"codeVoice"},{"type":"text","text":" (in addition to the "},{"code":"name","type":"codeVoice"},{"type":"text","text":" property it inherits from "},{"code":"Food","type":"codeVoice"},{"type":"text","text":") and defines two initializers for creating "},{"code":"RecipeIngredient","type":"codeVoice"},{"type":"text","text":" instances:"}],"type":"paragraph"},{"syntax":"swift","code":["class RecipeIngredient: Food {","    var quantity: Int","    init(name: String, quantity: Int) {","        self.quantity = quantity","        super.init(name: name)","    }","    override convenience init(name: String) {","        self.init(name: name, quantity: 1)","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The figure below shows the initializer chain for the ","type":"text"},{"code":"RecipeIngredient","type":"codeVoice"},{"text":" class:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"initializersExample02"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" class has a single designated initializer, "},{"type":"codeVoice","code":"init(name: String, quantity: Int)"},{"type":"text","text":", which can be used to populate all of the properties of a new "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" instance. This initializer starts by assigning the passed "},{"type":"codeVoice","code":"quantity"},{"type":"text","text":" argument to the "},{"type":"codeVoice","code":"quantity"},{"type":"text","text":" property, which is the only new property introduced by "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":". After doing so, the initializer delegates up to the "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":" initializer of the "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" class. This process satisfies safety check 1 from "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Two-Phase-Initialization"},{"type":"text","text":" above."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" also defines a convenience initializer, "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":", which is used to create a "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" instance by name alone. This convenience initializer assumes a quantity of "},{"type":"codeVoice","code":"1"},{"type":"text","text":" for any "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" instance that’s created without an explicit quantity. The definition of this convenience initializer makes "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" instances quicker and more convenient to create, and avoids code duplication when creating several single-quantity "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" instances. This convenience initializer simply delegates across to the class’s designated initializer, passing in a "},{"type":"codeVoice","code":"quantity"},{"type":"text","text":" value of "},{"type":"codeVoice","code":"1"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":" convenience initializer provided by "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" takes the same parameters as the "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"designated"}]},{"type":"text","text":" initializer from "},{"type":"codeVoice","code":"Food"},{"type":"text","text":". Because this convenience initializer overrides a designated initializer from its superclass, it must be marked with the "},{"type":"codeVoice","code":"override"},{"type":"text","text":" modifier (as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Inheritance-and-Overriding"},{"type":"text","text":")."}],"type":"paragraph"},{"inlineContent":[{"text":"Even though ","type":"text"},{"code":"RecipeIngredient","type":"codeVoice"},{"text":" provides the ","type":"text"},{"code":"init(name: String)","type":"codeVoice"},{"text":" initializer as a convenience initializer, ","type":"text"},{"code":"RecipeIngredient","type":"codeVoice"},{"text":" has nonetheless provided an implementation of all of its superclass’s designated initializers. Therefore, ","type":"text"},{"code":"RecipeIngredient","type":"codeVoice"},{"text":" automatically inherits all of its superclass’s convenience initializers too.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In this example, the superclass for "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" is "},{"type":"codeVoice","code":"Food"},{"type":"text","text":", which has a single convenience initializer called "},{"type":"codeVoice","code":"init()"},{"type":"text","text":". This initializer is therefore inherited by "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":". The inherited version of "},{"type":"codeVoice","code":"init()"},{"type":"text","text":" functions in exactly the same way as the "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" version, except that it delegates to the "},{"type":"codeVoice","code":"RecipeIngredient"},{"type":"text","text":" version of "},{"type":"codeVoice","code":"init(name: String)"},{"type":"text","text":" rather than the "},{"type":"codeVoice","code":"Food"},{"type":"text","text":" version."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"All three of these initializers can be used to create new "},{"code":"RecipeIngredient","type":"codeVoice"},{"type":"text","text":" instances:"}],"type":"paragraph"},{"syntax":"swift","code":["let oneMysteryItem = RecipeIngredient()","let oneBacon = RecipeIngredient(name: \"Bacon\")","let sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)"],"type":"codeListing"},{"inlineContent":[{"text":"The third and final class in the hierarchy is a subclass of ","type":"text"},{"type":"codeVoice","code":"RecipeIngredient"},{"text":" called ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" class models a recipe ingredient as it appears in a shopping list.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Every item in the shopping list starts out as “unpurchased”. To represent this fact, ","type":"text"},{"code":"ShoppingListItem","type":"codeVoice"},{"text":" introduces a Boolean property called ","type":"text"},{"code":"purchased","type":"codeVoice"},{"text":", with a default value of ","type":"text"},{"code":"false","type":"codeVoice"},{"text":". ","type":"text"},{"code":"ShoppingListItem","type":"codeVoice"},{"text":" also adds a computed ","type":"text"},{"code":"description","type":"codeVoice"},{"text":" property, which provides a textual description of a ","type":"text"},{"code":"ShoppingListItem","type":"codeVoice"},{"text":" instance:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class ShoppingListItem: RecipeIngredient {","    var purchased = false","    var description: String {","        var output = \"\\(quantity) x \\(name)\"","        output += purchased ? \" ✔\" : \" ✘\"","        return output","    }","}"],"type":"codeListing"},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"ShoppingListItem"},{"type":"text","text":" doesn’t define an initializer to provide an initial value for "},{"type":"codeVoice","code":"purchased"},{"type":"text","text":", because items in a shopping list (as modeled here) always start out unpurchased."}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"Because it provides a default value for all of the properties it introduces and doesn’t define any initializers itself, ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" automatically inherits ","type":"text"},{"inlineContent":[{"type":"text","text":"all"}],"type":"emphasis"},{"text":" of the designated and convenience initializers from its superclass.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The figure below shows the overall initializer chain for all three classes:"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"initializersExample03"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can use all three of the inherited initializers to create a new "},{"type":"codeVoice","code":"ShoppingListItem"},{"type":"text","text":" instance:"}],"type":"paragraph"},{"syntax":"swift","code":["var breakfastList = [","    ShoppingListItem(),","    ShoppingListItem(name: \"Bacon\"),","    ShoppingListItem(name: \"Eggs\", quantity: 6),","]","breakfastList[0].name = \"Orange juice\"","breakfastList[0].purchased = true","for item in breakfastList {","    print(item.description)","}","\/\/ 1 x Orange juice ✔","\/\/ 1 x Bacon ✘","\/\/ 6 x Eggs ✘"],"type":"codeListing"},{"inlineContent":[{"text":"Here, a new array called ","type":"text"},{"type":"codeVoice","code":"breakfastList"},{"text":" is created from an array literal containing three new ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" instances. The type of the array is inferred to be ","type":"text"},{"type":"codeVoice","code":"[ShoppingListItem]"},{"text":". After the array is created, the name of the ","type":"text"},{"type":"codeVoice","code":"ShoppingListItem"},{"text":" at the start of the array is changed from ","type":"text"},{"type":"codeVoice","code":"\"[Unnamed]\""},{"text":" to ","type":"text"},{"type":"codeVoice","code":"\"Orange juice\""},{"text":" and it’s marked as having been purchased. Printing the description of each item in the array shows that their default states have been set as expected.","type":"text"}],"type":"paragraph"},{"text":"Failable Initializers","anchor":"Failable-Initializers","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"It’s sometimes useful to define a class, structure, or enumeration for which initialization can fail. This failure might be triggered by invalid initialization parameter values, the absence of a required external resource, or some other condition that prevents initialization from succeeding."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To cope with initialization conditions that can fail, define one or more failable initializers as part of a class, structure, or enumeration definition. You write a failable initializer by placing a question mark after the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword ("},{"type":"codeVoice","code":"init?"},{"type":"text","text":")."}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"You can’t define a failable and a nonfailable initializer with the same parameter types and names.","type":"text"}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"A failable initializer creates an ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"optional","type":"text"}]},{"text":" value of the type it initializes. You write ","type":"text"},{"type":"codeVoice","code":"return nil"},{"text":" within a failable initializer to indicate a point at which initialization failure can be triggered.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Strictly speaking, initializers don’t return a value. Rather, their role is to ensure that "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is fully and correctly initialized by the time that initialization ends. Although you write "},{"type":"codeVoice","code":"return nil"},{"type":"text","text":" to trigger an initialization failure, you don’t use the "},{"type":"codeVoice","code":"return"},{"type":"text","text":" keyword to indicate initialization success."}]}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"For instance, failable initializers are implemented for numeric type conversions. To ensure conversion between numeric types maintains the value exactly, use the ","type":"text"},{"type":"codeVoice","code":"init(exactly:)"},{"text":" initializer. If the type conversion can’t maintain the value, the initializer fails.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let wholeNumber: Double = 12345.0","let pi = 3.14159","","if let valueMaintained = Int(exactly: wholeNumber) {","    print(\"\\(wholeNumber) conversion to Int maintains value of \\(valueMaintained)\")","}","\/\/ Prints \"12345.0 conversion to Int maintains value of 12345\"","","let valueChanged = Int(exactly: pi)","\/\/ valueChanged is of type Int?, not Int","","if valueChanged == nil {","    print(\"\\(pi) conversion to Int doesn't maintain value\")","}","\/\/ Prints \"3.14159 conversion to Int doesn't maintain value\""],"type":"codeListing"},{"inlineContent":[{"text":"The example below defines a structure called ","type":"text"},{"type":"codeVoice","code":"Animal"},{"text":", with a constant ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" property called ","type":"text"},{"type":"codeVoice","code":"species"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"Animal"},{"text":" structure also defines a failable initializer with a single parameter called ","type":"text"},{"type":"codeVoice","code":"species"},{"text":". This initializer checks if the ","type":"text"},{"type":"codeVoice","code":"species"},{"text":" value passed to the initializer is an empty string. If an empty string is found, an initialization failure is triggered. Otherwise, the ","type":"text"},{"type":"codeVoice","code":"species"},{"text":" property’s value is set, and initialization succeeds:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Animal {","    let species: String","    init?(species: String) {","        if species.isEmpty { return nil }","        self.species = species","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"You can use this failable initializer to try to initialize a new ","type":"text"},{"type":"codeVoice","code":"Animal"},{"text":" instance and to check if initialization succeeded:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let someCreature = Animal(species: \"Giraffe\")","\/\/ someCreature is of type Animal?, not Animal","","if let giraffe = someCreature {","    print(\"An animal was initialized with a species of \\(giraffe.species)\")","}","\/\/ Prints \"An animal was initialized with a species of Giraffe\""],"type":"codeListing"},{"inlineContent":[{"text":"If you pass an empty string value to the failable initializer’s ","type":"text"},{"code":"species","type":"codeVoice"},{"text":" parameter, the initializer triggers an initialization failure:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let anonymousCreature = Animal(species: \"\")","\/\/ anonymousCreature is of type Animal?, not Animal","","if anonymousCreature == nil {","    print(\"The anonymous creature couldn't be initialized\")","}","\/\/ Prints \"The anonymous creature couldn't be initialized\""],"type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Checking for an empty string value (such as ","type":"text"},{"code":"\"\"","type":"codeVoice"},{"text":" rather than ","type":"text"},{"code":"\"Giraffe\"","type":"codeVoice"},{"text":") isn’t the same as checking for ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" to indicate the absence of an ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]},{"text":" ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value. In the example above, an empty string (","type":"text"},{"code":"\"\"","type":"codeVoice"},{"text":") is a valid, non-optional ","type":"text"},{"code":"String","type":"codeVoice"},{"text":". However, it’s not appropriate for an animal to have an empty string as the value of its ","type":"text"},{"code":"species","type":"codeVoice"},{"text":" property. To model this restriction, the failable initializer triggers an initialization failure if an empty string is found.","type":"text"}]}],"name":"Note","type":"aside","style":"note"},{"text":"Failable Initializers for Enumerations","anchor":"Failable-Initializers-for-Enumerations","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"You can use a failable initializer to select an appropriate enumeration case based on one or more parameters. The initializer can then fail if the provided parameters don’t match an appropriate enumeration case."}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines an enumeration called ","type":"text"},{"code":"TemperatureUnit","type":"codeVoice"},{"text":", with three possible states (","type":"text"},{"code":"kelvin","type":"codeVoice"},{"text":", ","type":"text"},{"code":"celsius","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"fahrenheit","type":"codeVoice"},{"text":"). A failable initializer is used to find an appropriate enumeration case for a ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" value representing a temperature symbol:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["enum TemperatureUnit {","    case kelvin, celsius, fahrenheit","    init?(symbol: Character) {","        switch symbol {","        case \"K\":","            self = .kelvin","        case \"C\":","            self = .celsius","        case \"F\":","            self = .fahrenheit","        default:","            return nil","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"You can use this failable initializer to choose an appropriate enumeration case for the three possible states and to cause initialization to fail if the parameter doesn’t match one of these states:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let fahrenheitUnit = TemperatureUnit(symbol: \"F\")","if fahrenheitUnit != nil {","    print(\"This is a defined temperature unit, so initialization succeeded.\")","}","\/\/ Prints \"This is a defined temperature unit, so initialization succeeded.\"","","let unknownUnit = TemperatureUnit(symbol: \"X\")","if unknownUnit == nil {","    print(\"This isn't a defined temperature unit, so initialization failed.\")","}","\/\/ Prints \"This isn't a defined temperature unit, so initialization failed.\""],"type":"codeListing"},{"text":"Failable Initializers for Enumerations with Raw Values","anchor":"Failable-Initializers-for-Enumerations-with-Raw-Values","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Enumerations with raw values automatically receive a failable initializer, "},{"type":"codeVoice","code":"init?(rawValue:)"},{"type":"text","text":", that takes a parameter called "},{"type":"codeVoice","code":"rawValue"},{"type":"text","text":" of the appropriate raw-value type and selects a matching enumeration case if one is found, or triggers an initialization failure if no matching value exists."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can rewrite the "},{"type":"codeVoice","code":"TemperatureUnit"},{"type":"text","text":" example from above to use raw values of type "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" and to take advantage of the "},{"type":"codeVoice","code":"init?(rawValue:)"},{"type":"text","text":" initializer:"}],"type":"paragraph"},{"syntax":"swift","code":["enum TemperatureUnit: Character {","    case kelvin = \"K\", celsius = \"C\", fahrenheit = \"F\"","}","","let fahrenheitUnit = TemperatureUnit(rawValue: \"F\")","if fahrenheitUnit != nil {","    print(\"This is a defined temperature unit, so initialization succeeded.\")","}","\/\/ Prints \"This is a defined temperature unit, so initialization succeeded.\"","","let unknownUnit = TemperatureUnit(rawValue: \"X\")","if unknownUnit == nil {","    print(\"This isn't a defined temperature unit, so initialization failed.\")","}","\/\/ Prints \"This isn't a defined temperature unit, so initialization failed.\""],"type":"codeListing"},{"text":"Propagation of Initialization Failure","anchor":"Propagation-of-Initialization-Failure","type":"heading","level":3},{"inlineContent":[{"text":"A failable initializer of a class, structure, or enumeration can delegate across to another failable initializer from the same class, structure, or enumeration. Similarly, a subclass failable initializer can delegate up to a superclass failable initializer.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In either case, if you delegate to another initializer that causes initialization to fail, the entire initialization process fails immediately, and no further initialization code is executed.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"A failable initializer can also delegate to a nonfailable initializer. Use this approach if you need to add a potential failure state to an existing initialization process that doesn’t otherwise fail."}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"The example below defines a subclass of ","type":"text"},{"code":"Product","type":"codeVoice"},{"text":" called ","type":"text"},{"code":"CartItem","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"CartItem","type":"codeVoice"},{"text":" class models an item in an online shopping cart. ","type":"text"},{"code":"CartItem","type":"codeVoice"},{"text":" introduces a stored constant property called ","type":"text"},{"code":"quantity","type":"codeVoice"},{"text":" and ensures that this property always has a value of at least ","type":"text"},{"code":"1","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class Product {","    let name: String","    init?(name: String) {","        if name.isEmpty { return nil }","        self.name = name","    }","}","","class CartItem: Product {","    let quantity: Int","    init?(name: String, quantity: Int) {","        if quantity < 1 { return nil }","        self.quantity = quantity","        super.init(name: name)","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The failable initializer for "},{"type":"codeVoice","code":"CartItem"},{"type":"text","text":" starts by validating that it has received a "},{"type":"codeVoice","code":"quantity"},{"type":"text","text":" value of "},{"type":"codeVoice","code":"1"},{"type":"text","text":" or more. If the "},{"type":"codeVoice","code":"quantity"},{"type":"text","text":" is invalid, the entire initialization process fails immediately and no further initialization code is executed. Likewise, the failable initializer for "},{"type":"codeVoice","code":"Product"},{"type":"text","text":" checks the "},{"type":"codeVoice","code":"name"},{"type":"text","text":" value, and the initializer process fails immediately if "},{"type":"codeVoice","code":"name"},{"type":"text","text":" is the empty string."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you create a "},{"code":"CartItem","type":"codeVoice"},{"type":"text","text":" instance with a nonempty name and a quantity of "},{"code":"1","type":"codeVoice"},{"type":"text","text":" or more, initialization succeeds:"}],"type":"paragraph"},{"syntax":"swift","code":["if let twoSocks = CartItem(name: \"sock\", quantity: 2) {","    print(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")","}","\/\/ Prints \"Item: sock, quantity: 2\""],"type":"codeListing"},{"inlineContent":[{"text":"If you try to create a ","type":"text"},{"type":"codeVoice","code":"CartItem"},{"text":" instance with a ","type":"text"},{"type":"codeVoice","code":"quantity"},{"text":" value of ","type":"text"},{"type":"codeVoice","code":"0"},{"text":", the ","type":"text"},{"type":"codeVoice","code":"CartItem"},{"text":" initializer causes initialization to fail:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["if let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {","    print(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")","} else {","    print(\"Unable to initialize zero shirts\")","}","\/\/ Prints \"Unable to initialize zero shirts\""],"type":"codeListing"},{"inlineContent":[{"text":"Similarly, if you try to create a ","type":"text"},{"code":"CartItem","type":"codeVoice"},{"text":" instance with an empty ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" value, the superclass ","type":"text"},{"code":"Product","type":"codeVoice"},{"text":" initializer causes initialization to fail:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["if let oneUnnamed = CartItem(name: \"\", quantity: 1) {","    print(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")","} else {","    print(\"Unable to initialize one unnamed product\")","}","\/\/ Prints \"Unable to initialize one unnamed product\""],"type":"codeListing"},{"text":"Overriding a Failable Initializer","anchor":"Overriding-a-Failable-Initializer","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"You can override a superclass failable initializer in a subclass, just like any other initializer. Alternatively, you can override a superclass failable initializer with a subclass "},{"inlineContent":[{"text":"nonfailable","type":"text"}],"type":"emphasis"},{"type":"text","text":" initializer. This enables you to define a subclass for which initialization can’t fail, even though initialization of the superclass is allowed to fail."}],"type":"paragraph"},{"inlineContent":[{"text":"Note that if you override a failable superclass initializer with a nonfailable subclass initializer, the only way to delegate up to the superclass initializer is to force-unwrap the result of the failable superclass initializer.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"You can override a failable initializer with a nonfailable initializer but not the other way around.","type":"text"}],"type":"paragraph"}],"name":"Note","type":"aside","style":"note"},{"inlineContent":[{"text":"The example below defines a class called ","type":"text"},{"code":"Document","type":"codeVoice"},{"text":". This class models a document that can be initialized with a ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" property that’s either a nonempty string value or ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", but can’t be an empty string:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class Document {","    var name: String?","    \/\/ this initializer creates a document with a nil name value","    init() {}","    \/\/ this initializer creates a document with a nonempty name value","    init?(name: String) {","        if name.isEmpty { return nil }","        self.name = name","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The next example defines a subclass of ","type":"text"},{"type":"codeVoice","code":"Document"},{"text":" called ","type":"text"},{"type":"codeVoice","code":"AutomaticallyNamedDocument"},{"text":". The ","type":"text"},{"type":"codeVoice","code":"AutomaticallyNamedDocument"},{"text":" subclass overrides both of the designated initializers introduced by ","type":"text"},{"type":"codeVoice","code":"Document"},{"text":". These overrides ensure that an ","type":"text"},{"type":"codeVoice","code":"AutomaticallyNamedDocument"},{"text":" instance has an initial ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" value of ","type":"text"},{"type":"codeVoice","code":"\"[Untitled]\""},{"text":" if the instance is initialized without a name, or if an empty string is passed to the ","type":"text"},{"type":"codeVoice","code":"init(name:)"},{"text":" initializer:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class AutomaticallyNamedDocument: Document {","    override init() {","        super.init()","        self.name = \"[Untitled]\"","    }","    override init(name: String) {","        super.init()","        if name.isEmpty {","            self.name = \"[Untitled]\"","        } else {","            self.name = name","        }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"AutomaticallyNamedDocument"},{"text":" overrides its superclass’s failable ","type":"text"},{"type":"codeVoice","code":"init?(name:)"},{"text":" initializer with a nonfailable ","type":"text"},{"type":"codeVoice","code":"init(name:)"},{"text":" initializer. Because ","type":"text"},{"type":"codeVoice","code":"AutomaticallyNamedDocument"},{"text":" copes with the empty string case in a different way than its superclass, its initializer doesn’t need to fail, and so it provides a nonfailable version of the initializer instead.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can use forced unwrapping in an initializer to call a failable initializer from the superclass as part of the implementation of a subclass’s nonfailable initializer. For example, the "},{"type":"codeVoice","code":"UntitledDocument"},{"type":"text","text":" subclass below is always named "},{"type":"codeVoice","code":"\"[Untitled]\""},{"type":"text","text":", and it uses the failable "},{"type":"codeVoice","code":"init(name:)"},{"type":"text","text":" initializer from its superclass during initialization."}],"type":"paragraph"},{"syntax":"swift","code":["class UntitledDocument: Document {","    override init() {","        super.init(name: \"[Untitled]\")!","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"In this case, if the ","type":"text"},{"code":"init(name:)","type":"codeVoice"},{"text":" initializer of the superclass were ever called with an empty string as the name, the forced unwrapping operation would result in a runtime error. However, because it’s called with a string constant, you can see that the initializer won’t fail, so no runtime error can occur in this case.","type":"text"}],"type":"paragraph"},{"level":3,"text":"The init! Failable Initializer","type":"heading","anchor":"The-init-Failable-Initializer"},{"inlineContent":[{"type":"text","text":"You typically define a failable initializer that creates an optional instance of the appropriate type by placing a question mark after the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword ("},{"type":"codeVoice","code":"init?"},{"type":"text","text":"). Alternatively, you can define a failable initializer that creates an implicitly unwrapped optional instance of the appropriate type. Do this by placing an exclamation point after the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword ("},{"type":"codeVoice","code":"init!"},{"type":"text","text":") instead of a question mark."}],"type":"paragraph"},{"inlineContent":[{"text":"You can delegate from ","type":"text"},{"code":"init?","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"init!","type":"codeVoice"},{"text":" and vice versa, and you can override ","type":"text"},{"code":"init?","type":"codeVoice"},{"text":" with ","type":"text"},{"code":"init!","type":"codeVoice"},{"text":" and vice versa. You can also delegate from ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"init!","type":"codeVoice"},{"text":", although doing so will trigger an assertion if the ","type":"text"},{"code":"init!","type":"codeVoice"},{"text":" initializer causes initialization to fail.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Required Initializers","type":"heading","anchor":"Required-Initializers"},{"inlineContent":[{"text":"Write the ","type":"text"},{"type":"codeVoice","code":"required"},{"text":" modifier before the definition of a class initializer to indicate that every subclass of the class must implement that initializer:","type":"text"}],"type":"paragraph"},{"code":["class SomeClass {","    required init() {","        \/\/ initializer implementation goes here","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"You must also write the ","type":"text"},{"type":"codeVoice","code":"required"},{"text":" modifier before every subclass implementation of a required initializer, to indicate that the initializer requirement applies to further subclasses in the chain. You don’t write the ","type":"text"},{"type":"codeVoice","code":"override"},{"text":" modifier when overriding a required designated initializer:","type":"text"}],"type":"paragraph"},{"code":["class SomeSubclass: SomeClass {","    required init() {","        \/\/ subclass implementation of the required initializer goes here","    }","}"],"syntax":"swift","type":"codeListing"},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"You don’t have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initializer."}],"type":"paragraph"}]},{"level":2,"text":"Setting a Default Property Value with a Closure or Function","type":"heading","anchor":"Setting-a-Default-Property-Value-with-a-Closure-or-Function"},{"inlineContent":[{"text":"If a stored property’s default value requires some customization or setup, you can use a closure or global function to provide a customized default value for that property. Whenever a new instance of the type that the property belongs to is initialized, the closure or function is called, and its return value is assigned as the property’s default value.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"These kinds of closures or functions typically create a temporary value of the same type as the property, tailor that value to represent the desired initial state, and then return that temporary value to be used as the property’s default value."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s a skeleton outline of how a closure can be used to provide a default property value:","type":"text"}],"type":"paragraph"},{"code":["class SomeClass {","    let someProperty: SomeType = {","        \/\/ create a default value for someProperty inside this closure","        \/\/ someValue must be of the same type as SomeType","        return someValue","    }()","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note that the closure’s end curly brace is followed by an empty pair of parentheses. This tells Swift to execute the closure immediately. If you omit these parentheses, you are trying to assign the closure itself to the property, and not the return value of the closure."}],"type":"paragraph"},{"name":"Note","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you use a closure to initialize a property, remember that the rest of the instance hasn’t yet been initialized at the point that the closure is executed. This means that you can’t access any other property values from within your closure, even if those properties have default values. You also can’t use the implicit "},{"type":"codeVoice","code":"self"},{"type":"text","text":" property, or call any of the instance’s methods."}]}]},{"inlineContent":[{"type":"text","text":"The example below defines a structure called "},{"type":"codeVoice","code":"Chessboard"},{"type":"text","text":", which models a board for the game of chess. Chess is played on an 8 x 8 board, with alternating black and white squares."}],"type":"paragraph"},{"inlineContent":[{"identifier":"chessBoard","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To represent this game board, the "},{"type":"codeVoice","code":"Chessboard"},{"type":"text","text":" structure has a single property called "},{"type":"codeVoice","code":"boardColors"},{"type":"text","text":", which is an array of 64 "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" values. A value of "},{"type":"codeVoice","code":"true"},{"type":"text","text":" in the array represents a black square and a value of "},{"type":"codeVoice","code":"false"},{"type":"text","text":" represents a white square. The first item in the array represents the top left square on the board and the last item in the array represents the bottom right square on the board."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"boardColors","type":"codeVoice"},{"type":"text","text":" array is initialized with a closure to set up its color values:"}],"type":"paragraph"},{"code":["struct Chessboard {","    let boardColors: [Bool] = {","        var temporaryBoard: [Bool] = []","        var isBlack = false","        for i in 1...8 {","            for j in 1...8 {","                temporaryBoard.append(isBlack)","                isBlack = !isBlack","            }","            isBlack = !isBlack","        }","        return temporaryBoard","    }()","    func squareIsBlackAt(row: Int, column: Int) -> Bool {","        return boardColors[(row * 8) + column]","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Whenever a new ","type":"text"},{"code":"Chessboard","type":"codeVoice"},{"text":" instance is created, the closure is executed, and the default value of ","type":"text"},{"code":"boardColors","type":"codeVoice"},{"text":" is calculated and returned. The closure in the example above calculates and sets the appropriate color for each square on the board in a temporary array called ","type":"text"},{"code":"temporaryBoard","type":"codeVoice"},{"text":", and returns this temporary array as the closure’s return value once its setup is complete. The returned array value is stored in ","type":"text"},{"code":"boardColors","type":"codeVoice"},{"text":" and can be queried with the ","type":"text"},{"code":"squareIsBlackAt(row:column:)","type":"codeVoice"},{"text":" utility function:","type":"text"}],"type":"paragraph"},{"code":["let board = Chessboard()","print(board.squareIsBlackAt(row: 0, column: 1))","\/\/ Prints \"true\"","print(board.squareIsBlackAt(row: 7, column: 7))","\/\/ Prints \"false\""],"syntax":"swift","type":"codeListing"}]}],"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","interfaceLanguage":"swift"},"abstract":[{"inlineContent":[{"text":"Initialization","type":"text"}],"type":"emphasis"},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","schemaVersion":{"major":0,"patch":0,"minor":3},"metadata":{"roleHeading":"Article","role":"article","title":"Initialization","modules":[{"name":"Swift"}]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/initialization"]}],"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"seeAlsoSections":[{"title":"Language Guide","generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"]}],"references":{"twoPhaseInitialization02":{"alt":null,"variants":[{"url":"\/images\/twoPhaseInitialization02@2x.png","traits":["2x","light"]}],"type":"image","identifier":"twoPhaseInitialization02"},"doc://com.apple.Swift/documentation/Swift/Initialization#Two-Phase-Initialization":{"title":"Two-Phase Initialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Two-Phase-Initialization","url":"\/documentation\/swift\/initialization#Two-Phase-Initialization","type":"topic","abstract":[],"kind":"section"},"doc://com.apple.Swift/documentation/Swift/Initialization#Default-Initializers":{"url":"\/documentation\/swift\/initialization#Default-Initializers","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Default-Initializers","type":"topic","title":"Default Initializers","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","kind":"article","role":"article"},"initializersExample01":{"alt":null,"variants":[{"url":"\/images\/initializersExample01@2x.png","traits":["2x","light"]}],"type":"image","identifier":"initializersExample01"},"doc://com.apple.Swift/documentation/Swift/Functions":{"role":"article","type":"topic","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"kind":"article","url":"\/documentation\/swift\/functions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"kind":"article","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","title":"Extensions","type":"topic","url":"\/documentation\/swift\/extensions"},"initializersExample02":{"alt":null,"variants":[{"url":"\/images\/initializersExample02@2x.png","traits":["2x","light"]}],"type":"image","identifier":"initializersExample02"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"title":"Strings and Characters","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" is a series of characters, such as "},{"code":"\"hello, world\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"albatross\"","type":"codeVoice"},{"text":". Swift strings are represented by the ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type. The contents of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values.","type":"text"}],"type":"topic","kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","role":"article","url":"\/documentation\/swift\/stringsandcharacters"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"url":"\/documentation\/swift\/opaquetypes","title":"Opaque Types","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"type":"topic","role":"article","kind":"article","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"inlineContent":[{"type":"text","text":"Asynchronous code"}],"type":"emphasis"},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"inlineContent":[{"type":"text","text":"Parallel code"}],"type":"emphasis"},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"title":"Concurrency","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","abstract":[{"inlineContent":[{"text":"Structures","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.","type":"text"}],"title":"Structures and Classes","url":"\/documentation\/swift\/classesandstructures","role":"article"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"title":"Optional Chaining","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"title":"Swift","url":"\/documentation\/swift","role":"collection"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","role":"article","url":"\/documentation\/swift\/advancedoperators","abstract":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.","type":"text"}],"title":"Advanced Operators","kind":"article"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"abstract":[{"type":"text","text":"An "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"type":"codeVoice","code":"+"},{"text":") adds two numbers, as in ","type":"text"},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"type":"topic","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","url":"\/documentation\/swift\/basicoperators","kind":"article","title":"Basic Operators"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword. Deinitializers are only available on class types.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization"},"doc://com.apple.Swift/documentation/Swift/Initialization#Initializer-Delegation-for-Class-Types":{"type":"topic","title":"Initializer Delegation for Class Types","abstract":[],"url":"\/documentation\/swift\/initialization#Initializer-Delegation-for-Class-Types","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Delegation-for-Class-Types"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","role":"article","abstract":[{"inlineContent":[{"text":"Type casting","type":"text"}],"type":"emphasis"},{"text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.","type":"text"}],"title":"Type Casting","url":"\/documentation\/swift\/typecasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"role":"article","type":"topic","title":"Control Flow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"kind":"article","url":"\/documentation\/swift\/controlflow","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},"doc://com.apple.Swift/documentation/Swift/Closures":{"role":"article","type":"topic","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures"},"doc://com.apple.Swift/documentation/Swift/Generics":{"role":"article","type":"topic","title":"Generics","kind":"article","abstract":[{"inlineContent":[{"type":"text","text":"Generic code"}],"type":"emphasis"},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","url":"\/documentation\/swift\/generics"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","abstract":[{"inlineContent":[{"text":"Access control","type":"text"}],"type":"emphasis"},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/accesscontrol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"title":"Error Handling","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","url":"\/documentation\/swift\/errorhandling"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","title":"Subscripts","url":"\/documentation\/swift\/subscripts","role":"article","kind":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Initialization#Initialization-Parameters":{"url":"\/documentation\/swift\/initialization#Initialization-Parameters","abstract":[],"title":"Initialization Parameters","type":"topic","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initialization-Parameters"},"doc://com.apple.Swift/documentation/Swift/Initialization#Automatic-Initializer-Inheritance":{"url":"\/documentation\/swift\/initialization#Automatic-Initializer-Inheritance","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Automatic-Initializer-Inheritance","type":"topic","title":"Automatic Initializer Inheritance","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","kind":"article","role":"article"},"chessBoard":{"alt":null,"variants":[{"url":"\/images\/chessBoard@2x.png","traits":["2x","light"]}],"type":"image","identifier":"chessBoard"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"title":"Enumerations","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic"},"initializerDelegation01":{"alt":null,"variants":[{"url":"\/images\/initializerDelegation01@2x.png","traits":["2x","light"]}],"type":"image","identifier":"initializerDelegation01"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"url":"\/documentation\/swift\/protocols","title":"Protocols","abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"protocol","type":"text"}],"type":"emphasis"},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"type":"text","text":"adopted"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"conform","type":"text"}]},{"text":" to that protocol.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","title":"Collection Types","abstract":[{"text":"Swift provides three primary ","type":"text"},{"inlineContent":[{"text":"collection types","type":"text"}],"type":"emphasis"},{"text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/collectiontypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes"},"doc://com.apple.Swift/documentation/Swift/Initialization#Class-Inheritance-and-Initialization":{"url":"\/documentation\/swift\/initialization#Class-Inheritance-and-Initialization","abstract":[],"title":"Class Inheritance and Initialization","type":"topic","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Class-Inheritance-and-Initialization"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","role":"article","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","title":"Memory Safety","type":"topic","url":"\/documentation\/swift\/memorysafety"},"initializerDelegation02":{"alt":null,"variants":[{"url":"\/images\/initializerDelegation02@2x.png","traits":["2x","light"]}],"type":"image","identifier":"initializerDelegation02"},"initializersExample03":{"alt":null,"variants":[{"url":"\/images\/initializersExample03@2x.png","traits":["2x","light"]}],"type":"image","identifier":"initializersExample03"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"kind":"article","role":"article","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"text":"inherit","type":"text"}]},{"type":"text","text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":", and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"text":"superclass","type":"text"}]},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","type":"topic","url":"\/documentation\/swift\/inheritance"},"doc://com.apple.Swift/documentation/Swift/Initialization#Initializer-Inheritance-and-Overriding":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Initializer-Inheritance-and-Overriding","type":"topic","kind":"section","url":"\/documentation\/swift\/initialization#Initializer-Inheritance-and-Overriding","abstract":[],"title":"Initializer Inheritance and Overriding"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"role":"article","type":"topic","title":"Nested Types","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"inlineContent":[{"text":"nested types","type":"text"}],"type":"emphasis"},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/nestedtypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"url":"\/documentation\/swift\/automaticreferencecounting","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"Automatic Reference Counting","type":"text"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","kind":"article","role":"article"},"twoPhaseInitialization01":{"alt":null,"variants":[{"url":"\/images\/twoPhaseInitialization01@2x.png","traits":["2x","light"]}],"type":"image","identifier":"twoPhaseInitialization01"}}}