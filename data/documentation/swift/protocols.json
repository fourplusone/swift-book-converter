{"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","interfaceLanguage":"swift"},"sections":[],"abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"protocol","type":"text"}],"type":"emphasis"},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"type":"text","text":"conform"}],"type":"emphasis"},{"text":" to that protocol.","type":"text"}],"metadata":{"roleHeading":"Article","role":"article","title":"Protocols","modules":[{"name":"Swift"}]},"primaryContentSections":[{"content":[{"anchor":"overview","level":2,"text":"Overview","type":"heading"},{"inlineContent":[{"text":"In addition to specifying requirements that conforming types must implement, you can extend a protocol to implement some of these requirements or to implement additional functionality that conforming types can take advantage of.","type":"text"}],"type":"paragraph"},{"anchor":"Protocol-Syntax","level":2,"text":"Protocol Syntax","type":"heading"},{"inlineContent":[{"text":"You define protocols in a very similar way to classes, structures, and enumerations:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol SomeProtocol {","    \/\/ protocol definition goes here","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Custom types state that they adopt a particular protocol by placing the protocol’s name after the type’s name, separated by a colon, as part of their definition. Multiple protocols can be listed, and are separated by commas:"}],"type":"paragraph"},{"syntax":"swift","code":["struct SomeStructure: FirstProtocol, AnotherProtocol {","    \/\/ structure definition goes here","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"If a class has a superclass, list the superclass name before any protocols it adopts, followed by a comma:"}],"type":"paragraph"},{"syntax":"swift","code":["class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {","    \/\/ class definition goes here","}"],"type":"codeListing"},{"anchor":"Property-Requirements","level":2,"text":"Property Requirements","type":"heading"},{"inlineContent":[{"text":"A protocol can require any conforming type to provide an instance property or type property with a particular name and type. The protocol doesn’t specify whether the property should be a stored property or a computed property—it only specifies the required property name and type. The protocol also specifies whether each property must be gettable or gettable ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"text":" settable.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If a protocol requires a property to be gettable and settable, that property requirement can’t be fulfilled by a constant stored property or a read-only computed property. If the protocol only requires a property to be gettable, the requirement can be satisfied by any kind of property, and it’s valid for the property to be also settable if this is useful for your own code.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Property requirements are always declared as variable properties, prefixed with the ","type":"text"},{"code":"var","type":"codeVoice"},{"text":" keyword. Gettable and settable properties are indicated by writing ","type":"text"},{"code":"{ get set }","type":"codeVoice"},{"text":" after their type declaration, and gettable properties are indicated by writing ","type":"text"},{"code":"{ get }","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol SomeProtocol {","    var mustBeSettable: Int { get set }","    var doesNotNeedToBeSettable: Int { get }","}"],"type":"codeListing"},{"inlineContent":[{"text":"Always prefix type property requirements with the ","type":"text"},{"type":"codeVoice","code":"static"},{"text":" keyword when you define them in a protocol. This rule pertains even though type property requirements can be prefixed with the ","type":"text"},{"type":"codeVoice","code":"class"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"static"},{"text":" keyword when implemented by a class:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol AnotherProtocol {","    static var someTypeProperty: Int { get set }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Here’s an example of a protocol with a single instance property requirement:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol FullyNamed {","    var fullName: String { get }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"FullyNamed","type":"codeVoice"},{"text":" protocol requires a conforming type to provide a fully qualified name. The protocol doesn’t specify anything else about the nature of the conforming type—it only specifies that the type must be able to provide a full name for itself. The protocol states that any ","type":"text"},{"code":"FullyNamed","type":"codeVoice"},{"text":" type must have a gettable instance property called ","type":"text"},{"code":"fullName","type":"codeVoice"},{"text":", which is of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s an example of a simple structure that adopts and conforms to the ","type":"text"},{"code":"FullyNamed","type":"codeVoice"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Person: FullyNamed {","    var fullName: String","}","let john = Person(fullName: \"John Appleseed\")","\/\/ john.fullName is \"John Appleseed\""],"type":"codeListing"},{"inlineContent":[{"text":"This example defines a structure called ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":", which represents a specific named person. It states that it adopts the ","type":"text"},{"code":"FullyNamed","type":"codeVoice"},{"text":" protocol as part of the first line of its definition.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Each instance of "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" has a single stored property called "},{"code":"fullName","type":"codeVoice"},{"type":"text","text":", which is of type "},{"code":"String","type":"codeVoice"},{"type":"text","text":". This matches the single requirement of the "},{"code":"FullyNamed","type":"codeVoice"},{"type":"text","text":" protocol, and means that "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" has correctly conformed to the protocol. (Swift reports an error at compile time if a protocol requirement isn’t fulfilled.)"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s a more complex class, which also adopts and conforms to the "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"syntax":"swift","code":["class Starship: FullyNamed {","    var prefix: String?","    var name: String","    init(name: String, prefix: String? = nil) {","        self.name = name","        self.prefix = prefix","    }","    var fullName: String {","        return (prefix != nil ? prefix! + \" \" : \"\") + name","    }","}","var ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")","\/\/ ncc1701.fullName is \"USS Enterprise\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This class implements the "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":" property requirement as a computed read-only property for a starship. Each "},{"type":"codeVoice","code":"Starship"},{"type":"text","text":" class instance stores a mandatory "},{"type":"codeVoice","code":"name"},{"type":"text","text":" and an optional "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":". The "},{"type":"codeVoice","code":"fullName"},{"type":"text","text":" property uses the "},{"type":"codeVoice","code":"prefix"},{"type":"text","text":" value if it exists, and prepends it to the beginning of "},{"type":"codeVoice","code":"name"},{"type":"text","text":" to create a full name for the starship."}],"type":"paragraph"},{"anchor":"Method-Requirements","level":2,"text":"Method Requirements","type":"heading"},{"inlineContent":[{"text":"Protocols can require specific instance methods and type methods to be implemented by conforming types. These methods are written as part of the protocol’s definition in exactly the same way as for normal instance and type methods, but without curly braces or a method body. Variadic parameters are allowed, subject to the same rules as for normal methods. Default values, however, can’t be specified for method parameters within a protocol’s definition.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"As with type property requirements, you always prefix type method requirements with the ","type":"text"},{"code":"static","type":"codeVoice"},{"text":" keyword when they’re defined in a protocol. This is true even though type method requirements are prefixed with the ","type":"text"},{"code":"class","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"static","type":"codeVoice"},{"text":" keyword when implemented by a class:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol SomeProtocol {","    static func someTypeMethod()","}"],"type":"codeListing"},{"inlineContent":[{"text":"The following example defines a protocol with a single instance method requirement:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol RandomNumberGenerator {","    func random() -> Double","}"],"type":"codeListing"},{"inlineContent":[{"text":"This protocol, ","type":"text"},{"code":"RandomNumberGenerator","type":"codeVoice"},{"text":", requires any conforming type to have an instance method called ","type":"text"},{"code":"random","type":"codeVoice"},{"text":", which returns a ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" value whenever it’s called. Although it’s not specified as part of the protocol, it’s assumed that this value will be a number from ","type":"text"},{"code":"0.0","type":"codeVoice"},{"text":" up to (but not including) ","type":"text"},{"code":"1.0","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"RandomNumberGenerator","type":"codeVoice"},{"text":" protocol doesn’t make any assumptions about how each random number will be generated—it simply requires the generator to provide a standard way to generate a new random number.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s an implementation of a class that adopts and conforms to the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol. This class implements a pseudorandom number generator algorithm known as a "},{"type":"emphasis","inlineContent":[{"text":"linear congruential generator","type":"text"}]},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["class LinearCongruentialGenerator: RandomNumberGenerator {","    var lastRandom = 42.0","    let m = 139968.0","    let a = 3877.0","    let c = 29573.0","    func random() -> Double {","        lastRandom = ((lastRandom * a + c)","            .truncatingRemainder(dividingBy:m))","        return lastRandom \/ m","    }","}","let generator = LinearCongruentialGenerator()","print(\"Here's a random number: \\(generator.random())\")","\/\/ Prints \"Here's a random number: 0.3746499199817101\"","print(\"And another one: \\(generator.random())\")","\/\/ Prints \"And another one: 0.729023776863283\""],"type":"codeListing"},{"anchor":"Mutating-Method-Requirements","level":2,"text":"Mutating Method Requirements","type":"heading"},{"inlineContent":[{"text":"It’s sometimes necessary for a method to modify (or ","type":"text"},{"inlineContent":[{"text":"mutate","type":"text"}],"type":"emphasis"},{"text":") the instance it belongs to. For instance methods on value types (that is, structures and enumerations) you place the ","type":"text"},{"code":"mutating","type":"codeVoice"},{"text":" keyword before a method’s ","type":"text"},{"code":"func","type":"codeVoice"},{"text":" keyword to indicate that the method is allowed to modify the instance it belongs to and any properties of that instance. This process is described in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods#Modifying-Value-Types-from-Within-Instance-Methods","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you define a protocol instance method requirement that’s intended to mutate instances of any type that adopts the protocol, mark the method with the "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":" keyword as part of the protocol’s definition. This enables structures and enumerations to adopt the protocol and satisfy that method requirement."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"If you mark a protocol instance method requirement as ","type":"text"},{"code":"mutating","type":"codeVoice"},{"text":", you don’t need to write the ","type":"text"},{"code":"mutating","type":"codeVoice"},{"text":" keyword when writing an implementation of that method for a class. The ","type":"text"},{"code":"mutating","type":"codeVoice"},{"text":" keyword is only used by structures and enumerations.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"text":"The example below defines a protocol called ","type":"text"},{"code":"Togglable","type":"codeVoice"},{"text":", which defines a single instance method requirement called ","type":"text"},{"code":"toggle","type":"codeVoice"},{"text":". As its name suggests, the ","type":"text"},{"code":"toggle()","type":"codeVoice"},{"text":" method is intended to toggle or invert the state of any conforming type, typically by modifying a property of that type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"toggle()","type":"codeVoice"},{"text":" method is marked with the ","type":"text"},{"code":"mutating","type":"codeVoice"},{"text":" keyword as part of the ","type":"text"},{"code":"Togglable","type":"codeVoice"},{"text":" protocol definition, to indicate that the method is expected to mutate the state of a conforming instance when it’s called:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol Togglable {","    mutating func toggle()","}"],"type":"codeListing"},{"inlineContent":[{"text":"If you implement the ","type":"text"},{"code":"Togglable","type":"codeVoice"},{"text":" protocol for a structure or enumeration, that structure or enumeration can conform to the protocol by providing an implementation of the ","type":"text"},{"type":"codeVoice","code":"toggle()"},{"text":" method that’s also marked as ","type":"text"},{"type":"codeVoice","code":"mutating"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example below defines an enumeration called "},{"type":"codeVoice","code":"OnOffSwitch"},{"type":"text","text":". This enumeration toggles between two states, indicated by the enumeration cases "},{"type":"codeVoice","code":"on"},{"type":"text","text":" and "},{"type":"codeVoice","code":"off"},{"type":"text","text":". The enumeration’s "},{"type":"codeVoice","code":"toggle"},{"type":"text","text":" implementation is marked as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":", to match the "},{"type":"codeVoice","code":"Togglable"},{"type":"text","text":" protocol’s requirements:"}],"type":"paragraph"},{"syntax":"swift","code":["enum OnOffSwitch: Togglable {","    case off, on","    mutating func toggle() {","        switch self {","        case .off:","            self = .on","        case .on:","            self = .off","        }","    }","}","var lightSwitch = OnOffSwitch.off","lightSwitch.toggle()","\/\/ lightSwitch is now equal to .on"],"type":"codeListing"},{"anchor":"Initializer-Requirements","level":2,"text":"Initializer Requirements","type":"heading"},{"inlineContent":[{"text":"Protocols can require specific initializers to be implemented by conforming types. You write these initializers as part of the protocol’s definition in exactly the same way as for normal initializers, but without curly braces or an initializer body:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol SomeProtocol {","    init(someParameter: Int)","}"],"type":"codeListing"},{"anchor":"Class-Implementations-of-Protocol-Initializer-Requirements","level":3,"text":"Class Implementations of Protocol Initializer Requirements","type":"heading"},{"inlineContent":[{"type":"text","text":"You can implement a protocol initializer requirement on a conforming class as either a designated initializer or a convenience initializer. In both cases, you must mark the initializer implementation with the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" modifier:"}],"type":"paragraph"},{"syntax":"swift","code":["class SomeClass: SomeProtocol {","    required init(someParameter: Int) {","        \/\/ initializer implementation goes here","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The use of the "},{"code":"required","type":"codeVoice"},{"type":"text","text":" modifier ensures that you provide an explicit or inherited implementation of the initializer requirement on all subclasses of the conforming class, such that they also conform to the protocol."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For more information on required initializers, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Required-Initializers","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You don’t need to mark protocol initializer implementations with the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" modifier on classes that are marked with the "},{"type":"codeVoice","code":"final"},{"type":"text","text":" modifier, because final classes can’t subclassed. For more about the "},{"type":"codeVoice","code":"final"},{"type":"text","text":" modifier, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance#Preventing-Overrides"},{"type":"text","text":"."}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"type":"text","text":"If a subclass overrides a designated initializer from a superclass, and also implements a matching initializer requirement from a protocol, mark the initializer implementation with both the "},{"type":"codeVoice","code":"required"},{"type":"text","text":" and "},{"type":"codeVoice","code":"override"},{"type":"text","text":" modifiers:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol SomeProtocol {","    init()","}","","class SomeSuperClass {","    init() {","        \/\/ initializer implementation goes here","    }","}","","class SomeSubClass: SomeSuperClass, SomeProtocol {","    \/\/ \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass","    required override init() {","        \/\/ initializer implementation goes here","    }","}"],"type":"codeListing"},{"anchor":"Failable-Initializer-Requirements","level":3,"text":"Failable Initializer Requirements","type":"heading"},{"inlineContent":[{"type":"text","text":"Protocols can define failable initializer requirements for conforming types, as defined in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Failable-Initializers"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A failable initializer requirement can be satisfied by a failable or nonfailable initializer on a conforming type. A nonfailable initializer requirement can be satisfied by a nonfailable initializer or an implicitly unwrapped failable initializer."}],"type":"paragraph"},{"anchor":"Protocols-as-Types","level":2,"text":"Protocols as Types","type":"heading"},{"inlineContent":[{"text":"Protocols don’t actually implement any functionality themselves. Nonetheless, you can use protocols as a fully fledged types in your code. Using a protocol as a type is sometimes called an ","type":"text"},{"inlineContent":[{"text":"existential type","type":"text"}],"type":"emphasis"},{"text":", which comes from the phrase “there exists a type ","type":"text"},{"inlineContent":[{"text":"T","type":"text"}],"type":"emphasis"},{"text":" such that ","type":"text"},{"inlineContent":[{"type":"text","text":"T"}],"type":"emphasis"},{"text":" conforms to the protocol”.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can use a protocol in many places where other types are allowed, including:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As a parameter type or return type in a function, method, or initializer"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As the type of a constant, variable, or property"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"As the type of items in an array, dictionary, or other container"}],"type":"paragraph"}]}],"type":"unorderedList"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Because protocols are types, begin their names with a capital letter (such as "},{"type":"codeVoice","code":"FullyNamed"},{"type":"text","text":" and "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":") to match the names of other types in Swift (such as "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Double"},{"type":"text","text":")."}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"type":"text","text":"Here’s an example of a protocol used as a type:"}],"type":"paragraph"},{"syntax":"swift","code":["class Dice {","    let sides: Int","    let generator: RandomNumberGenerator","    init(sides: Int, generator: RandomNumberGenerator) {","        self.sides = sides","        self.generator = generator","    }","    func roll() -> Int {","        return Int(generator.random() * Double(sides)) + 1","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example defines a new class called "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":", which represents an "},{"type":"emphasis","inlineContent":[{"text":"n","type":"text"}]},{"type":"text","text":"-sided dice for use in a board game. "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instances have an integer property called "},{"type":"codeVoice","code":"sides"},{"type":"text","text":", which represents how many sides they have, and a property called "},{"type":"codeVoice","code":"generator"},{"type":"text","text":", which provides a random number generator from which to create dice roll values."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"generator"},{"type":"text","text":" property is of type "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":". Therefore, you can set it to an instance of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"type":"text","text":" type that adopts the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol. Nothing else is required of the instance you assign to this property, except that the instance must adopt the "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":" protocol. Because its type is "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":", code inside the "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" class can only interact with "},{"type":"codeVoice","code":"generator"},{"type":"text","text":" in ways that apply to all generators that conform to this protocol. That means it can’t use any methods or properties that are defined by the underlying type of the generator. However, you can downcast from a protocol type to an underlying type in the same way you can downcast from a superclass to a subclass, as discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting#Downcasting"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"Dice"},{"type":"text","text":" also has an initializer, to set up its initial state. This initializer has a parameter called "},{"type":"codeVoice","code":"generator"},{"type":"text","text":", which is also of type "},{"type":"codeVoice","code":"RandomNumberGenerator"},{"type":"text","text":". You can pass a value of any conforming type in to this parameter when initializing a new "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instance."}],"type":"paragraph"},{"inlineContent":[{"code":"Dice","type":"codeVoice"},{"type":"text","text":" provides one instance method, "},{"code":"roll","type":"codeVoice"},{"type":"text","text":", which returns an integer value between 1 and the number of sides on the dice. This method calls the generator’s "},{"code":"random()","type":"codeVoice"},{"type":"text","text":" method to create a new random number between "},{"code":"0.0","type":"codeVoice"},{"type":"text","text":" and "},{"code":"1.0","type":"codeVoice"},{"type":"text","text":", and uses this random number to create a dice roll value within the correct range. Because "},{"code":"generator","type":"codeVoice"},{"type":"text","text":" is known to adopt "},{"code":"RandomNumberGenerator","type":"codeVoice"},{"type":"text","text":", it’s guaranteed to have a "},{"code":"random()","type":"codeVoice"},{"type":"text","text":" method to call."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s how the ","type":"text"},{"code":"Dice","type":"codeVoice"},{"text":" class can be used to create a six-sided dice with a ","type":"text"},{"code":"LinearCongruentialGenerator","type":"codeVoice"},{"text":" instance as its random number generator:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())","for _ in 1...5 {","    print(\"Random dice roll is \\(d6.roll())\")","}","\/\/ Random dice roll is 3","\/\/ Random dice roll is 5","\/\/ Random dice roll is 4","\/\/ Random dice roll is 5","\/\/ Random dice roll is 4"],"type":"codeListing"},{"anchor":"Delegation","level":2,"text":"Delegation","type":"heading"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Delegation","type":"text"}]},{"text":" is a design pattern that enables a class or structure to hand off (or ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"delegate","type":"text"}]},{"text":") some of its responsibilities to an instance of another type. This design pattern is implemented by defining a protocol that encapsulates the delegated responsibilities, such that a conforming type (known as a delegate) is guaranteed to provide the functionality that has been delegated. Delegation can be used to respond to a particular action, or to retrieve data from an external source without needing to know the underlying type of that source.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example below defines two protocols for use with dice-based board games:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol DiceGame {","    var dice: Dice { get }","    func play()","}","protocol DiceGameDelegate: AnyObject {","    func gameDidStart(_ game: DiceGame)","    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)","    func gameDidEnd(_ game: DiceGame)","}"],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"DiceGame"},{"text":" protocol is a protocol that can be adopted by any game that involves dice.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"DiceGameDelegate","type":"codeVoice"},{"type":"text","text":" protocol can be adopted to track the progress of a "},{"code":"DiceGame","type":"codeVoice"},{"type":"text","text":". To prevent strong reference cycles, delegates are declared as weak references. For information about weak references, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances"},{"type":"text","text":". Marking the protocol as class-only lets the "},{"code":"SnakesAndLadders","type":"codeVoice"},{"type":"text","text":" class later in this chapter declare that its delegate must use a weak reference. A class-only protocol is marked by its inheritance from "},{"code":"AnyObject","type":"codeVoice"},{"type":"text","text":", as discussed in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Class-Only-Protocols"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s a version of the "},{"inlineContent":[{"type":"text","text":"Snakes and Ladders"}],"type":"emphasis"},{"type":"text","text":" game originally introduced in "},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","type":"reference"},{"type":"text","text":". This version is adapted to use a "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" instance for its dice-rolls; to adopt the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol; and to notify a "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" about its progress:"}],"type":"paragraph"},{"syntax":"swift","code":["class SnakesAndLadders: DiceGame {","    let finalSquare = 25","    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())","    var square = 0","    var board: [Int]","    init() {","        board = Array(repeating: 0, count: finalSquare + 1)","        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02","        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08","    }","    weak var delegate: DiceGameDelegate?","    func play() {","        square = 0","        delegate?.gameDidStart(self)","        gameLoop: while square != finalSquare {","            let diceRoll = dice.roll()","            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)","            switch square + diceRoll {","            case finalSquare:","                break gameLoop","            case let newSquare where newSquare > finalSquare:","                continue gameLoop","            default:","                square += diceRoll","                square += board[square]","            }","        }","        delegate?.gameDidEnd(self)","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"For a description of the ","type":"text"},{"inlineContent":[{"text":"Snakes and Ladders","type":"text"}],"type":"emphasis"},{"text":" gameplay, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Break","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This version of the game is wrapped up as a class called "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":", which adopts the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol. It provides a gettable "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property and a "},{"type":"codeVoice","code":"play()"},{"type":"text","text":" method in order to conform to the protocol. (The "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property is declared as a constant property because it doesn’t need to change after initialization, and the protocol only requires that it must be gettable.)"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"Snakes and Ladders"}],"type":"emphasis"},{"text":" game board setup takes place within the class’s ","type":"text"},{"code":"init()","type":"codeVoice"},{"text":" initializer. All game logic is moved into the protocol’s ","type":"text"},{"code":"play","type":"codeVoice"},{"text":" method, which uses the protocol’s required ","type":"text"},{"code":"dice","type":"codeVoice"},{"text":" property to provide its dice roll values.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is defined as an "},{"type":"emphasis","inlineContent":[{"text":"optional","type":"text"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":", because a delegate isn’t required in order to play the game. Because it’s of an optional type, the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is automatically set to an initial value of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Thereafter, the game instantiator has the option to set the property to a suitable delegate. Because the "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":" protocol is class-only, you can declare the delegate to be "},{"type":"codeVoice","code":"weak"},{"type":"text","text":" to prevent reference cycles."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"DiceGameDelegate"},{"text":" provides three methods for tracking the progress of a game. These three methods have been incorporated into the game logic within the ","type":"text"},{"type":"codeVoice","code":"play()"},{"text":" method above, and are called when a new game starts, a new turn begins, or the game ends.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Because the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"DiceGameDelegate"},{"type":"text","text":", the "},{"type":"codeVoice","code":"play()"},{"type":"text","text":" method uses optional chaining each time it calls a method on the delegate. If the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is nil, these delegate calls fail gracefully and without error. If the "},{"type":"codeVoice","code":"delegate"},{"type":"text","text":" property is non-nil, the delegate methods are called, and are passed the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" instance as a parameter."}],"type":"paragraph"},{"inlineContent":[{"text":"This next example shows a class called ","type":"text"},{"code":"DiceGameTracker","type":"codeVoice"},{"text":", which adopts the ","type":"text"},{"code":"DiceGameDelegate","type":"codeVoice"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class DiceGameTracker: DiceGameDelegate {","    var numberOfTurns = 0","    func gameDidStart(_ game: DiceGame) {","        numberOfTurns = 0","        if game is SnakesAndLadders {","            print(\"Started a new game of Snakes and Ladders\")","        }","        print(\"The game is using a \\(game.dice.sides)-sided dice\")","    }","    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {","        numberOfTurns += 1","        print(\"Rolled a \\(diceRoll)\")","    }","    func gameDidEnd(_ game: DiceGame) {","        print(\"The game lasted for \\(numberOfTurns) turns\")","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"DiceGameTracker"},{"text":" implements all three methods required by ","type":"text"},{"type":"codeVoice","code":"DiceGameDelegate"},{"text":". It uses these methods to keep track of the number of turns a game has taken. It resets a ","type":"text"},{"type":"codeVoice","code":"numberOfTurns"},{"text":" property to zero when the game starts, increments it each time a new turn begins, and prints out the total number of turns once the game has ended.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The implementation of "},{"code":"gameDidStart(_:)","type":"codeVoice"},{"type":"text","text":" shown above uses the "},{"code":"game","type":"codeVoice"},{"type":"text","text":" parameter to print some introductory information about the game that’s about to be played. The "},{"code":"game","type":"codeVoice"},{"type":"text","text":" parameter has a type of "},{"code":"DiceGame","type":"codeVoice"},{"type":"text","text":", not "},{"code":"SnakesAndLadders","type":"codeVoice"},{"type":"text","text":", and so "},{"code":"gameDidStart(_:)","type":"codeVoice"},{"type":"text","text":" can access and use only methods and properties that are implemented as part of the "},{"code":"DiceGame","type":"codeVoice"},{"type":"text","text":" protocol. However, the method is still able to use type casting to query the type of the underlying instance. In this example, it checks whether "},{"code":"game","type":"codeVoice"},{"type":"text","text":" is actually an instance of "},{"code":"SnakesAndLadders","type":"codeVoice"},{"type":"text","text":" behind the scenes, and prints an appropriate message if so."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" method also accesses the "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property of the passed "},{"type":"codeVoice","code":"game"},{"type":"text","text":" parameter. Because "},{"type":"codeVoice","code":"game"},{"type":"text","text":" is known to conform to the "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":" protocol, it’s guaranteed to have a "},{"type":"codeVoice","code":"dice"},{"type":"text","text":" property, and so the "},{"type":"codeVoice","code":"gameDidStart(_:)"},{"type":"text","text":" method is able to access and print the dice’s "},{"type":"codeVoice","code":"sides"},{"type":"text","text":" property, regardless of what kind of game is being played."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s how ","type":"text"},{"code":"DiceGameTracker","type":"codeVoice"},{"text":" looks in action:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let tracker = DiceGameTracker()","let game = SnakesAndLadders()","game.delegate = tracker","game.play()","\/\/ Started a new game of Snakes and Ladders","\/\/ The game is using a 6-sided dice","\/\/ Rolled a 3","\/\/ Rolled a 5","\/\/ Rolled a 4","\/\/ Rolled a 5","\/\/ The game lasted for 4 turns"],"type":"codeListing"},{"anchor":"Adding-Protocol-Conformance-with-an-Extension","level":2,"text":"Adding Protocol Conformance with an Extension","type":"heading"},{"inlineContent":[{"text":"You can extend an existing type to adopt and conform to a new protocol, even if you don’t have access to the source code for the existing type. Extensions can add new properties, methods, and subscripts to an existing type, and are therefore able to add any requirements that a protocol may demand. For more about extensions, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Existing instances of a type automatically adopt and conform to a protocol when that conformance is added to the instance’s type in an extension.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"inlineContent":[{"type":"text","text":"For example, this protocol, called "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":", can be implemented by any type that has a way to be represented as text. This might be a description of itself, or a text version of its current state:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol TextRepresentable {","    var textualDescription: String { get }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":" class from above can be extended to adopt and conform to "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["extension Dice: TextRepresentable {","    var textualDescription: String {","        return \"A \\(sides)-sided dice\"","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"This extension adopts the new protocol in exactly the same way as if ","type":"text"},{"code":"Dice","type":"codeVoice"},{"text":" had provided it in its original implementation. The protocol name is provided after the type name, separated by a colon, and an implementation of all requirements of the protocol is provided within the extension’s curly braces.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Any ","type":"text"},{"type":"codeVoice","code":"Dice"},{"text":" instance can now be treated as ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())","print(d12.textualDescription)","\/\/ Prints \"A 12-sided dice\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Similarly, the "},{"code":"SnakesAndLadders","type":"codeVoice"},{"type":"text","text":" game class can be extended to adopt and conform to the "},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"syntax":"swift","code":["extension SnakesAndLadders: TextRepresentable {","    var textualDescription: String {","        return \"A game of Snakes and Ladders with \\(finalSquare) squares\"","    }","}","print(game.textualDescription)","\/\/ Prints \"A game of Snakes and Ladders with 25 squares\""],"type":"codeListing"},{"anchor":"Conditionally-Conforming-to-a-Protocol","level":3,"text":"Conditionally Conforming to a Protocol","type":"heading"},{"inlineContent":[{"text":"A generic type may be able to satisfy the requirements of a protocol only under certain conditions, such as when the type’s generic parameter conforms to the protocol. You can make a generic type conditionally conform to a protocol by listing constraints when extending the type. Write these constraints after the name of the protocol you’re adopting by writing a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause. For more about generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clauses, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Generic-Where-Clauses","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The following extension makes ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" instances conform to the ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"text":" protocol whenever they store elements of a type that conforms to ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["extension Array: TextRepresentable where Element: TextRepresentable {","    var textualDescription: String {","        let itemsAsText = self.map { $0.textualDescription }","        return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"","    }","}","let myDice = [d6, d12]","print(myDice.textualDescription)","\/\/ Prints \"[A 6-sided dice, A 12-sided dice]\""],"type":"codeListing"},{"anchor":"Declaring-Protocol-Adoption-with-an-Extension","level":3,"text":"Declaring Protocol Adoption with an Extension","type":"heading"},{"inlineContent":[{"text":"If a type already conforms to all of the requirements of a protocol, but hasn’t yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Hamster {","    var name: String","    var textualDescription: String {","        return \"A hamster named \\(name)\"","    }","}","extension Hamster: TextRepresentable {}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Instances of "},{"code":"Hamster","type":"codeVoice"},{"type":"text","text":" can now be used wherever "},{"code":"TextRepresentable","type":"codeVoice"},{"type":"text","text":" is the required type:"}],"type":"paragraph"},{"syntax":"swift","code":["let simonTheHamster = Hamster(name: \"Simon\")","let somethingTextRepresentable: TextRepresentable = simonTheHamster","print(somethingTextRepresentable.textualDescription)","\/\/ Prints \"A hamster named Simon\""],"type":"codeListing"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Types don’t automatically adopt a protocol just by satisfying its requirements. They must always explicitly declare their adoption of the protocol.","type":"text"}]}],"style":"note","name":"Note","type":"aside"},{"anchor":"Adopting-a-Protocol-Using-a-Synthesized-Implementation","level":2,"text":"Adopting a Protocol Using a Synthesized Implementation","type":"heading"},{"inlineContent":[{"text":"Swift can automatically provide the protocol conformance for ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"text":" in many simple cases. Using this synthesized implementation means you don’t have to write repetitive boilerplate code to implement the protocol requirements yourself.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift provides a synthesized implementation of ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" for the following kinds of custom types:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Structures that have only stored properties that conform to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Enumerations that have only associated types that conform to the ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" protocol","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Enumerations that have no associated types","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"To receive a synthesized implementation of "},{"type":"codeVoice","code":"=="},{"type":"text","text":", declare conformance to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" in the file that contains the original declaration, without implementing an "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator yourself. The "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol provides a default implementation of "},{"type":"codeVoice","code":"!="},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines a ","type":"text"},{"code":"Vector3D","type":"codeVoice"},{"text":" structure for a three-dimensional position vector ","type":"text"},{"code":"(x, y, z)","type":"codeVoice"},{"text":", similar to the ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"text":" structure. Because the ","type":"text"},{"code":"x","type":"codeVoice"},{"text":", ","type":"text"},{"code":"y","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"z","type":"codeVoice"},{"text":" properties are all of an ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" type, ","type":"text"},{"code":"Vector3D","type":"codeVoice"},{"text":" receives synthesized implementations of the equivalence operators.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct Vector3D: Equatable {","    var x = 0.0, y = 0.0, z = 0.0","}","","let twoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)","let anotherTwoThreeFour = Vector3D(x: 2.0, y: 3.0, z: 4.0)","if twoThreeFour == anotherTwoThreeFour {","    print(\"These two vectors are also equivalent.\")","}","\/\/ Prints \"These two vectors are also equivalent.\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Swift provides a synthesized implementation of "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" for the following kinds of custom types:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Structures that have only stored properties that conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol"}]}]},{"content":[{"inlineContent":[{"text":"Enumerations that have only associated types that conform to the ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":" protocol","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Enumerations that have no associated types","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"To receive a synthesized implementation of "},{"type":"codeVoice","code":"hash(into:)"},{"type":"text","text":", declare conformance to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" in the file that contains the original declaration, without implementing a "},{"type":"codeVoice","code":"hash(into:)"},{"type":"text","text":" method yourself."}],"type":"paragraph"},{"inlineContent":[{"text":"Swift provides a synthesized implementation of ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"text":" for enumerations that don’t have a raw value. If the enumeration has associated types, they must all conform to the ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"text":" protocol. To receive a synthesized implementation of ","type":"text"},{"type":"codeVoice","code":"<"},{"text":", declare conformance to ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"text":" in the file that contains the original enumeration declaration, without implementing a ","type":"text"},{"type":"codeVoice","code":"<"},{"text":" operator yourself. The ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"text":" protocol’s default implementation of ","type":"text"},{"type":"codeVoice","code":"<="},{"text":", ","type":"text"},{"type":"codeVoice","code":">"},{"text":", and ","type":"text"},{"type":"codeVoice","code":">="},{"text":" provides the remaining comparison operators.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines a ","type":"text"},{"code":"SkillLevel","type":"codeVoice"},{"text":" enumeration with cases for beginners, intermediates, and experts. Experts are additionally ranked by the number of stars they have.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["enum SkillLevel: Comparable {","    case beginner","    case intermediate","    case expert(stars: Int)","}","var levels = [SkillLevel.intermediate, SkillLevel.beginner,","              SkillLevel.expert(stars: 5), SkillLevel.expert(stars: 3)]","for level in levels.sorted() {","    print(level)","}","\/\/ Prints \"beginner\"","\/\/ Prints \"intermediate\"","\/\/ Prints \"expert(stars: 3)\"","\/\/ Prints \"expert(stars: 5)\""],"type":"codeListing"},{"anchor":"Collections-of-Protocol-Types","level":2,"text":"Collections of Protocol Types","type":"heading"},{"inlineContent":[{"text":"A protocol can be used as the type to be stored in a collection such as an array or a dictionary, as mentioned in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Protocols-as-Types","isActive":true},{"text":". This example creates an array of ","type":"text"},{"code":"TextRepresentable","type":"codeVoice"},{"text":" things:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let things: [TextRepresentable] = [game, d12, simonTheHamster]"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"It’s now possible to iterate over the items in the array, and print each item’s textual description:"}],"type":"paragraph"},{"syntax":"swift","code":["for thing in things {","    print(thing.textualDescription)","}","\/\/ A game of Snakes and Ladders with 25 squares","\/\/ A 12-sided dice","\/\/ A hamster named Simon"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":"thing"},{"type":"text","text":" constant is of type "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":". It’s not of type "},{"type":"codeVoice","code":"Dice"},{"type":"text","text":", or "},{"type":"codeVoice","code":"DiceGame"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Hamster"},{"type":"text","text":", even if the actual instance behind the scenes is of one of those types. Nonetheless, because it’s of type "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":", and anything that’s "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" is known to have a "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property, it’s safe to access "},{"type":"codeVoice","code":"thing.textualDescription"},{"type":"text","text":" each time through the loop."}],"type":"paragraph"},{"anchor":"Protocol-Inheritance","level":2,"text":"Protocol Inheritance","type":"heading"},{"inlineContent":[{"type":"text","text":"A protocol can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inherit"}]},{"type":"text","text":" one or more other protocols and can add further requirements on top of the requirements it inherits. The syntax for protocol inheritance is similar to the syntax for class inheritance, but with the option to list multiple inherited protocols, separated by commas:"}],"type":"paragraph"},{"syntax":"swift","code":["protocol InheritingProtocol: SomeProtocol, AnotherProtocol {","    \/\/ protocol definition goes here","}"],"type":"codeListing"},{"inlineContent":[{"text":"Here’s an example of a protocol that inherits the ","type":"text"},{"type":"codeVoice","code":"TextRepresentable"},{"text":" protocol from above:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["protocol PrettyTextRepresentable: TextRepresentable {","    var prettyTextualDescription: String { get }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example defines a new protocol, "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":", which inherits from "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":". Anything that adopts "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" must satisfy all of the requirements enforced by "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":", "},{"type":"emphasis","inlineContent":[{"text":"plus","type":"text"}]},{"type":"text","text":" the additional requirements enforced by "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":". In this example, "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" adds a single requirement to provide a gettable property called "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" that returns a "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"SnakesAndLadders","type":"codeVoice"},{"type":"text","text":" class can be extended to adopt and conform to "},{"code":"PrettyTextRepresentable","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","code":["extension SnakesAndLadders: PrettyTextRepresentable {","    var prettyTextualDescription: String {","        var output = textualDescription + \":\\n\"","        for index in 1...finalSquare {","            switch board[index] {","            case let ladder where ladder > 0:","                output += \"▲ \"","            case let snake where snake < 0:","                output += \"▼ \"","            default:","                output += \"○ \"","            }","        }","        return output","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This extension states that it adopts the "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" protocol and provides an implementation of the "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" property for the "},{"type":"codeVoice","code":"SnakesAndLadders"},{"type":"text","text":" type. Anything that’s "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" must also be "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":", and so the implementation of "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" starts by accessing the "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property from the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol to begin an output string. It appends a colon and a line break, and uses this as the start of its pretty text representation. It then iterates through the array of board squares, and appends a geometric shape to represent the contents of each square:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"If the square’s value is greater than ","type":"text"},{"type":"codeVoice","code":"0"},{"text":", it’s the base of a ladder, and is represented by ","type":"text"},{"type":"codeVoice","code":"▲"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"If the square’s value is less than ","type":"text"},{"code":"0","type":"codeVoice"},{"text":", it’s the head of a snake, and is represented by ","type":"text"},{"code":"▼","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Otherwise, the square’s value is "},{"type":"codeVoice","code":"0"},{"type":"text","text":", and it’s a “free” square, represented by "},{"type":"codeVoice","code":"○"},{"type":"text","text":"."}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"prettyTextualDescription","type":"codeVoice"},{"text":" property can now be used to print a pretty text description of any ","type":"text"},{"code":"SnakesAndLadders","type":"codeVoice"},{"text":" instance:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["print(game.prettyTextualDescription)","\/\/ A game of Snakes and Ladders with 25 squares:","\/\/ ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○"],"type":"codeListing"},{"anchor":"Class-Only-Protocols","level":2,"text":"Class-Only Protocols","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can limit protocol adoption to class types (and not structures or enumerations) by adding the ","type":"text"},{"code":"AnyObject","type":"codeVoice"},{"text":" protocol to a protocol’s inheritance list.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {","    \/\/ class-only protocol definition goes here","}"]},{"type":"paragraph","inlineContent":[{"text":"In the example above, ","type":"text"},{"type":"codeVoice","code":"SomeClassOnlyProtocol"},{"text":" can only be adopted by class types. It’s a compile-time error to write a structure or enumeration definition that tries to adopt ","type":"text"},{"type":"codeVoice","code":"SomeClassOnlyProtocol"},{"text":".","type":"text"}]},{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"text":"Use a class-only protocol when the behavior defined by that protocol’s requirements assumes or requires that a conforming type has reference semantics rather than value semantics. For more about reference and value semantics, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","type":"reference","isActive":true},{"text":" and ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Classes-Are-Reference-Types","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"}]},{"anchor":"Protocol-Composition","type":"heading","level":2,"text":"Protocol Composition"},{"type":"paragraph","inlineContent":[{"text":"It can be useful to require a type to conform to multiple protocols at the same time. You can combine multiple protocols into a single requirement with a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"protocol composition"}]},{"text":". Protocol compositions behave as if you defined a temporary local protocol that has the combined requirements of all protocols in the composition. Protocol compositions don’t define any new protocol types.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol compositions have the form "},{"type":"codeVoice","code":"SomeProtocol & AnotherProtocol"},{"type":"text","text":". You can list as many protocols as you need, separating them with ampersands ("},{"type":"codeVoice","code":"&"},{"type":"text","text":"). In addition to its list of protocols, a protocol composition can also contain one class type, which you can use to specify a required superclass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example that combines two protocols called "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Aged"},{"type":"text","text":" into a single protocol composition requirement on a function parameter:"}]},{"syntax":"swift","type":"codeListing","code":["protocol Named {","    var name: String { get }","}","protocol Aged {","    var age: Int { get }","}","struct Person: Named, Aged {","    var name: String","    var age: Int","}","func wishHappyBirthday(to celebrator: Named & Aged) {","    print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\")","}","let birthdayPerson = Person(name: \"Malcolm\", age: 21)","wishHappyBirthday(to: birthdayPerson)","\/\/ Prints \"Happy birthday, Malcolm, you're 21!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, the "},{"code":"Named","type":"codeVoice"},{"type":"text","text":" protocol has a single requirement for a gettable "},{"code":"String","type":"codeVoice"},{"type":"text","text":" property called "},{"code":"name","type":"codeVoice"},{"type":"text","text":". The "},{"code":"Aged","type":"codeVoice"},{"type":"text","text":" protocol has a single requirement for a gettable "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" property called "},{"code":"age","type":"codeVoice"},{"type":"text","text":". Both protocols are adopted by a structure called "},{"code":"Person","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example also defines a "},{"type":"codeVoice","code":"wishHappyBirthday(to:)"},{"type":"text","text":" function. The type of the "},{"type":"codeVoice","code":"celebrator"},{"type":"text","text":" parameter is "},{"type":"codeVoice","code":"Named & Aged"},{"type":"text","text":", which means “any type that conforms to both the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Aged"},{"type":"text","text":" protocols.” It doesn’t matter which specific type is passed to the function, as long as it conforms to both of the required protocols."}]},{"type":"paragraph","inlineContent":[{"text":"The example then creates a new ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance called ","type":"text"},{"code":"birthdayPerson","type":"codeVoice"},{"text":" and passes this new instance to the ","type":"text"},{"code":"wishHappyBirthday(to:)","type":"codeVoice"},{"text":" function. Because ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" conforms to both protocols, this call is valid, and the ","type":"text"},{"code":"wishHappyBirthday(to:)","type":"codeVoice"},{"text":" function can print its birthday greeting.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example that combines the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" protocol from the previous example with a "},{"type":"codeVoice","code":"Location"},{"type":"text","text":" class:"}]},{"syntax":"swift","type":"codeListing","code":["class Location {","    var latitude: Double","    var longitude: Double","    init(latitude: Double, longitude: Double) {","        self.latitude = latitude","        self.longitude = longitude","    }","}","class City: Location, Named {","    var name: String","    init(name: String, latitude: Double, longitude: Double) {","        self.name = name","        super.init(latitude: latitude, longitude: longitude)","    }","}","func beginConcert(in location: Location & Named) {","    print(\"Hello, \\(location.name)!\")","}","","let seattle = City(name: \"Seattle\", latitude: 47.6, longitude: -122.3)","beginConcert(in: seattle)","\/\/ Prints \"Hello, Seattle!\""]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"beginConcert(in:)"},{"text":" function takes a parameter of type ","type":"text"},{"type":"codeVoice","code":"Location & Named"},{"text":", which means “any type that’s a subclass of ","type":"text"},{"type":"codeVoice","code":"Location"},{"text":" and that conforms to the ","type":"text"},{"type":"codeVoice","code":"Named"},{"text":" protocol.” In this case, ","type":"text"},{"type":"codeVoice","code":"City"},{"text":" satisfies both requirements.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Passing "},{"type":"codeVoice","code":"birthdayPerson"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" function is invalid because "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" isn’t a subclass of "},{"type":"codeVoice","code":"Location"},{"type":"text","text":". Likewise, if you made a subclass of "},{"type":"codeVoice","code":"Location"},{"type":"text","text":" that didn’t conform to the "},{"type":"codeVoice","code":"Named"},{"type":"text","text":" protocol, calling "},{"type":"codeVoice","code":"beginConcert(in:)"},{"type":"text","text":" with an instance of that type is also invalid."}]},{"anchor":"Checking-for-Protocol-Conformance","type":"heading","level":2,"text":"Checking for Protocol Conformance"},{"type":"paragraph","inlineContent":[{"text":"You can use the ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"as","type":"codeVoice"},{"text":" operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","isActive":true},{"text":" to check for protocol conformance, and to cast to a specific protocol. Checking for and casting to a protocol follows exactly the same syntax as checking for and casting to a type:","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" operator returns ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" if an instance conforms to a protocol and returns ","type":"text"},{"code":"false","type":"codeVoice"},{"text":" if it doesn’t.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"as?"},{"type":"text","text":" version of the downcast operator returns an optional value of the protocol’s type, and this value is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" if the instance doesn’t conform to that protocol."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"as!","type":"codeVoice"},{"text":" version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast doesn’t succeed.","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"This example defines a protocol called ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"text":", with a single property requirement of a gettable ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" property called ","type":"text"},{"code":"area","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["protocol HasArea {","    var area: Double { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here are two classes, "},{"type":"codeVoice","code":"Circle"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Country"},{"type":"text","text":", both of which conform to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol:"}]},{"syntax":"swift","type":"codeListing","code":["class Circle: HasArea {","    let pi = 3.1415927","    var radius: Double","    var area: Double { return pi * radius * radius }","    init(radius: Double) { self.radius = radius }","}","class Country: HasArea {","    var area: Double","    init(area: Double) { self.area = area }","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"Circle","type":"codeVoice"},{"text":" class implements the ","type":"text"},{"code":"area","type":"codeVoice"},{"text":" property requirement as a computed property, based on a stored ","type":"text"},{"code":"radius","type":"codeVoice"},{"text":" property. The ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" class implements the ","type":"text"},{"code":"area","type":"codeVoice"},{"text":" requirement directly as a stored property. Both classes correctly conform to the ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"text":" protocol.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a class called "},{"code":"Animal","type":"codeVoice"},{"type":"text","text":", which doesn’t conform to the "},{"code":"HasArea","type":"codeVoice"},{"type":"text","text":" protocol:"}]},{"syntax":"swift","type":"codeListing","code":["class Animal {","    var legs: Int","    init(legs: Int) { self.legs = legs }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"Circle","type":"codeVoice"},{"type":"text","text":", "},{"code":"Country","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Animal","type":"codeVoice"},{"type":"text","text":" classes don’t have a shared base class. Nonetheless, they’re all classes, and so instances of all three types can be used to initialize an array that stores values of type "},{"code":"AnyObject","type":"codeVoice"},{"type":"text","text":":"}]},{"syntax":"swift","type":"codeListing","code":["let objects: [AnyObject] = [","    Circle(radius: 2.0),","    Country(area: 243_610),","    Animal(legs: 4)","]"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"objects","type":"codeVoice"},{"text":" array is initialized with an array literal containing a ","type":"text"},{"code":"Circle","type":"codeVoice"},{"text":" instance with a radius of 2 units; a ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" instance initialized with the surface area of the United Kingdom in square kilometers; and an ","type":"text"},{"code":"Animal","type":"codeVoice"},{"text":" instance with four legs.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"objects"},{"type":"text","text":" array can now be iterated, and each object in the array can be checked to see if it conforms to the "},{"type":"codeVoice","code":"HasArea"},{"type":"text","text":" protocol:"}]},{"syntax":"swift","type":"codeListing","code":["for object in objects {","    if let objectWithArea = object as? HasArea {","        print(\"Area is \\(objectWithArea.area)\")","    } else {","        print(\"Something that doesn't have an area\")","    }","}","\/\/ Area is 12.5663708","\/\/ Area is 243610.0","\/\/ Something that doesn't have an area"]},{"type":"paragraph","inlineContent":[{"text":"Whenever an object in the array conforms to the ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"text":" protocol, the optional value returned by the ","type":"text"},{"code":"as?","type":"codeVoice"},{"text":" operator is unwrapped with optional binding into a constant called ","type":"text"},{"code":"objectWithArea","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"objectWithArea","type":"codeVoice"},{"text":" constant is known to be of type ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"text":", and so its ","type":"text"},{"code":"area","type":"codeVoice"},{"text":" property can be accessed and printed in a type-safe way.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Note that the underlying objects aren’t changed by the casting process. They continue to be a ","type":"text"},{"code":"Circle","type":"codeVoice"},{"text":", a ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" and an ","type":"text"},{"code":"Animal","type":"codeVoice"},{"text":". However, at the point that they’re stored in the ","type":"text"},{"code":"objectWithArea","type":"codeVoice"},{"text":" constant, they’re only known to be of type ","type":"text"},{"code":"HasArea","type":"codeVoice"},{"text":", and so only their ","type":"text"},{"code":"area","type":"codeVoice"},{"text":" property can be accessed.","type":"text"}]},{"anchor":"Optional-Protocol-Requirements","type":"heading","level":2,"text":"Optional Protocol Requirements"},{"type":"paragraph","inlineContent":[{"text":"You can define ","type":"text"},{"inlineContent":[{"text":"optional requirements","type":"text"}],"type":"emphasis"},{"text":" for protocols. These requirements don’t have to be implemented by types that conform to the protocol. Optional requirements are prefixed by the ","type":"text"},{"code":"optional","type":"codeVoice"},{"text":" modifier as part of the protocol’s definition. Optional requirements are available so that you can write code that interoperates with Objective-C. Both the protocol and the optional requirement must be marked with the ","type":"text"},{"code":"@objc","type":"codeVoice"},{"text":" attribute. Note that ","type":"text"},{"code":"@objc","type":"codeVoice"},{"text":" protocols can be adopted only by classes that inherit from Objective-C classes or other ","type":"text"},{"code":"@objc","type":"codeVoice"},{"text":" classes. They can’t be adopted by structures or enumerations.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"When you use a method or property in an optional requirement, its type automatically becomes an optional. For example, a method of type ","type":"text"},{"type":"codeVoice","code":"(Int) -> String"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"((Int) -> String)?"},{"text":". Note that the entire function type is wrapped in the optional, not the method’s return value.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An optional protocol requirement can be called with optional chaining, to account for the possibility that the requirement was not implemented by a type that conforms to the protocol. You check for an implementation of an optional method by writing a question mark after the name of the method when it’s called, such as "},{"type":"codeVoice","code":"someOptionalMethod?(someArgument)"},{"type":"text","text":". For information on optional chaining, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"The following example defines an integer-counting class called ","type":"text"},{"type":"codeVoice","code":"Counter"},{"text":", which uses an external data source to provide its increment amount. This data source is defined by the ","type":"text"},{"type":"codeVoice","code":"CounterDataSource"},{"text":" protocol, which has two optional requirements:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["@objc protocol CounterDataSource {","    @objc optional func increment(forCount count: Int) -> Int","    @objc optional var fixedIncrement: Int { get }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol defines an optional method requirement called "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" and an optional property requirement called "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":". These requirements define two different ways for data sources to provide an appropriate increment amount for a "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance."}]},{"style":"note","name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Strictly speaking, you can write a custom class that conforms to "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" without implementing "},{"type":"emphasis","inlineContent":[{"text":"either","type":"text"}]},{"type":"text","text":" protocol requirement. They’re both optional, after all. Although technically allowed, this wouldn’t make for a very good data source."}]}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"Counter","type":"codeVoice"},{"text":" class, defined below, has an optional ","type":"text"},{"code":"dataSource","type":"codeVoice"},{"text":" property of type ","type":"text"},{"code":"CounterDataSource?","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class Counter {","    var count = 0","    var dataSource: CounterDataSource?","    func increment() {","        if let amount = dataSource?.increment?(forCount: count) {","            count += amount","        } else if let amount = dataSource?.fixedIncrement {","            count += amount","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"Counter","type":"codeVoice"},{"text":" class stores its current value in a variable property called ","type":"text"},{"code":"count","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"Counter","type":"codeVoice"},{"text":" class also defines a method called ","type":"text"},{"code":"increment","type":"codeVoice"},{"text":", which increments the ","type":"text"},{"code":"count","type":"codeVoice"},{"text":" property every time the method is called.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"increment()","type":"codeVoice"},{"type":"text","text":" method first tries to retrieve an increment amount by looking for an implementation of the "},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":" method on its data source. The "},{"code":"increment()","type":"codeVoice"},{"type":"text","text":" method uses optional chaining to try to call "},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":", and passes the current "},{"code":"count","type":"codeVoice"},{"type":"text","text":" value as the method’s single argument."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"two"}]},{"type":"text","text":" levels of optional chaining are at play here. First, it’s possible that "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" may be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", and so "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" has a question mark after its name to indicate that "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" should be called only if "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Second, even if "},{"type":"codeVoice","code":"dataSource"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"does","type":"text"}]},{"type":"text","text":" exist, there’s no guarantee that it implements "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":", because it’s an optional requirement. Here, the possibility that "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" might not be implemented is also handled by optional chaining. The call to "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" happens only if "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" exists—that is, if it isn’t "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". This is why "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" is also written with a question mark after its name."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the call to "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" can fail for either of these two reasons, the call returns an "},{"type":"emphasis","inlineContent":[{"text":"optional","type":"text"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value. This is true even though "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" is defined as returning a non-optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value in the definition of "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":". Even though there are two optional chaining operations, one after another, the result is still wrapped in a single optional. For more information about using multiple optional chaining operations, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining#Linking-Multiple-Levels-of-Chaining","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After calling "},{"code":"increment(forCount:)","type":"codeVoice"},{"type":"text","text":", the optional "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" that it returns is unwrapped into a constant called "},{"code":"amount","type":"codeVoice"},{"type":"text","text":", using optional binding. If the optional "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" does contain a value—that is, if the delegate and method both exist, and the method returned a value—the unwrapped "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" is added onto the stored "},{"code":"count","type":"codeVoice"},{"type":"text","text":" property, and incrementation is complete."}]},{"type":"paragraph","inlineContent":[{"text":"If it’s ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"text":" possible to retrieve a value from the ","type":"text"},{"type":"codeVoice","code":"increment(forCount:)"},{"text":" method—either because ","type":"text"},{"type":"codeVoice","code":"dataSource"},{"text":" is nil, or because the data source doesn’t implement ","type":"text"},{"type":"codeVoice","code":"increment(forCount:)"},{"text":"—then the ","type":"text"},{"type":"codeVoice","code":"increment()"},{"text":" method tries to retrieve a value from the data source’s ","type":"text"},{"type":"codeVoice","code":"fixedIncrement"},{"text":" property instead. The ","type":"text"},{"type":"codeVoice","code":"fixedIncrement"},{"text":" property is also an optional requirement, so its value is an optional ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" value, even though ","type":"text"},{"type":"codeVoice","code":"fixedIncrement"},{"text":" is defined as a non-optional ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" property as part of the ","type":"text"},{"type":"codeVoice","code":"CounterDataSource"},{"text":" protocol definition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a simple "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" implementation where the data source returns a constant value of "},{"type":"codeVoice","code":"3"},{"type":"text","text":" every time it’s queried. It does this by implementing the optional "},{"type":"codeVoice","code":"fixedIncrement"},{"type":"text","text":" property requirement:"}]},{"syntax":"swift","type":"codeListing","code":["class ThreeSource: NSObject, CounterDataSource {","    let fixedIncrement = 3","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use an instance of "},{"type":"codeVoice","code":"ThreeSource"},{"type":"text","text":" as the data source for a new "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance:"}]},{"syntax":"swift","type":"codeListing","code":["var counter = Counter()","counter.dataSource = ThreeSource()","for _ in 1...4 {","    counter.increment()","    print(counter.count)","}","\/\/ 3","\/\/ 6","\/\/ 9","\/\/ 12"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a new "},{"code":"Counter","type":"codeVoice"},{"type":"text","text":" instance; sets its data source to be a new "},{"code":"ThreeSource","type":"codeVoice"},{"type":"text","text":" instance; and calls the counter’s "},{"code":"increment()","type":"codeVoice"},{"type":"text","text":" method four times. As expected, the counter’s "},{"code":"count","type":"codeVoice"},{"type":"text","text":" property increases by three each time "},{"code":"increment()","type":"codeVoice"},{"type":"text","text":" is called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a more complex data source called "},{"type":"codeVoice","code":"TowardsZeroSource"},{"type":"text","text":", which makes a "},{"type":"codeVoice","code":"Counter"},{"type":"text","text":" instance count up or down towards zero from its current "},{"type":"codeVoice","code":"count"},{"type":"text","text":" value:"}]},{"syntax":"swift","type":"codeListing","code":["class TowardsZeroSource: NSObject, CounterDataSource {","    func increment(forCount count: Int) -> Int {","        if count == 0 {","            return 0","        } else if count < 0 {","            return 1","        } else {","            return -1","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"TowardsZeroSource"},{"type":"text","text":" class implements the optional "},{"type":"codeVoice","code":"increment(forCount:)"},{"type":"text","text":" method from the "},{"type":"codeVoice","code":"CounterDataSource"},{"type":"text","text":" protocol and uses the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" argument value to work out which direction to count in. If "},{"type":"codeVoice","code":"count"},{"type":"text","text":" is already zero, the method returns "},{"type":"codeVoice","code":"0"},{"type":"text","text":" to indicate that no further counting should take place."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use an instance of "},{"code":"TowardsZeroSource","type":"codeVoice"},{"type":"text","text":" with the existing "},{"code":"Counter","type":"codeVoice"},{"type":"text","text":" instance to count from "},{"code":"-4","type":"codeVoice"},{"type":"text","text":" to zero. Once the counter reaches zero, no more counting takes place:"}]},{"syntax":"swift","type":"codeListing","code":["counter.count = -4","counter.dataSource = TowardsZeroSource()","for _ in 1...5 {","    counter.increment()","    print(counter.count)","}","\/\/ -3","\/\/ -2","\/\/ -1","\/\/ 0","\/\/ 0"]},{"anchor":"Protocol-Extensions","type":"heading","level":2,"text":"Protocol Extensions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocols can be extended to provide method, initializer, subscript, and computed property implementations to conforming types. This allows you to define behavior on protocols themselves, rather than in each type’s individual conformance or in a global function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"code":"RandomNumberGenerator","type":"codeVoice"},{"type":"text","text":" protocol can be extended to provide a "},{"code":"randomBool()","type":"codeVoice"},{"type":"text","text":" method, which uses the result of the required "},{"code":"random()","type":"codeVoice"},{"type":"text","text":" method to return a random "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" value:"}]},{"syntax":"swift","type":"codeListing","code":["extension RandomNumberGenerator {","    func randomBool() -> Bool {","        return random() > 0.5","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By creating an extension on the protocol, all conforming types automatically gain this method implementation without any additional modification."}]},{"syntax":"swift","type":"codeListing","code":["let generator = LinearCongruentialGenerator()","print(\"Here's a random number: \\(generator.random())\")","\/\/ Prints \"Here's a random number: 0.3746499199817101\"","print(\"And here's a random Boolean: \\(generator.randomBool())\")","\/\/ Prints \"And here's a random Boolean: true\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Protocol extensions can add implementations to conforming types but can’t make a protocol extend or inherit from another protocol. Protocol inheritance is always specified in the protocol declaration itself."}]},{"anchor":"Providing-Default-Implementations","type":"heading","level":3,"text":"Providing Default Implementations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use protocol extensions to provide a default implementation to any method or computed property requirement of that protocol. If a conforming type provides its own implementation of a required method or property, that implementation will be used instead of the one provided by the extension."}]},{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"type":"text","text":"Protocol requirements with default implementations provided by extensions are distinct from optional protocol requirements. Although conforming types don’t have to provide their own implementation of either, requirements with default implementations can be called without optional chaining."}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the "},{"type":"codeVoice","code":"PrettyTextRepresentable"},{"type":"text","text":" protocol, which inherits the "},{"type":"codeVoice","code":"TextRepresentable"},{"type":"text","text":" protocol can provide a default implementation of its required "},{"type":"codeVoice","code":"prettyTextualDescription"},{"type":"text","text":" property to simply return the result of accessing the "},{"type":"codeVoice","code":"textualDescription"},{"type":"text","text":" property:"}]},{"syntax":"swift","type":"codeListing","code":["extension PrettyTextRepresentable  {","    var prettyTextualDescription: String {","        return textualDescription","    }","}"]},{"anchor":"Adding-Constraints-to-Protocol-Extensions","type":"heading","level":3,"text":"Adding Constraints to Protocol Extensions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you define a protocol extension, you can specify constraints that conforming types must satisfy before the methods and properties of the extension are available. You write these constraints after the name of the protocol you’re extending by writing a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause. For more about generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clauses, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Generic-Where-Clauses","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"For example, you can define an extension to the ","type":"text"},{"code":"Collection","type":"codeVoice"},{"text":" protocol that applies to any collection whose elements conform to the ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" protocol. By constraining a collection’s elements to the ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" protocol, a part of the standard library, you can use the ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"!=","type":"codeVoice"},{"text":" operators to check for equality and inequality between two elements.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["extension Collection where Element: Equatable {","    func allEqual() -> Bool {","        for element in self {","            if element != self.first {","                return false","            }","        }","        return true","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"allEqual()"},{"type":"text","text":" method returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":" only if all the elements in the collection are equal."}]},{"type":"paragraph","inlineContent":[{"text":"Consider two arrays of integers, one where all the elements are the same, and one where they aren’t:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let equalNumbers = [100, 100, 100, 100, 100]","let differentNumbers = [100, 100, 200, 100, 200]"]},{"type":"paragraph","inlineContent":[{"text":"Because arrays conform to ","type":"text"},{"type":"codeVoice","code":"Collection"},{"text":" and integers conform to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":", ","type":"text"},{"type":"codeVoice","code":"equalNumbers"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"differentNumbers"},{"text":" can use the ","type":"text"},{"type":"codeVoice","code":"allEqual()"},{"text":" method:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["print(equalNumbers.allEqual())","\/\/ Prints \"true\"","print(differentNumbers.allEqual())","\/\/ Prints \"false\""]},{"style":"note","name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a conforming type satisfies the requirements for multiple constrained extensions that provide implementations for the same method or property, Swift uses the implementation corresponding to the most specialized constraints."}]}]}],"kind":"content"}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"generated":true,"title":"Language Guide"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"kind":"article","hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/protocols"]}],"references":{"doc://com.apple.Swift/documentation/Swift/Closures":{"role":"article","type":"topic","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures"},"doc://com.apple.Swift/documentation/Swift/Generics":{"role":"article","type":"topic","title":"Generics","kind":"article","abstract":[{"inlineContent":[{"type":"text","text":"Generic code"}],"type":"emphasis"},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","url":"\/documentation\/swift\/generics"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","title":"Collection Types","abstract":[{"text":"Swift provides three primary ","type":"text"},{"inlineContent":[{"text":"collection types","type":"text"}],"type":"emphasis"},{"text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/collectiontypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes"},"doc://com.apple.Swift/documentation/Swift/Generics#Generic-Where-Clauses":{"type":"topic","title":"Generic Where Clauses","kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Generic-Where-Clauses","url":"\/documentation\/swift\/generics#Generic-Where-Clauses"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","abstract":[{"inlineContent":[{"text":"Structures","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.","type":"text"}],"title":"Structures and Classes","url":"\/documentation\/swift\/classesandstructures","role":"article"},"doc://com.apple.Swift/documentation/Swift/Protocols#Protocols-as-Types":{"kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Protocols-as-Types","title":"Protocols as Types","type":"topic","url":"\/documentation\/swift\/protocols#Protocols-as-Types"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types":{"kind":"section","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","abstract":[],"title":"Structures and Enumerations Are Value Types","url":"\/documentation\/swift\/classesandstructures#Structures-and-Enumerations-Are-Value-Types"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"title":"Swift","url":"\/documentation\/swift","role":"collection"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"abstract":[{"type":"text","text":"An "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"type":"codeVoice","code":"+"},{"text":") adds two numbers, as in ","type":"text"},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"type":"topic","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","url":"\/documentation\/swift\/basicoperators","kind":"article","title":"Basic Operators"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","role":"article","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","title":"Memory Safety","type":"topic","url":"\/documentation\/swift\/memorysafety"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"title":"Optional Chaining","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"title":"Error Handling","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","url":"\/documentation\/swift\/errorhandling"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"title":"Enumerations","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Inheritance#Preventing-Overrides":{"url":"\/documentation\/swift\/inheritance#Preventing-Overrides","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance#Preventing-Overrides","type":"topic","title":"Preventing Overrides","kind":"section","abstract":[]},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","title":"Subscripts","url":"\/documentation\/swift\/subscripts","role":"article","kind":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","role":"article","abstract":[{"inlineContent":[{"text":"Type casting","type":"text"}],"type":"emphasis"},{"text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.","type":"text"}],"title":"Type Casting","url":"\/documentation\/swift\/typecasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"url":"\/documentation\/swift\/automaticreferencecounting","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"Automatic Reference Counting","type":"text"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining#Linking-Multiple-Levels-of-Chaining":{"url":"\/documentation\/swift\/optionalchaining#Linking-Multiple-Levels-of-Chaining","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining#Linking-Multiple-Levels-of-Chaining","type":"topic","abstract":[],"title":"Linking Multiple Levels of Chaining","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword. Deinitializers are only available on class types.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances":{"url":"\/documentation\/swift\/automaticreferencecounting#Strong-Reference-Cycles-Between-Class-Instances","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Strong-Reference-Cycles-Between-Class-Instances","type":"topic","abstract":[],"title":"Strong Reference Cycles Between Class Instances","kind":"section"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"role":"article","type":"topic","title":"Nested Types","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"inlineContent":[{"text":"nested types","type":"text"}],"type":"emphasis"},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/nestedtypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes"},"doc://com.apple.Swift/documentation/Swift/Functions":{"role":"article","type":"topic","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"kind":"article","url":"\/documentation\/swift\/functions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"kind":"article","role":"article","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"text":"inherit","type":"text"}]},{"type":"text","text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":", and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"text":"superclass","type":"text"}]},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","type":"topic","url":"\/documentation\/swift\/inheritance"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures#Classes-Are-Reference-Types":{"url":"\/documentation\/swift\/classesandstructures#Classes-Are-Reference-Types","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Classes-Are-Reference-Types","type":"topic","title":"Classes Are Reference Types","kind":"section","abstract":[]},"doc://com.apple.Swift/documentation/Swift/TypeCasting#Downcasting":{"url":"\/documentation\/swift\/typecasting#Downcasting","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting#Downcasting","type":"topic","abstract":[],"title":"Downcasting","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Methods#Modifying-Value-Types-from-Within-Instance-Methods":{"url":"\/documentation\/swift\/methods#Modifying-Value-Types-from-Within-Instance-Methods","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods#Modifying-Value-Types-from-Within-Instance-Methods","type":"topic","abstract":[],"title":"Modifying Value Types from Within Instance Methods","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Initialization#Required-Initializers":{"type":"topic","title":"Required Initializers","abstract":[],"url":"\/documentation\/swift\/initialization#Required-Initializers","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Required-Initializers"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"url":"\/documentation\/swift\/initialization","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","type":"topic","title":"Initialization","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}]},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"url":"\/documentation\/swift\/opaquetypes","title":"Opaque Types","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","role":"article","url":"\/documentation\/swift\/advancedoperators","abstract":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.","type":"text"}],"title":"Advanced Operators","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"kind":"article","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","title":"Extensions","type":"topic","url":"\/documentation\/swift\/extensions"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","abstract":[{"inlineContent":[{"text":"Access control","type":"text"}],"type":"emphasis"},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/accesscontrol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},"doc://com.apple.Swift/documentation/Swift/Protocols#Class-Only-Protocols":{"type":"topic","title":"Class-Only Protocols","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Class-Only-Protocols","abstract":[],"kind":"section","url":"\/documentation\/swift\/protocols#Class-Only-Protocols"},"doc://com.apple.Swift/documentation/Swift/ControlFlow#Break":{"type":"topic","title":"Break","kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Break","url":"\/documentation\/swift\/controlflow#Break"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"role":"article","type":"topic","title":"Control Flow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"kind":"article","url":"\/documentation\/swift\/controlflow","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"title":"Strings and Characters","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" is a series of characters, such as "},{"code":"\"hello, world\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"albatross\"","type":"codeVoice"},{"text":". Swift strings are represented by the ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type. The contents of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values.","type":"text"}],"type":"topic","kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","role":"article","url":"\/documentation\/swift\/stringsandcharacters"},"doc://com.apple.Swift/documentation/Swift/Initialization#Failable-Initializers":{"title":"Failable Initializers","abstract":[],"kind":"section","type":"topic","url":"\/documentation\/swift\/initialization#Failable-Initializers","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Failable-Initializers"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"type":"topic","role":"article","kind":"article","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"inlineContent":[{"type":"text","text":"Asynchronous code"}],"type":"emphasis"},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"inlineContent":[{"type":"text","text":"Parallel code"}],"type":"emphasis"},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"title":"Concurrency","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","url":"\/documentation\/swift\/concurrency"}}}