{"sections":[],"kind":"article","schemaVersion":{"minor":3,"patch":0,"major":0},"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator"}]},{"type":"text","text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") adds two numbers, as in "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","interfaceLanguage":"swift"},"metadata":{"modules":[{"name":"Swift"}],"roleHeading":"Article","role":"article","title":"Basic Operators"},"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"title":"Language Guide"}],"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"inlineContent":[{"type":"text","text":"Swift supports the operators you may already know from languages like C, and improves several capabilities to eliminate common coding errors. The assignment operator ("},{"type":"codeVoice","code":"="},{"type":"text","text":") doesn’t return a value, to prevent it from being mistakenly used when the equal to operator ("},{"code":"==","type":"codeVoice"},{"text":") is intended. Arithmetic operators (","type":"text"},{"code":"+","type":"codeVoice"},{"text":", ","type":"text"},{"code":"-","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"*"},{"type":"text","text":", "},{"type":"codeVoice","code":"\/"},{"type":"text","text":", "},{"type":"codeVoice","code":"%"},{"type":"text","text":" and so forth) detect and disallow value overflow, to avoid unexpected results when working with numbers that become larger or smaller than the allowed value range of the type that stores them. You can opt in to value overflow behavior by using Swift’s overflow operators, as described in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Overflow-Operators","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift also provides range operators that aren’t found in C, such as "},{"type":"codeVoice","code":"a..<b"},{"text":" and ","type":"text"},{"code":"a...b","type":"codeVoice"},{"text":", as a shortcut for expressing a range of values.","type":"text"}]},{"inlineContent":[{"type":"text","text":"This chapter describes the common operators in Swift. "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"},{"type":"text","text":" covers Swift’s advanced operators, and describes how to define your own custom operators and implement the standard operators for your own custom types."}],"type":"paragraph"},{"text":"Terminology","anchor":"Terminology","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Operators are unary, binary, or ternary:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Unary"}]},{"type":"text","text":" operators operate on a single target (such as "},{"type":"codeVoice","code":"-a"},{"type":"text","text":"). Unary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"prefix"}]},{"type":"text","text":" operators appear immediately before their target (such as "},{"type":"codeVoice","code":"!b"},{"type":"text","text":"), and unary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"postfix"}]},{"type":"text","text":" operators appear immediately after their target (such as "},{"type":"codeVoice","code":"c!"},{"type":"text","text":")."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Binary"}],"type":"emphasis"},{"text":" operators operate on two targets (such as ","type":"text"},{"type":"codeVoice","code":"2 + 3"},{"text":") and are ","type":"text"},{"inlineContent":[{"text":"infix","type":"text"}],"type":"emphasis"},{"text":" because they appear in between their two targets.","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Ternary"}],"type":"emphasis"},{"type":"text","text":" operators operate on three targets. Like C, Swift has only one ternary operator, the ternary conditional operator ("},{"code":"a ? b : c","type":"codeVoice"},{"type":"text","text":")."}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"The values that operators affect are ","type":"text"},{"inlineContent":[{"text":"operands","type":"text"}],"type":"emphasis"},{"text":". In the expression ","type":"text"},{"type":"codeVoice","code":"1 + 2"},{"text":", the ","type":"text"},{"type":"codeVoice","code":"+"},{"text":" symbol is an infix operator and its two operands are the values ","type":"text"},{"type":"codeVoice","code":"1"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"2"},{"text":".","type":"text"}]},{"text":"Assignment Operator","anchor":"Assignment-Operator","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"assignment operator","type":"text"}],"type":"emphasis"},{"type":"text","text":" ("},{"code":"a = b","type":"codeVoice"},{"type":"text","text":") initializes or updates the value of "},{"code":"a","type":"codeVoice"},{"type":"text","text":" with the value of "},{"code":"b","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let b = 10","var a = 5","a = b","\/\/ a is now equal to 10"]},{"inlineContent":[{"type":"text","text":"If the right side of the assignment is a tuple with multiple values, its elements can be decomposed into multiple constants or variables at once:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let (x, y) = (1, 2)","\/\/ x is equal to 1, and y is equal to 2"]},{"inlineContent":[{"text":"Unlike the assignment operator in C and Objective-C, the assignment operator in Swift doesn’t itself return a value. The following statement isn’t valid:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if x = y {","    \/\/ This isn't valid, because x = y doesn't return a value.","}"]},{"inlineContent":[{"text":"This feature prevents the assignment operator (","type":"text"},{"code":"=","type":"codeVoice"},{"text":") from being used by accident when the equal to operator (","type":"text"},{"code":"==","type":"codeVoice"},{"text":") is actually intended. By making ","type":"text"},{"code":"if x = y","type":"codeVoice"},{"text":" invalid, Swift helps you to avoid these kinds of errors in your code.","type":"text"}],"type":"paragraph"},{"text":"Arithmetic Operators","level":2,"anchor":"Arithmetic-Operators","type":"heading"},{"inlineContent":[{"text":"Swift supports the four standard ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"arithmetic operators","type":"text"}]},{"text":" for all number types:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Addition (","type":"text"},{"code":"+","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Subtraction (","type":"text"},{"type":"codeVoice","code":"-"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Multiplication ("},{"type":"codeVoice","code":"*"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Division ("},{"type":"codeVoice","code":"\/"},{"type":"text","text":")"}]}]}],"type":"unorderedList"},{"syntax":"swift","code":["1 + 2       \/\/ equals 3","5 - 3       \/\/ equals 2","2 * 3       \/\/ equals 6","10.0 \/ 2.5  \/\/ equals 4.0"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators don’t allow values to overflow by default. You can opt in to value overflow behavior by using Swift’s overflow operators (such as ","type":"text"},{"code":"a &+ b","type":"codeVoice"},{"text":"). See ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Overflow-Operators","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The addition operator is also supported for ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" concatenation:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\"hello, \" + \"world\"  \/\/ equals \"hello, world\""]},{"type":"heading","text":"Remainder Operator","anchor":"Remainder-Operator","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"remainder operator"}],"type":"emphasis"},{"type":"text","text":" ("},{"code":"a % b","type":"codeVoice"},{"type":"text","text":") works out how many multiples of "},{"code":"b","type":"codeVoice"},{"type":"text","text":" will fit inside "},{"code":"a","type":"codeVoice"},{"type":"text","text":" and returns the value that’s left over (known as the "},{"inlineContent":[{"type":"text","text":"remainder"}],"type":"emphasis"},{"type":"text","text":")."}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"The remainder operator ("},{"type":"codeVoice","code":"%"},{"type":"text","text":") is also known as a "},{"type":"emphasis","inlineContent":[{"text":"modulo operator","type":"text"}]},{"type":"text","text":" in other languages. However, its behavior in Swift for negative numbers means that, strictly speaking, it’s a remainder rather than a modulo operation."}],"type":"paragraph"}],"name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the remainder operator works. To calculate "},{"type":"codeVoice","code":"9 % 4"},{"type":"text","text":", you first work out how many "},{"type":"codeVoice","code":"4"},{"type":"text","text":"s will fit inside "},{"type":"codeVoice","code":"9"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"identifier":"remainderInteger","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can fit two "},{"code":"4","type":"codeVoice"},{"type":"text","text":"s inside "},{"code":"9","type":"codeVoice"},{"type":"text","text":", and the remainder is "},{"code":"1","type":"codeVoice"},{"type":"text","text":" (shown in orange)."}]},{"type":"paragraph","inlineContent":[{"text":"In Swift, this would be written as:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["9 % 4    \/\/ equals 1"]},{"type":"paragraph","inlineContent":[{"text":"To determine the answer for ","type":"text"},{"code":"a % b","type":"codeVoice"},{"text":", the ","type":"text"},{"code":"%","type":"codeVoice"},{"text":" operator calculates the following equation and returns ","type":"text"},{"code":"remainder","type":"codeVoice"},{"text":" as its output:","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"a","type":"codeVoice"},{"type":"text","text":" = ("},{"code":"b","type":"codeVoice"},{"type":"text","text":" x "},{"code":"some multiplier","type":"codeVoice"},{"type":"text","text":") + "},{"code":"remainder","type":"codeVoice"}]},{"type":"paragraph","inlineContent":[{"text":"where ","type":"text"},{"type":"codeVoice","code":"some multiplier"},{"text":" is the largest number of multiples of ","type":"text"},{"type":"codeVoice","code":"b"},{"text":" that will fit inside ","type":"text"},{"type":"codeVoice","code":"a"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Inserting "},{"code":"9","type":"codeVoice"},{"type":"text","text":" and "},{"code":"4","type":"codeVoice"},{"type":"text","text":" into this equation yields:"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"9"},{"text":" = (","type":"text"},{"type":"codeVoice","code":"4"},{"text":" x ","type":"text"},{"type":"codeVoice","code":"2"},{"text":") + ","type":"text"},{"type":"codeVoice","code":"1"}]},{"type":"paragraph","inlineContent":[{"text":"The same method is applied when calculating the remainder for a negative value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["-9 % 4   \/\/ equals -1"]},{"type":"paragraph","inlineContent":[{"text":"Inserting ","type":"text"},{"type":"codeVoice","code":"-9"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"4"},{"text":" into the equation yields:","type":"text"}]},{"type":"paragraph","inlineContent":[{"code":"-9","type":"codeVoice"},{"text":" = (","type":"text"},{"code":"4","type":"codeVoice"},{"text":" x ","type":"text"},{"code":"-2","type":"codeVoice"},{"text":") + ","type":"text"},{"code":"-1","type":"codeVoice"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"giving a remainder value of "},{"type":"codeVoice","code":"-1"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"The sign of ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" is ignored for negative values of ","type":"text"},{"code":"b","type":"codeVoice"},{"text":". This means that ","type":"text"},{"code":"a % b","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"a % -b","type":"codeVoice"},{"text":" always give the same answer.","type":"text"}]},{"type":"heading","text":"Unary Minus Operator","anchor":"Unary-Minus-Operator","level":3},{"type":"paragraph","inlineContent":[{"text":"The sign of a numeric value can be toggled using a prefixed ","type":"text"},{"code":"-","type":"codeVoice"},{"text":", known as the ","type":"text"},{"inlineContent":[{"type":"text","text":"unary minus operator"}],"type":"emphasis"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let three = 3","let minusThree = -three       \/\/ minusThree equals -3","let plusThree = -minusThree   \/\/ plusThree equals 3, or \"minus minus three\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The unary minus operator ("},{"code":"-","type":"codeVoice"},{"type":"text","text":") is prepended directly before the value it operates on, without any white space."}]},{"type":"heading","text":"Unary Plus Operator","anchor":"Unary-Plus-Operator","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"unary plus operator"}]},{"type":"text","text":" ("},{"code":"+","type":"codeVoice"},{"type":"text","text":") simply returns the value it operates on, without any change:"}]},{"type":"codeListing","syntax":"swift","code":["let minusSix = -6","let alsoMinusSix = +minusSix  \/\/ alsoMinusSix equals -6"]},{"type":"paragraph","inlineContent":[{"text":"Although the unary plus operator doesn’t actually do anything, you can use it to provide symmetry in your code for positive numbers when also using the unary minus operator for negative numbers.","type":"text"}]},{"type":"heading","text":"Compound Assignment Operators","anchor":"Compound-Assignment-Operators","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Like C, Swift provides "},{"type":"emphasis","inlineContent":[{"type":"text","text":"compound assignment operators"}]},{"type":"text","text":" that combine assignment ("},{"type":"codeVoice","code":"="},{"text":") with another operation. One example is the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"addition assignment operator","type":"text"}]},{"text":" (","type":"text"},{"type":"codeVoice","code":"+="},{"text":"):","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var a = 1","a += 2","\/\/ a is now equal to 3"]},{"type":"paragraph","inlineContent":[{"text":"The expression ","type":"text"},{"type":"codeVoice","code":"a += 2"},{"text":" is shorthand for ","type":"text"},{"type":"codeVoice","code":"a = a + 2"},{"text":". Effectively, the addition and the assignment are combined into one operator that performs both tasks at the same time.","type":"text"}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"The compound assignment operators don’t return a value. For example, you can’t write ","type":"text"},{"code":"let b = a += 2","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}],"name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library, see "},{"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","isActive":true},{"type":"text","text":" [https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations]"},{"type":"text","text":"."}]},{"type":"heading","text":"Comparison Operators","anchor":"Comparison-Operators","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift supports the following comparison operators:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Equal to (","type":"text"},{"code":"a == b","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Not equal to (","type":"text"},{"type":"codeVoice","code":"a != b"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Greater than (","type":"text"},{"type":"codeVoice","code":"a > b"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Less than ("},{"type":"codeVoice","code":"a < b"},{"type":"text","text":")"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Greater than or equal to ("},{"type":"codeVoice","code":"a >= b"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Less than or equal to ("},{"code":"a <= b","type":"codeVoice"},{"type":"text","text":")"}]}]}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"Swift also provides two "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identity operators"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"==="},{"type":"text","text":" and "},{"type":"codeVoice","code":"!=="},{"type":"text","text":"), which you use to test whether two object references both refer to the same object instance. For more information, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Identity-Operators"},{"type":"text","text":"."}],"type":"paragraph"}],"name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each of the comparison operators returns a "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value to indicate whether or not the statement is true:"}]},{"type":"codeListing","syntax":"swift","code":["1 == 1   \/\/ true because 1 is equal to 1","2 != 1   \/\/ true because 2 isn't equal to 1","2 > 1    \/\/ true because 2 is greater than 1","1 < 2    \/\/ true because 1 is less than 2","1 >= 1   \/\/ true because 1 is greater than or equal to 1","2 <= 1   \/\/ false because 2 isn't less than or equal to 1"]},{"type":"paragraph","inlineContent":[{"text":"Comparison operators are often used in conditional statements, such as the ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" statement:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let name = \"world\"","if name == \"world\" {","    print(\"hello, world\")","} else {","    print(\"I'm sorry \\(name), but I don't recognize you\")","}","\/\/ Prints \"hello, world\", because name is indeed equal to \"world\"."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more about the "},{"code":"if","type":"codeVoice"},{"type":"text","text":" statement, see "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can compare two tuples if they have the same type and the same number of values. Tuples are compared from left to right, one value at a time, until the comparison finds two values that aren’t equal. Those two values are compared, and the result of that comparison determines the overall result of the tuple comparison. If all the elements are equal, then the tuples themselves are equal. For example:"}]},{"type":"codeListing","syntax":"swift","code":["(1, \"zebra\") < (2, \"apple\")   \/\/ true because 1 is less than 2; \"zebra\" and \"apple\" aren't compared","(3, \"apple\") < (3, \"bird\")    \/\/ true because 3 is equal to 3, and \"apple\" is less than \"bird\"","(4, \"dog\") == (4, \"dog\")      \/\/ true because 4 is equal to 4, and \"dog\" is equal to \"dog\""]},{"type":"paragraph","inlineContent":[{"text":"In the example above, you can see the left-to-right comparison behavior on the first line. Because ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" is less than ","type":"text"},{"code":"2","type":"codeVoice"},{"text":", ","type":"text"},{"code":"(1, \"zebra\")","type":"codeVoice"},{"text":" is considered less than ","type":"text"},{"code":"(2, \"apple\")","type":"codeVoice"},{"text":", regardless of any other values in the tuples. It doesn’t matter that ","type":"text"},{"code":"\"zebra\"","type":"codeVoice"},{"text":" isn’t less than ","type":"text"},{"code":"\"apple\"","type":"codeVoice"},{"text":", because the comparison is already determined by the tuples’ first elements. However, when the tuples’ first elements are the same, their second elements ","type":"text"},{"inlineContent":[{"text":"are","type":"text"}],"type":"emphasis"},{"text":" compared—this is what happens on the second and third line.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Tuples can be compared with a given operator only if the operator can be applied to each value in the respective tuples. For example, as demonstrated in the code below, you can compare two tuples of type "},{"code":"(String, Int)","type":"codeVoice"},{"type":"text","text":" because both "},{"code":"String","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values can be compared using the "},{"code":"<","type":"codeVoice"},{"type":"text","text":" operator. In contrast, two tuples of type "},{"code":"(String, Bool)","type":"codeVoice"},{"type":"text","text":" can’t be compared with the "},{"code":"<","type":"codeVoice"},{"type":"text","text":" operator because the "},{"code":"<","type":"codeVoice"},{"type":"text","text":" operator can’t be applied to "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" values."}]},{"type":"codeListing","syntax":"swift","code":["(\"blue\", -1) < (\"purple\", 1)        \/\/ OK, evaluates to true","(\"blue\", false) < (\"purple\", true)  \/\/ Error because < can't compare Boolean values"]},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"The Swift standard library includes tuple comparison operators for tuples with fewer than seven elements. To compare tuples with seven or more elements, you must implement the comparison operators yourself.","type":"text"}],"type":"paragraph"}],"name":"Note"},{"type":"heading","text":"Ternary Conditional Operator","anchor":"Ternary-Conditional-Operator","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"ternary conditional operator"}]},{"type":"text","text":" is a special operator with three parts, which takes the form "},{"type":"codeVoice","code":"question ? answer1 : answer2"},{"type":"text","text":". It’s a shortcut for evaluating one of two expressions based on whether "},{"type":"codeVoice","code":"question"},{"type":"text","text":" is true or false. If "},{"type":"codeVoice","code":"question"},{"type":"text","text":" is true, it evaluates "},{"type":"codeVoice","code":"answer1"},{"type":"text","text":" and returns its value; otherwise, it evaluates "},{"type":"codeVoice","code":"answer2"},{"type":"text","text":" and returns its value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The ternary conditional operator is shorthand for the code below:"}]},{"type":"codeListing","syntax":"swift","code":["if question {","    answer1","} else {","    answer2","}"]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example, which calculates the height for a table row. The row height should be 50 points taller than the content height if the row has a header, and 20 points taller if the row doesn’t have a header:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let contentHeight = 40","let hasHeader = true","let rowHeight = contentHeight + (hasHeader ? 50 : 20)","\/\/ rowHeight is equal to 90"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above is shorthand for the code below:"}]},{"type":"codeListing","syntax":"swift","code":["let contentHeight = 40","let hasHeader = true","let rowHeight: Int","if hasHeader {","    rowHeight = contentHeight + 50","} else {","    rowHeight = contentHeight + 20","}","\/\/ rowHeight is equal to 90"]},{"type":"paragraph","inlineContent":[{"text":"The first example’s use of the ternary conditional operator means that ","type":"text"},{"code":"rowHeight","type":"codeVoice"},{"text":" can be set to the correct value on a single line of code, which is more concise than the code used in the second example.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The ternary conditional operator provides an efficient shorthand for deciding which of two expressions to consider. Use the ternary conditional operator with care, however. Its conciseness can lead to hard-to-read code if overused. Avoid combining multiple instances of the ternary conditional operator into one compound statement."}]},{"type":"heading","text":"Nil-Coalescing Operator","anchor":"Nil-Coalescing-Operator","level":2},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nil-coalescing operator","type":"text"}]},{"text":" (","type":"text"},{"code":"a ?? b","type":"codeVoice"},{"text":") unwraps an optional ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" if it contains a value, or returns a default value ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" if ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". The expression ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" is always of an optional type. The expression ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" must match the type that’s stored inside ","type":"text"},{"code":"a","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The nil-coalescing operator is shorthand for the code below:"}]},{"type":"codeListing","syntax":"swift","code":["a != nil ? a! : b"]},{"type":"paragraph","inlineContent":[{"text":"The code above uses the ternary conditional operator and forced unwrapping (","type":"text"},{"code":"a!","type":"codeVoice"},{"text":") to access the value wrapped inside ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" when ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" isn’t ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", and to return ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" otherwise. The nil-coalescing operator provides a more elegant way to encapsulate this conditional checking and unwrapping in a concise and readable form.","type":"text"}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" is non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the value of "},{"type":"codeVoice","code":"b"},{"type":"text","text":" isn’t evaluated. This is known as "},{"type":"emphasis","inlineContent":[{"text":"short-circuit evaluation","type":"text"}]},{"type":"text","text":"."}]}],"name":"Note"},{"type":"paragraph","inlineContent":[{"text":"The example below uses the nil-coalescing operator to choose between a default color name and an optional user-defined color name:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let defaultColorName = \"red\"","var userDefinedColorName: String?   \/\/ defaults to nil","","var colorNameToUse = userDefinedColorName ?? defaultColorName","\/\/ userDefinedColorName is nil, so colorNameToUse is set to the default of \"red\""]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"userDefinedColorName","type":"codeVoice"},{"text":" variable is defined as an optional ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", with a default value of ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". Because ","type":"text"},{"code":"userDefinedColorName","type":"codeVoice"},{"text":" is of an optional type, you can use the nil-coalescing operator to consider its value. In the example above, the operator is used to determine an initial value for a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" variable called ","type":"text"},{"code":"colorNameToUse","type":"codeVoice"},{"text":". Because ","type":"text"},{"code":"userDefinedColorName","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", the expression ","type":"text"},{"code":"userDefinedColorName ?? defaultColorName","type":"codeVoice"},{"text":" returns the value of ","type":"text"},{"code":"defaultColorName","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"\"red\"","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If you assign a non-","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" value to ","type":"text"},{"code":"userDefinedColorName","type":"codeVoice"},{"text":" and perform the nil-coalescing operator check again, the value wrapped inside ","type":"text"},{"code":"userDefinedColorName","type":"codeVoice"},{"text":" is used instead of the default:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["userDefinedColorName = \"green\"","colorNameToUse = userDefinedColorName ?? defaultColorName","\/\/ userDefinedColorName isn't nil, so colorNameToUse is set to \"green\""]},{"type":"heading","text":"Range Operators","anchor":"Range-Operators","level":2},{"type":"paragraph","inlineContent":[{"text":"Swift includes several ","type":"text"},{"inlineContent":[{"text":"range operators","type":"text"}],"type":"emphasis"},{"text":", which are shortcuts for expressing a range of values.","type":"text"}]},{"type":"heading","text":"Closed Range Operator","anchor":"Closed-Range-Operator","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"closed range operator"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"a...b"},{"type":"text","text":") defines a range that runs from "},{"type":"codeVoice","code":"a"},{"type":"text","text":" to "},{"type":"codeVoice","code":"b"},{"type":"text","text":", and includes the values "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":". The value of "},{"type":"codeVoice","code":"a"},{"type":"text","text":" must not be greater than "},{"type":"codeVoice","code":"b"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The closed range operator is useful when iterating over a range in which you want all of the values to be used, such as with a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" loop:"}]},{"type":"codeListing","syntax":"swift","code":["for index in 1...5 {","    print(\"\\(index) times 5 is \\(index * 5)\")","}","\/\/ 1 times 5 is 5","\/\/ 2 times 5 is 10","\/\/ 3 times 5 is 15","\/\/ 4 times 5 is 20","\/\/ 5 times 5 is 25"]},{"type":"paragraph","inlineContent":[{"text":"For more about ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" loops, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","type":"reference","isActive":true},{"text":".","type":"text"}]},{"type":"heading","text":"Half-Open Range Operator","anchor":"Half-Open-Range-Operator","level":3},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"text":"half-open range operator","type":"text"}],"type":"emphasis"},{"text":" (","type":"text"},{"code":"a..<b","type":"codeVoice"},{"text":") defines a range that runs from ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"b","type":"codeVoice"},{"text":", but doesn’t include ","type":"text"},{"code":"b","type":"codeVoice"},{"text":". It’s said to be ","type":"text"},{"inlineContent":[{"type":"text","text":"half-open"}],"type":"emphasis"},{"text":" because it contains its first value, but not its final value. As with the closed range operator, the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" must not be greater than ","type":"text"},{"code":"b","type":"codeVoice"},{"text":". If the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" is equal to ","type":"text"},{"code":"b","type":"codeVoice"},{"text":", then the resulting range will be empty.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Half-open ranges are particularly useful when you work with zero-based lists such as arrays, where it’s useful to count up to (but not including) the length of the list:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]","let count = names.count","for i in 0..<count {","    print(\"Person \\(i + 1) is called \\(names[i])\")","}","\/\/ Person 1 is called Anna","\/\/ Person 2 is called Alex","\/\/ Person 3 is called Brian","\/\/ Person 4 is called Jack"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the array contains four items, but "},{"type":"codeVoice","code":"0..<count"},{"type":"text","text":" only counts as far as "},{"type":"codeVoice","code":"3"},{"type":"text","text":" (the index of the last item in the array), because it’s a half-open range. For more about arrays, see "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes#Arrays","type":"reference","isActive":true},{"type":"text","text":"."}]},{"type":"heading","text":"One-Sided Ranges","anchor":"One-Sided-Ranges","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"The closed range operator has an alternative form for ranges that continue as far as possible in one direction—for example, a range that includes all the elements of an array from index 2 to the end of the array. In these cases, you can omit the value from one side of the range operator. This kind of range is called a "},{"type":"emphasis","inlineContent":[{"text":"one-sided range","type":"text"}]},{"type":"text","text":" because the operator has a value on only one side. For example:"}]},{"type":"codeListing","syntax":"swift","code":["for name in names[2...] {","    print(name)","}","\/\/ Brian","\/\/ Jack","","for name in names[...2] {","    print(name)","}","\/\/ Anna","\/\/ Alex","\/\/ Brian"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The half-open range operator also has a one-sided form that’s written with only its final value. Just like when you include a value on both sides, the final value isn’t part of the range. For example:"}]},{"type":"codeListing","syntax":"swift","code":["for name in names[..<2] {","    print(name)","}","\/\/ Anna","\/\/ Alex"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One-sided ranges can be used in other contexts, not just in subscripts. You can’t iterate over a one-sided range that omits a first value, because it isn’t clear where iteration should begin. You "},{"type":"emphasis","inlineContent":[{"type":"text","text":"can"}]},{"type":"text","text":" iterate over a one-sided range that omits its final value; however, because the range continues indefinitely, make sure you add an explicit end condition for the loop. You can also check whether a one-sided range contains a particular value, as shown in the code below."}]},{"type":"codeListing","syntax":"swift","code":["let range = ...5","range.contains(7)   \/\/ false","range.contains(4)   \/\/ true","range.contains(-1)  \/\/ true"]},{"type":"heading","text":"Logical Operators","anchor":"Logical-Operators","level":2},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Logical operators","type":"text"}],"type":"emphasis"},{"type":"text","text":" modify or combine the Boolean logic values "},{"code":"true","type":"codeVoice"},{"type":"text","text":" and "},{"code":"false","type":"codeVoice"},{"type":"text","text":". Swift supports the three standard logical operators found in C-based languages:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Logical NOT (","type":"text"},{"code":"!a","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Logical AND ("},{"type":"codeVoice","code":"a && b"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Logical OR ("},{"type":"codeVoice","code":"a || b"},{"type":"text","text":")"}]}]}]},{"type":"heading","text":"Logical NOT Operator","anchor":"Logical-NOT-Operator","level":3},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"text":"logical NOT operator","type":"text"}],"type":"emphasis"},{"text":" (","type":"text"},{"code":"!a","type":"codeVoice"},{"text":") inverts a Boolean value so that ","type":"text"},{"type":"codeVoice","code":"true"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"false"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"false"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"true"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The logical NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space. It can be read as “not "},{"code":"a","type":"codeVoice"},{"type":"text","text":"”, as seen in the following example:"}]},{"type":"codeListing","syntax":"swift","code":["let allowedEntry = false","if !allowedEntry {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"ACCESS DENIED\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The phrase "},{"type":"codeVoice","code":"if !allowedEntry"},{"type":"text","text":" can be read as “if not allowed entry.” The subsequent line is only executed if “not allowed entry” is true; that is, if "},{"type":"codeVoice","code":"allowedEntry"},{"type":"text","text":" is "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"As in this example, careful choice of Boolean constant and variable names can help to keep code readable and concise, while avoiding double negatives or confusing logic statements.","type":"text"}]},{"type":"heading","text":"Logical AND Operator","anchor":"Logical-AND-Operator","level":3},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"text":"logical AND operator","type":"text"}],"type":"emphasis"},{"text":" (","type":"text"},{"type":"codeVoice","code":"a && b"},{"text":") creates logical expressions where both values must be ","type":"text"},{"type":"codeVoice","code":"true"},{"text":" for the overall expression to also be ","type":"text"},{"type":"codeVoice","code":"true"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If either value is ","type":"text"},{"code":"false","type":"codeVoice"},{"text":", the overall expression will also be ","type":"text"},{"code":"false","type":"codeVoice"},{"text":". In fact, if the ","type":"text"},{"inlineContent":[{"type":"text","text":"first"}],"type":"emphasis"},{"text":" value is ","type":"text"},{"code":"false","type":"codeVoice"},{"text":", the second value won’t even be evaluated, because it can’t possibly make the overall expression equate to ","type":"text"},{"code":"true","type":"codeVoice"},{"text":". This is known as ","type":"text"},{"inlineContent":[{"type":"text","text":"short-circuit evaluation"}],"type":"emphasis"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This example considers two ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" values and only allows access if both values are ","type":"text"},{"code":"true","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let enteredDoorCode = true","let passedRetinaScan = false","if enteredDoorCode && passedRetinaScan {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"ACCESS DENIED\""]},{"type":"heading","text":"Logical OR Operator","anchor":"Logical-OR-Operator","level":3},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"logical OR operator"}],"type":"emphasis"},{"text":" (","type":"text"},{"code":"a || b","type":"codeVoice"},{"text":") is an infix operator made from two adjacent pipe characters. You use it to create logical expressions in which only ","type":"text"},{"inlineContent":[{"text":"one","type":"text"}],"type":"emphasis"},{"text":" of the two values has to be ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" for the overall expression to be ","type":"text"},{"code":"true","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Like the Logical AND operator above, the Logical OR operator uses short-circuit evaluation to consider its expressions. If the left side of a Logical OR expression is ","type":"text"},{"type":"codeVoice","code":"true"},{"text":", the right side isn’t evaluated, because it can’t change the outcome of the overall expression.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example below, the first "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" value ("},{"code":"hasDoorKey","type":"codeVoice"},{"type":"text","text":") is "},{"code":"false","type":"codeVoice"},{"type":"text","text":", but the second value ("},{"code":"knowsOverridePassword","type":"codeVoice"},{"type":"text","text":") is "},{"code":"true","type":"codeVoice"},{"type":"text","text":". Because one value is "},{"code":"true","type":"codeVoice"},{"type":"text","text":", the overall expression also evaluates to "},{"code":"true","type":"codeVoice"},{"type":"text","text":", and access is allowed:"}]},{"type":"codeListing","syntax":"swift","code":["let hasDoorKey = false","let knowsOverridePassword = true","if hasDoorKey || knowsOverridePassword {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"Welcome!\""]},{"type":"heading","text":"Combining Logical Operators","anchor":"Combining-Logical-Operators","level":3},{"type":"paragraph","inlineContent":[{"text":"You can combine multiple logical operators to create longer compound expressions:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if enteredDoorCode && passedRetinaScan || hasDoorKey || knowsOverridePassword {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"Welcome!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example uses multiple "},{"type":"codeVoice","code":"&&"},{"type":"text","text":" and "},{"type":"codeVoice","code":"||"},{"type":"text","text":" operators to create a longer compound expression. However, the "},{"type":"codeVoice","code":"&&"},{"type":"text","text":" and "},{"type":"codeVoice","code":"||"},{"type":"text","text":" operators still operate on only two values, so this is actually three smaller expressions chained together. The example can be read as:"}]},{"type":"paragraph","inlineContent":[{"text":"If we’ve entered the correct door code and passed the retina scan, or if we have a valid door key, or if we know the emergency override password, then allow access.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Based on the values of ","type":"text"},{"code":"enteredDoorCode","type":"codeVoice"},{"text":", ","type":"text"},{"code":"passedRetinaScan","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"hasDoorKey","type":"codeVoice"},{"text":", the first two subexpressions are ","type":"text"},{"code":"false","type":"codeVoice"},{"text":". However, the emergency override password is known, so the overall compound expression still evaluates to ","type":"text"},{"code":"true","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"The Swift logical operators ","type":"text"},{"code":"&&","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"||","type":"codeVoice"},{"text":" are left-associative, meaning that compound expressions with multiple logical operators evaluate the leftmost subexpression first.","type":"text"}],"type":"paragraph"}],"name":"Note"},{"type":"heading","text":"Explicit Parentheses","anchor":"Explicit-Parentheses","level":3},{"type":"paragraph","inlineContent":[{"text":"It’s sometimes useful to include parentheses when they’re not strictly needed, to make the intention of a complex expression easier to read. In the door access example above, it’s useful to add parentheses around the first part of the compound expression to make its intent explicit:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if (enteredDoorCode && passedRetinaScan) || hasDoorKey || knowsOverridePassword {","    print(\"Welcome!\")","} else {","    print(\"ACCESS DENIED\")","}","\/\/ Prints \"Welcome!\""]},{"type":"paragraph","inlineContent":[{"text":"The parentheses make it clear that the first two values are considered as part of a separate possible state in the overall logic. The output of the compound expression doesn’t change, but the overall intention is clearer to the reader. Readability is always preferred over brevity; use parentheses where they help to make your intentions clear.","type":"text"}]}],"kind":"content"}],"variants":[{"paths":["\/documentation\/swift\/basicoperators"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"url":"\/documentation\/swift\/stringsandcharacters","role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","kind":"article","url":"\/documentation\/swift\/extensions","title":"Extensions"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes#Arrays":{"url":"\/documentation\/swift\/collectiontypes#Arrays","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes#Arrays","title":"Arrays","abstract":[],"kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","url":"\/documentation\/swift\/concurrency","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"type":"text","text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Generics":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"url":"\/documentation\/swift\/generics","role":"article","title":"Generics","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"text":"inherit","type":"text"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"text":"subclass","type":"text"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/inheritance","title":"Inheritance","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"title":"Initialization","url":"\/documentation\/swift\/initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"url":"\/documentation\/swift\/collectiontypes","role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Closures":{"url":"\/documentation\/swift\/closures","role":"article","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"url":"\/documentation\/swift\/advancedoperators","role":"article","title":"Advanced Operators","abstract":[{"type":"text","text":"In addition to the operators described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"title":"Automatic Reference Counting","url":"\/documentation\/swift\/automaticreferencecounting","abstract":[{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators#Overflow-Operators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Overflow-Operators","type":"topic","abstract":[],"kind":"section","url":"\/documentation\/swift\/advancedoperators#Overflow-Operators","title":"Overflow Operators"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"title":"Nested Types","url":"\/documentation\/swift\/nestedtypes","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nested types","type":"text"}]},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"text":"conform","type":"text"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","url":"\/documentation\/swift\/protocols","title":"Protocols"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"role":"article","abstract":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","kind":"article","url":"\/documentation\/swift\/enumerations","title":"Enumerations"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"text":" is called immediately before a class instance is deallocated. You write deinitializers with the ","type":"text"},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","kind":"article","url":"\/documentation\/swift\/deinitialization","title":"Deinitialization"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","abstract":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") adds two numbers, as in ","type":"text"},{"code":"let i = 1 + 2","type":"codeVoice"},{"text":", and the logical AND operator (","type":"text"},{"code":"&&","type":"codeVoice"},{"text":") combines two Boolean values, as in ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"text":".","type":"text"}],"kind":"article","url":"\/documentation\/swift\/basicoperators","title":"Basic Operators","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","url":"\/documentation\/swift\/functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/swift\/optionalchaining","role":"article","title":"Optional Chaining","abstract":[{"inlineContent":[{"text":"Optional chaining","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", the property, method, or subscript call returns "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"title":"Subscripts","url":"\/documentation\/swift\/subscripts","abstract":[{"text":"Classes, structures, and enumerations can define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instance as "},{"code":"someArray[index]","type":"codeVoice"},{"type":"text","text":" and elements in a "},{"code":"Dictionary","type":"codeVoice"},{"text":" instance as ","type":"text"},{"type":"codeVoice","code":"someDictionary[key]"},{"text":".","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","url":"\/documentation\/swift\/accesscontrol","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","role":"article","type":"topic"},"https://developer.apple.com/documentation/swift/operator_declarations":{"type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","titleInlineContent":[{"text":"Operator Declarations","type":"text"}],"title":"Operator Declarations"},"remainderInteger":{"identifier":"remainderInteger","alt":null,"variants":[{"url":"\/images\/remainderInteger@2x.png","traits":["2x","light"]}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures#Identity-Operators":{"url":"\/documentation\/swift\/classesandstructures#Identity-Operators","title":"Identity Operators","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Identity-Operators","abstract":[],"type":"topic"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"title":"Opaque Types","role":"article","kind":"article","url":"\/documentation\/swift\/opaquetypes","type":"topic","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"classes","type":"text"}]},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","kind":"article","url":"\/documentation\/swift\/classesandstructures","title":"Structures and Classes"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"url":"\/documentation\/swift\/typecasting","role":"article","title":"Type Casting","abstract":[{"inlineContent":[{"type":"text","text":"Type casting"}],"type":"emphasis"},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"title":"Memory Safety","url":"\/documentation\/swift\/memorysafety","abstract":[{"text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"url":"\/documentation\/swift\/errorhandling","role":"article","title":"Error Handling","abstract":[{"inlineContent":[{"type":"text","text":"Error handling"}],"type":"emphasis"},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","role":"article","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","type":"topic"}}}