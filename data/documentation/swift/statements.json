{"kind":"article","hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"sections":[],"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"paths":["\/documentation\/swift\/statements"],"traits":[{"interfaceLanguage":"swift"}]}],"seeAlsoSections":[{"generated":true,"title":"Language Reference","identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/AboutTheLanguageReference","doc:\/\/com.apple.Swift\/documentation\/Swift\/LexicalStructure","doc:\/\/com.apple.Swift\/documentation\/Swift\/Types","doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations","doc:\/\/com.apple.Swift\/documentation\/Swift\/Attributes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Patterns","doc:\/\/com.apple.Swift\/documentation\/Swift\/GenericParametersAndArguments","doc:\/\/com.apple.Swift\/documentation\/Swift\/zzSummaryOfTheGrammar"]}],"abstract":[{"type":"text","text":"In Swift, there are three kinds of statements: simple statements, compiler control statements, and control flow statements. Simple statements are the most common and consist of either an expression or a declaration. Compiler control statements allow the program to change aspects of the compiler’s behavior and include a conditional compilation block and a line control statement."}],"metadata":{"roleHeading":"Article","modules":[{"name":"Swift"}],"role":"article","title":"Statements"},"primaryContentSections":[{"content":[{"level":2,"text":"Overview","anchor":"overview","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Control flow statements are used to control the flow of execution in a program. There are several types of control flow statements in Swift, including loop statements, branch statements, and control transfer statements. Loop statements allow a block of code to be executed repeatedly, branch statements allow a certain block of code to be executed only when certain conditions are met, and control transfer statements provide a way to alter the order in which code is executed. In addition, Swift provides a "},{"type":"codeVoice","code":"do"},{"type":"text","text":" statement to introduce scope, and catch and handle errors, and a "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement for running cleanup actions just before the current scope exits."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A semicolon ("},{"type":"codeVoice","code":";"},{"type":"text","text":") can optionally appear after any statement and is used to separate multiple statements if they appear on the same line."}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of a statement"},{"type":"heading","level":2,"anchor":"Loop-Statements","text":"Loop Statements"},{"inlineContent":[{"text":"Loop statements allow a block of code to be executed repeatedly, depending on the conditions specified in the loop. Swift has three loop statements: a ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" statement, a ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" statement, and a ","type":"text"},{"code":"repeat","type":"codeVoice"},{"text":"-","type":"text"},{"code":"while","type":"codeVoice"},{"text":" statement.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Control flow in a loop statement can be changed by a ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" statement and a ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" statement and is discussed in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Break-Statement","isActive":true,"type":"reference"},{"text":" and ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Continue-Statement","isActive":true,"type":"reference"},{"text":" below.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Grammar of a loop statement","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}]},{"type":"heading","level":3,"anchor":"For-In-Statement","text":"For-In Statement"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" statement allows a block of code to be executed once for each item in a collection (or any type) that conforms to the "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence"},{"type":"text","text":" [https:\/\/developer.apple.com\/documentation\/swift\/sequence]"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" statement has the following form:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["for item in collection {","    statements","}"]},{"inlineContent":[{"text":"The ","type":"text"},{"code":"makeIterator()","type":"codeVoice"},{"text":" method is called on the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection"}]},{"text":" expression to obtain a value of an iterator type—that is, a type that conforms to the ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/iteratorprotocol"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/iteratorprotocol]","type":"text"},{"text":" protocol. The program begins executing a loop by calling the ","type":"text"},{"code":"next()","type":"codeVoice"},{"text":" method on the iterator. If the value returned isn’t ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", it’s assigned to the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"item"}]},{"text":" pattern, the program executes the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"statements","type":"text"}]},{"text":", and then continues execution at the beginning of the loop. Otherwise, the program doesn’t perform assignment or execute the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"statements","type":"text"}]},{"text":", and it’s finished executing the ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" statement.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Grammar of a for-in statement","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}]},{"type":"heading","level":3,"anchor":"While-Statement","text":"While Statement"},{"inlineContent":[{"type":"text","text":"A "},{"code":"while","type":"codeVoice"},{"type":"text","text":" statement allows a block of code to be executed repeatedly, as long as a condition remains true."}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"while"},{"text":" statement has the following form:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["while condition {","    statements","}"]},{"inlineContent":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"while"},{"text":" statement is executed as follows:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"condition"}],"type":"emphasis"},{"type":"text","text":" is evaluated."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"true"},{"type":"text","text":", execution continues to step 2. If "},{"type":"codeVoice","code":"false"},{"type":"text","text":", the program is finished executing the "},{"type":"codeVoice","code":"while"},{"type":"text","text":" statement."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The program executes the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"statements"}]},{"type":"text","text":", and execution returns to step 1."}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"Because the value of the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"condition"}]},{"type":"text","text":" is evaluated before the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"statements"}]},{"type":"text","text":" are executed, the "},{"type":"emphasis","inlineContent":[{"text":"statements","type":"text"}]},{"type":"text","text":" in a "},{"code":"while","type":"codeVoice"},{"type":"text","text":" statement can be executed zero or more times."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of the "},{"inlineContent":[{"text":"condition","type":"text"}],"type":"emphasis"},{"type":"text","text":" must be of type "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" or a type bridged to "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":". The condition can also be an optional binding declaration, as discussed in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Optional-Binding","type":"reference","isActive":true},{"type":"text","text":"."}]},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of a while statement"},{"type":"heading","text":"Repeat-While Statement","level":3,"anchor":"Repeat-While-Statement"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" statement allows a block of code to be executed one or more times, as long as a condition remains true."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"repeat"},{"type":"text","text":"-"},{"type":"codeVoice","code":"while"},{"type":"text","text":" statement has the following form:"}]},{"syntax":"swift","code":["repeat {","    statements","} while condition"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"code":"repeat","type":"codeVoice"},{"type":"text","text":"-"},{"code":"while","type":"codeVoice"},{"type":"text","text":" statement is executed as follows:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"The program executes the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"statements"}]},{"type":"text","text":", and execution continues to step 2."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"condition","type":"text"}]},{"text":" is evaluated.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If ","type":"text"},{"type":"codeVoice","code":"true"},{"text":", execution returns to step 1. If ","type":"text"},{"type":"codeVoice","code":"false"},{"text":", the program is finished executing the ","type":"text"},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"type":"text","text":" statement."}]}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"Because the value of the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"condition","type":"text"}]},{"text":" is evaluated after the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"statements"}]},{"text":" are executed, the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"statements","type":"text"}]},{"text":" in a ","type":"text"},{"type":"codeVoice","code":"repeat"},{"text":"-","type":"text"},{"type":"codeVoice","code":"while"},{"text":" statement are executed at least once.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of the "},{"inlineContent":[{"type":"text","text":"condition"}],"type":"emphasis"},{"type":"text","text":" must be of type "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" or a type bridged to "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":". The condition can also be an optional binding declaration, as discussed in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Optional-Binding","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of a repeat-while statement"},{"text":"Branch Statements","anchor":"Branch-Statements","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Branch statements allow the program to execute certain parts of code depending on the value of one or more conditions. The values of the conditions specified in a branch statement control how the program branches and, therefore, what block of code is executed. Swift has three branch statements: an "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement, a "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" statement, and a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Control flow in an "},{"code":"if","type":"codeVoice"},{"type":"text","text":" statement or a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement can be changed by a "},{"code":"break","type":"codeVoice"},{"type":"text","text":" statement and is discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Break-Statement"},{"type":"text","text":" below."}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]}],"type":"aside","style":"note","name":"Grammar of a branch statement"},{"text":"If Statement","anchor":"If-Statement","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement is used for executing code based on the evaluation of one or more conditions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two basic forms of an "},{"code":"if","type":"codeVoice"},{"type":"text","text":" statement. In each form, the opening and closing braces are required."}]},{"type":"paragraph","inlineContent":[{"text":"The first form allows code to be executed only when a condition is true and has the following form:","type":"text"}]},{"code":["if condition {","    statements","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The second form of an "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement provides an additional "},{"type":"emphasis","inlineContent":[{"type":"text","text":"else clause"}]},{"type":"text","text":" (introduced by the "},{"type":"codeVoice","code":"else"},{"type":"text","text":" keyword) and is used for executing one part of code when the condition is true and another part of code when the same condition is false. When a single else clause is present, an "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement has the following form:"}]},{"code":["if condition {","    statements to execute if condition is true","} else {","    statements to execute if condition is false","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The else clause of an "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement can contain another "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement to test more than one condition. An "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement chained together in this way has the following form:"}]},{"code":["if condition 1 {","    statements to execute if condition 1 is true","} else if condition 2 {","    statements to execute if condition 2 is true","} else {","    statements to execute if both conditions are false","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The value of any condition in an "},{"code":"if","type":"codeVoice"},{"type":"text","text":" statement must be of type "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" or a type bridged to "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":". The condition can also be an optional binding declaration, as discussed in "},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Optional-Binding","type":"reference"},{"type":"text","text":"."}]},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of an if statement"},{"text":"Guard Statement","anchor":"Guard-Statement","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":" statement is used to transfer program control out of a scope if one or more conditions aren’t met.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":" statement has the following form:","type":"text"}]},{"code":["guard condition else {","    statements","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The value of any condition in a ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":" statement must be of type ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" or a type bridged to ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":". The condition can also be an optional binding declaration, as discussed in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Optional-Binding","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Any constants or variables assigned a value from an optional binding declaration in a ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":" statement condition can be used for the rest of the guard statement’s enclosing scope.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"else","type":"codeVoice"},{"type":"text","text":" clause of a "},{"code":"guard","type":"codeVoice"},{"type":"text","text":" statement is required, and must either call a function with the "},{"code":"Never","type":"codeVoice"},{"type":"text","text":" return type or transfer program control outside the guard statement’s enclosing scope using one of the following statements:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"return"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"break"}]}]},{"content":[{"inlineContent":[{"code":"continue","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"throw","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Control transfer statements are discussed in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Control-Transfer-Statements"},{"type":"text","text":" below. For more information on functions with the "},{"type":"codeVoice","code":"Never"},{"type":"text","text":" return type, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Functions-that-Never-Return"},{"type":"text","text":"."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"type":"aside","style":"note","name":"Grammar of a guard statement"},{"text":"Switch Statement","anchor":"Switch-Statement","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement allows certain blocks of code to be executed depending on the value of a control expression."}]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement has the following form:","type":"text"}]},{"code":["switch control expression {","case pattern 1:","    statements","case pattern 2 where condition:","    statements","case pattern 3 where condition,","     pattern 4 where condition:","    statements","default:","    statements","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"control expression"}]},{"text":" of the ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" statement is evaluated and then compared with the patterns specified in each case. If a match is found, the program executes the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"statements"}]},{"text":" listed within the scope of that case. The scope of each case can’t be empty. As a result, you must include at least one statement following the colon (","type":"text"},{"type":"codeVoice","code":":"},{"text":") of each case label. Use a single ","type":"text"},{"type":"codeVoice","code":"break"},{"text":" statement if you don’t intend to execute any code in the body of a matched case.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The values of expressions your code can branch on are very flexible. For example, in addition to the values of scalar types, such as integers and characters, your code can branch on the values of any type, including floating-point numbers, strings, tuples, instances of custom classes, and optionals. The value of the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"control expression"}]},{"text":" can even be matched to the value of a case in an enumeration and checked for inclusion in a specified range of values. For examples of how to use these various types of values in ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" statements, see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Switch"},{"text":" in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","type":"reference","isActive":true},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" case can optionally contain a ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause after each pattern. A ","type":"text"},{"inlineContent":[{"text":"where clause","type":"text"}],"type":"emphasis"},{"text":" is introduced by the ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" keyword followed by an expression, and is used to provide an additional condition before a pattern in a case is considered matched to the ","type":"text"},{"inlineContent":[{"text":"control expression","type":"text"}],"type":"emphasis"},{"text":". If a ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause is present, the ","type":"text"},{"inlineContent":[{"type":"text","text":"statements"}],"type":"emphasis"},{"text":" within the relevant case are executed only if the value of the ","type":"text"},{"inlineContent":[{"text":"control expression","type":"text"}],"type":"emphasis"},{"text":" matches one of the patterns of the case and the expression of the ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause evaluates to ","type":"text"},{"code":"true","type":"codeVoice"},{"text":". For example, a ","type":"text"},{"inlineContent":[{"type":"text","text":"control expression"}],"type":"emphasis"},{"text":" matches the case in the example below only if it’s a tuple that contains two elements of the same value, such as ","type":"text"},{"code":"(1, 1)","type":"codeVoice"},{"text":".","type":"text"}]},{"code":["case let (x, y) where x == y:"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"As the above example shows, patterns in a case can also bind constants using the ","type":"text"},{"type":"codeVoice","code":"let"},{"text":" keyword (they can also bind variables using the ","type":"text"},{"type":"codeVoice","code":"var"},{"text":" keyword). These constants (or variables) can then be referenced in a corresponding ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause and throughout the rest of the code within the scope of the case. If the case contains multiple patterns that match the control expression, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the case’s patterns.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement can also include a default case, introduced by the ","type":"text"},{"code":"default","type":"codeVoice"},{"text":" keyword. The code within a default case is executed only if no other cases match the control expression. A ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement can include only one default case, which must appear at the end of the ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Although the actual execution order of pattern-matching operations, and in particular the evaluation order of patterns in cases, is unspecified, pattern matching in a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement behaves as if the evaluation is performed in source order—that is, the order in which they appear in source code. As a result, if multiple cases contain patterns that evaluate to the same value, and thus can match the value of the control expression, the program executes only the code within the first matching case in source order."}]},{"text":"Switch Statements Must Be Exhaustive","anchor":"Switch-Statements-Must-Be-Exhaustive","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, every possible value of the control expression’s type must match the value of at least one pattern of a case. When this simply isn’t feasible (for example, when the control expression’s type is "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"), you can include a default case to satisfy the requirement."}]},{"text":"Switching Over Future Enumeration Cases","anchor":"Switching-Over-Future-Enumeration-Cases","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"nonfrozen enumeration"}],"type":"emphasis"},{"text":" is a special kind of enumeration that may gain new enumeration cases in the future—even after you compile and ship an app. Switching over a nonfrozen enumeration requires extra consideration. When a library’s authors mark an enumeration as nonfrozen, they reserve the right to add new enumeration cases, and any code that interacts with that enumeration ","type":"text"},{"inlineContent":[{"text":"must","type":"text"}],"type":"emphasis"},{"text":" be able to handle those future cases without being recompiled. Code that’s compiled in library evolution mode, code in the standard library, Swift overlays for Apple frameworks, and C and Objective-C code can declare nonfrozen enumerations. For information about frozen and nonfrozen enumerations, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Attributes#frozen","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When switching over a nonfrozen enumeration value, you always need to include a default case, even if every case of the enumeration already has a corresponding switch case. You can apply the "},{"type":"codeVoice","code":"@unknown"},{"type":"text","text":" attribute to the default case, which indicates that the default case should match only enumeration cases that are added in the future. Swift produces a warning if the default case matches any enumeration case that’s known at compiler time. This future warning informs you that the library author added a new case to the enumeration that doesn’t have a corresponding switch case."}]},{"type":"paragraph","inlineContent":[{"text":"The following example switches over all three existing cases of the standard library’s ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/mirror\/ancestorrepresentation","isActive":true,"type":"reference"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/mirror\/ancestorrepresentation]","type":"text"},{"text":" enumeration. If you add additional cases in the future, the compiler generates a warning to indicate that you need to update the switch statement to take the new cases into account.","type":"text"}]},{"code":["let representation: Mirror.AncestorRepresentation = .generated","switch representation {","case .customized:","    print(\"Use the nearest ancestor’s implementation.\")","case .generated:","    print(\"Generate a default mirror for all ancestor classes.\")","case .suppressed:","    print(\"Suppress the representation of all ancestor classes.\")","@unknown default:","    print(\"Use a representation that was unknown when this code was compiled.\")","}","\/\/ Prints \"Generate a default mirror for all ancestor classes.\""],"type":"codeListing","syntax":"swift"},{"text":"Execution Does Not Fall Through Cases Implicitly","anchor":"Execution-Does-Not-Fall-Through-Cases-Implicitly","level":4,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After the code within a matched case has finished executing, the program exits from the "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement. Program execution doesn’t continue or “fall through” to the next case or default case. That said, if you want execution to continue from one case to the next, explicitly include a "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" statement, which simply consists of the "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" keyword, in the case from which you want execution to continue. For more information about the "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" statement, see "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Fallthrough-Statement","type":"reference","isActive":true},{"type":"text","text":" below."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"type":"aside","style":"note","name":"Grammar of a switch statement"},{"text":"Labeled Statement","anchor":"Labeled-Statement","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can prefix a loop statement, an ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" statement, a ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement, or a ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" statement with a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"statement label","type":"text"}]},{"text":", which consists of the name of the label followed immediately by a colon (:). Use statement labels with ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" statements to be explicit about how you want to change control flow in a loop statement or a ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement, as discussed in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Break-Statement","isActive":true,"type":"reference"},{"text":" and ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Continue-Statement","isActive":true,"type":"reference"},{"text":" below.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The scope of a labeled statement is the entire statement following the statement label. You can nest labeled statements, but the name of each statement label must be unique."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information and to see examples of how to use statement labels, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Labeled-Statements","isActive":true},{"type":"text","text":" in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","isActive":true},{"type":"text","text":"."}]},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of a labeled statement"},{"text":"Control Transfer Statements","anchor":"Control-Transfer-Statements","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Control transfer statements can change the order in which code in your program is executed by unconditionally transferring program control from one piece of code to another. Swift has five control transfer statements: a "},{"type":"codeVoice","code":"break"},{"type":"text","text":" statement, a "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" statement, a "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" statement, a "},{"type":"codeVoice","code":"return"},{"type":"text","text":" statement, and a "},{"type":"codeVoice","code":"throw"},{"type":"text","text":" statement."}]},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of a control transfer statement"},{"text":"Break Statement","anchor":"Break-Statement","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"code":"break","type":"codeVoice"},{"type":"text","text":" statement ends program execution of a loop, an "},{"code":"if","type":"codeVoice"},{"type":"text","text":" statement, or a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement. A "},{"code":"break","type":"codeVoice"},{"type":"text","text":" statement can consist of only the "},{"code":"break","type":"codeVoice"},{"type":"text","text":" keyword, or it can consist of the "},{"code":"break","type":"codeVoice"},{"type":"text","text":" keyword followed by the name of a statement label, as shown below."}]},{"code":["break","break label name"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"When a ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" statement is followed by the name of a statement label, it ends program execution of the loop, ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" statement, or ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement named by that label.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"When a ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" statement isn’t followed by the name of a statement label, it ends program execution of the ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement or the innermost enclosing loop statement in which it occurs. You can’t use an unlabeled ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" statement to break out of an ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" statement.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In both cases, program control is then transferred to the first line of code following the enclosing loop or "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement, if any."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For examples of how to use a "},{"type":"codeVoice","code":"break"},{"type":"text","text":" statement, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Break"},{"type":"text","text":" and "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Labeled-Statements"},{"type":"text","text":" in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},{"type":"text","text":"."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"type":"aside","style":"note","name":"Grammar of a break statement"},{"text":"Continue Statement","anchor":"Continue-Statement","level":3,"type":"heading"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" statement ends program execution of the current iteration of a loop statement but doesn’t stop execution of the loop statement. A ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" statement can consist of only the ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" keyword, or it can consist of the ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" keyword followed by the name of a statement label, as shown below.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["continue","continue label name"]},{"inlineContent":[{"text":"When a ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" statement is followed by the name of a statement label, it ends program execution of the current iteration of the loop statement named by that label.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"When a ","type":"text"},{"code":"continue","type":"codeVoice"},{"text":" statement isn’t followed by the name of a statement label, it ends program execution of the current iteration of the innermost enclosing loop statement in which it occurs.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In both cases, program control is then transferred to the condition of the enclosing loop statement.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In a "},{"type":"codeVoice","code":"for"},{"type":"text","text":" statement, the increment expression is still evaluated after the "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" statement is executed, because the increment expression is evaluated after the execution of the loop’s body."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For examples of how to use a "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" statement, see "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Continue","type":"reference","isActive":true},{"type":"text","text":" and "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Labeled-Statements","type":"reference","isActive":true},{"type":"text","text":" in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]}],"name":"Grammar of a continue statement","style":"note","type":"aside"},{"level":3,"anchor":"Fallthrough-Statement","type":"heading","text":"Fallthrough Statement"},{"inlineContent":[{"type":"text","text":"A "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" statement consists of the "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" keyword and occurs only in a case block of a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement. A "},{"code":"fallthrough","type":"codeVoice"},{"type":"text","text":" statement causes program execution to continue from one case in a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement to the next case. Program execution continues to the next case even if the patterns of the case label don’t match the value of the "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement’s control expression."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"fallthrough"},{"type":"text","text":" statement can appear anywhere inside a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement, not just as the last statement of a case block, but it can’t be used in the final case block. It also can’t transfer control into a case block whose pattern contains value binding patterns."}],"type":"paragraph"},{"inlineContent":[{"text":"For an example of how to use a ","type":"text"},{"code":"fallthrough","type":"codeVoice"},{"text":" statement in a ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Control-Transfer-Statements","isActive":true,"type":"reference"},{"text":" in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"}],"name":"Grammar of a fallthrough statement","style":"note","type":"aside"},{"level":3,"anchor":"Return-Statement","type":"heading","text":"Return Statement"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"return"},{"type":"text","text":" statement occurs in the body of a function or method definition and causes program execution to return to the calling function or method. Program execution continues at the point immediately following the function or method call."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"return"},{"type":"text","text":" statement can consist of only the "},{"type":"codeVoice","code":"return"},{"type":"text","text":" keyword, or it can consist of the "},{"type":"codeVoice","code":"return"},{"text":" keyword followed by an expression, as shown below.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["return","return expression"]},{"inlineContent":[{"type":"text","text":"When a "},{"type":"codeVoice","code":"return"},{"type":"text","text":" statement is followed by an expression, the value of the expression is returned to the calling function or method. If the value of the expression doesn’t match the value of the return type declared in the function or method declaration, the expression’s value is converted to the return type before it’s returned to the calling function or method."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"As described in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Failable-Initializers"},{"type":"text","text":", a special form of the "},{"code":"return","type":"codeVoice"},{"type":"text","text":" statement ("},{"code":"return nil","type":"codeVoice"},{"type":"text","text":") can be used in a failable initializer to indicate initialization failure."}],"type":"paragraph"}],"name":"Note","style":"note","type":"aside"},{"inlineContent":[{"type":"text","text":"When a "},{"type":"codeVoice","code":"return"},{"type":"text","text":" statement isn’t followed by an expression, it can be used only to return from a function or method that doesn’t return a value (that is, when the return type of the function or method is "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" or "},{"type":"codeVoice","code":"()"},{"type":"text","text":")."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"}],"name":"Grammar of a return statement","style":"note","type":"aside"},{"level":3,"anchor":"Throw-Statement","type":"heading","text":"Throw Statement"},{"inlineContent":[{"type":"text","text":"A "},{"code":"throw","type":"codeVoice"},{"type":"text","text":" statement occurs in the body of a throwing function or method, or in the body of a closure expression whose type is marked with the "},{"code":"throws","type":"codeVoice"},{"type":"text","text":" keyword."}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"throw","type":"codeVoice"},{"text":" statement causes a program to end execution of the current scope and begin error propagation to its enclosing scope. The error that’s thrown continues to propagate until it’s handled by a ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause of a ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" statement.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"throw","type":"codeVoice"},{"text":" statement consists of the ","type":"text"},{"code":"throw","type":"codeVoice"},{"text":" keyword followed by an expression, as shown below.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["throw expression"]},{"inlineContent":[{"text":"The value of the ","type":"text"},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"},{"text":" must have a type that conforms to the ","type":"text"},{"type":"codeVoice","code":"Error"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For an example of how to use a ","type":"text"},{"code":"throw","type":"codeVoice"},{"text":" statement, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling#Propagating-Errors-Using-Throwing-Functions","isActive":true,"type":"reference"},{"text":" in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]}],"name":"Grammar of a throw statement","style":"note","type":"aside"},{"level":2,"anchor":"Defer-Statement","type":"heading","text":"Defer Statement"},{"inlineContent":[{"type":"text","text":"A "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statement is used for executing code just before transferring program control outside of the scope that the "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statement appears in."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement has the following form:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["defer {","    statements","}"]},{"inlineContent":[{"text":"The statements within the ","type":"text"},{"type":"codeVoice","code":"defer"},{"text":" statement are executed no matter how program control is transferred. This means that a ","type":"text"},{"type":"codeVoice","code":"defer"},{"text":" statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If multiple "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statements appear in the same scope, the order they appear is the reverse of the order they’re executed. Executing the last "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statement in a given scope first means that statements inside that last "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statement can refer to resources that will be cleaned up by other "},{"code":"defer","type":"codeVoice"},{"type":"text","text":" statements."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func f() {","    defer { print(\"First defer\") }","    defer { print(\"Second defer\") }","    print(\"End of function\")","}","f()","\/\/ Prints \"End of function\"","\/\/ Prints \"Second defer\"","\/\/ Prints \"First defer\""]},{"inlineContent":[{"text":"The statements in the ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" statement can’t transfer program control outside of the ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" statement.","type":"text"}],"type":"paragraph"},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"}],"name":"Grammar of a defer statement","style":"note","type":"aside"},{"level":2,"anchor":"Do-Statement","type":"heading","text":"Do Statement"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"do"},{"text":" statement is used to introduce a new scope and can optionally contain one or more ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":" clauses, which contain patterns that match against defined error conditions. Variables and constants declared in the scope of a ","type":"text"},{"type":"codeVoice","code":"do"},{"text":" statement can be accessed only within that scope.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" statement in Swift is similar to curly braces (","type":"text"},{"code":"{}","type":"codeVoice"},{"text":") in C used to delimit a code block, and doesn’t incur a performance cost at runtime.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" statement has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["do {","    try expression","    statements","} catch pattern 1 {","    statements","} catch pattern 2 where condition {","    statements","} catch pattern 3, pattern 4 where condition {","    statements","} catch {","    statements","}"]},{"inlineContent":[{"text":"If any statement in the ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" code block throws an error, program control is transferred to the first ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause whose pattern matches the error. If none of the clauses match, the error propagates to the surrounding scope. If an error is unhandled at the top level, program execution stops with a runtime error.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Like a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement, the compiler attempts to infer whether "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clauses are exhaustive. If such a determination can be made, the error is considered handled. Otherwise, the error can propagate out of the containing scope, which means the error must be handled by an enclosing "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clause or the containing function must be declared with "},{"type":"codeVoice","code":"throws"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause that has multiple patterns matches the error if any of its patterns match the error. If a ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause contains multiple patterns, all of the patterns must contain the same constant or variable bindings, and each bound variable or constant must have the same type in all of the ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause’s patterns.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To ensure that an error is handled, use a ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":" clause with a pattern that matches all errors, such as a wildcard pattern (","type":"text"},{"type":"codeVoice","code":"_"},{"text":"). If a ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":" clause doesn’t specify a pattern, the ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":" clause matches and binds any error to a local constant named ","type":"text"},{"type":"codeVoice","code":"error"},{"text":". For more information about the patterns you can use in a ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":" clause, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Patterns","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To see an example of how to use a ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" statement with several ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clauses, see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling#Handling-Errors"},{"text":".","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"name":"Grammar of a do statement","style":"note","type":"aside"},{"level":2,"anchor":"Compiler-Control-Statements","type":"heading","text":"Compiler Control Statements"},{"inlineContent":[{"type":"text","text":"Compiler control statements allow the program to change aspects of the compiler’s behavior. Swift has three compiler control statements: a conditional compilation block a line control statement, and a compile-time diagnostic statement."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"name":"Grammar of a compiler control statement","style":"note","type":"aside"},{"level":3,"anchor":"Conditional-Compilation-Block","type":"heading","text":"Conditional Compilation Block"},{"inlineContent":[{"text":"A conditional compilation block allows code to be conditionally compiled depending on the value of one or more compilation conditions.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Every conditional compilation block begins with the ","type":"text"},{"code":"#if","type":"codeVoice"},{"text":" compilation directive and ends with the ","type":"text"},{"type":"codeVoice","code":"#endif"},{"type":"text","text":" compilation directive. A simple conditional compilation block has the following form:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["#if compilation condition","statements","#endif"]},{"inlineContent":[{"text":"Unlike the condition of an ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" statement, the ","type":"text"},{"inlineContent":[{"type":"text","text":"compilation condition"}],"type":"emphasis"},{"text":" is evaluated at compile time. As a result, the ","type":"text"},{"inlineContent":[{"text":"statements","type":"text"}],"type":"emphasis"},{"text":" are compiled and executed only if the ","type":"text"},{"inlineContent":[{"text":"compilation condition","type":"text"}],"type":"emphasis"},{"text":" evaluates to ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" at compile time.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"type":"text","text":"compilation condition"}],"type":"emphasis"},{"text":" can include the ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"false","type":"codeVoice"},{"text":" Boolean literals, an identifier used with the ","type":"text"},{"code":"-D","type":"codeVoice"},{"text":" command line flag, or any of the platform conditions listed in the table below.","type":"text"}],"type":"paragraph"},{"header":"row","rows":[[[{"type":"paragraph","inlineContent":[{"text":"Platform condition","type":"text"}]}],[{"type":"paragraph","inlineContent":[{"text":"Valid arguments","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"os()"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"macOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"iOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"watchOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"tvOS"},{"type":"text","text":", "},{"type":"codeVoice","code":"Linux"},{"type":"text","text":", "},{"type":"codeVoice","code":"Windows"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"arch()"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"i386"},{"type":"text","text":", "},{"type":"codeVoice","code":"x86_64"},{"type":"text","text":", "},{"type":"codeVoice","code":"arm"},{"type":"text","text":", "},{"type":"codeVoice","code":"arm64"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"swift()"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":">="},{"type":"text","text":" or "},{"type":"codeVoice","code":"<"},{"type":"text","text":" followed by a version number"}]}]],[[{"type":"paragraph","inlineContent":[{"code":"compiler()","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":">="},{"type":"text","text":" or "},{"type":"codeVoice","code":"<"},{"type":"text","text":" followed by a version number"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"canImport()"}]}],[{"type":"paragraph","inlineContent":[{"text":"A module name","type":"text"}]}]],[[{"type":"paragraph","inlineContent":[{"code":"targetEnvironment()","type":"codeVoice"}]}],[{"type":"paragraph","inlineContent":[{"code":"simulator","type":"codeVoice"},{"text":", ","type":"text"},{"code":"macCatalyst","type":"codeVoice"}]}]]],"type":"table"},{"inlineContent":[{"text":"The version number for the ","type":"text"},{"type":"codeVoice","code":"swift()"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"compiler()"},{"text":" platform conditions consists of a major number, optional minor number, optional patch number, and so on, with a dot (","type":"text"},{"type":"codeVoice","code":"."},{"text":") separating each part of the version number. There must not be whitespace between the comparison operator and the version number. The version for ","type":"text"},{"type":"codeVoice","code":"compiler()"},{"text":" is the compiler version, regardless of the Swift version setting passed to the compiler. The version for ","type":"text"},{"type":"codeVoice","code":"swift()"},{"text":" is the language version currently being compiled. For example, if you compile your code using the Swift 5 compiler in Swift 4.2 mode, the compiler version is 5 and the language version is 4.2. With those settings, the following code prints all three messages:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["#if compiler(>=5)","print(\"Compiled with the Swift 5 compiler or later\")","#endif","#if swift(>=4.2)","print(\"Compiled in Swift 4.2 mode or later\")","#endif","#if compiler(>=5) && swift(<5)","print(\"Compiled with the Swift 5 compiler or later in a Swift mode earlier than 5\")","#endif","\/\/ Prints \"Compiled with the Swift 5 compiler or later\"","\/\/ Prints \"Compiled in Swift 4.2 mode or later\"","\/\/ Prints \"Compiled with the Swift 5 compiler or later in a Swift mode earlier than 5\""]},{"inlineContent":[{"text":"The argument for the ","type":"text"},{"code":"canImport()","type":"codeVoice"},{"text":" platform condition is the name of a module that may not be present on all platforms. The module can include periods (","type":"text"},{"code":".","type":"codeVoice"},{"text":") in its name. This condition tests whether it’s possible to import the module, but doesn’t actually import it. If the module is present, the platform condition returns ","type":"text"},{"code":"true","type":"codeVoice"},{"text":"; otherwise, it returns ","type":"text"},{"code":"false","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"targetEnvironment()","type":"codeVoice"},{"type":"text","text":" platform condition returns "},{"code":"true","type":"codeVoice"},{"type":"text","text":" when code is being compiled for the specified environment; otherwise, it returns "},{"code":"false","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"arch(arm)","type":"codeVoice"},{"text":" platform condition doesn’t return ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" for ARM 64 devices. The ","type":"text"},{"code":"arch(i386)","type":"codeVoice"},{"text":" platform condition returns ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" when code is compiled for the 32–bit iOS simulator.","type":"text"}]}],"name":"Note","style":"note","type":"aside"},{"inlineContent":[{"type":"text","text":"You can combine and negate compilation conditions using the logical operators "},{"type":"codeVoice","code":"&&"},{"type":"text","text":", "},{"type":"codeVoice","code":"||"},{"type":"text","text":", and "},{"type":"codeVoice","code":"!"},{"type":"text","text":" and use parentheses for grouping. These operators have the same associativity and precedence as the logical operators that are used to combine ordinary Boolean expressions."}],"type":"paragraph"},{"inlineContent":[{"text":"Similar to an ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" statement, you can add multiple conditional branches to test for different compilation conditions. You can add any number of additional branches using ","type":"text"},{"code":"#elseif","type":"codeVoice"},{"text":" clauses. You can also add a final additional branch using an ","type":"text"},{"code":"#else","type":"codeVoice"},{"text":" clause. Conditional compilation blocks that contain multiple branches have the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["#if compilation condition 1","statements to compile if compilation condition 1 is true","#elseif compilation condition 2","statements to compile if compilation condition 2 is true","#else","statements to compile if both compilation conditions are false","#endif"]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Each statement in the body of a conditional compilation block is parsed even if it’s not compiled. However, there’s an exception if the compilation condition includes a ","type":"text"},{"code":"swift()","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"compiler()","type":"codeVoice"},{"text":" platform condition: The statements are parsed only if the language or compiler version matches what is specified in the platform condition. This exception ensures that an older compiler doesn’t attempt to parse syntax introduced in a newer version of Swift.","type":"text"}]}],"name":"Note","style":"note","type":"aside"},{"inlineContent":[{"type":"text","text":"For information about how you can wrap explicit member expressions in conditional compilation blocks, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions#Explicit-Member-Expression","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"name":"Grammar of a conditional compilation block","style":"note","type":"aside"},{"level":3,"anchor":"Line-Control-Statement","type":"heading","text":"Line Control Statement"},{"inlineContent":[{"text":"A line control statement is used to specify a line number and filename that can be different from the line number and filename of the source code being compiled. Use a line control statement to change the source code location used by Swift for diagnostic and debugging purposes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A line control statement has the following forms:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["#sourceLocation(file: file path, line: line number)","#sourceLocation()"]},{"inlineContent":[{"type":"text","text":"The first form of a line control statement changes the values of the "},{"type":"codeVoice","code":"#line"},{"type":"text","text":", "},{"type":"codeVoice","code":"#file"},{"type":"text","text":", "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":", and "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":" literal expressions, beginning with the line of code following the line control statement. The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"line number"}]},{"type":"text","text":" changes the value of "},{"type":"codeVoice","code":"#line"},{"type":"text","text":", and is any integer literal greater than zero. The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"file path"}]},{"type":"text","text":" changes the value of "},{"type":"codeVoice","code":"#file"},{"type":"text","text":", "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":", and "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":", and is a string literal. The specified string becomes the value of "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":", and the last path component of the string is used by the value of "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":". For information about "},{"type":"codeVoice","code":"#file"},{"type":"text","text":", "},{"type":"codeVoice","code":"#fileID"},{"type":"text","text":", and "},{"type":"codeVoice","code":"#filePath"},{"type":"text","text":", see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions#Literal-Expression"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The second form of a line control statement, ","type":"text"},{"code":"#sourceLocation()","type":"codeVoice"},{"text":", resets the source code location back to the default line numbering and file path.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]}],"name":"Grammar of a line control statement","style":"note","type":"aside"},{"level":3,"anchor":"Compile-Time-Diagnostic-Statement","type":"heading","text":"Compile-Time Diagnostic Statement"},{"inlineContent":[{"type":"text","text":"A compile-time diagnostic statement causes the compiler to emit an error or a warning during compilation. A compile-time diagnostic statement has the following forms:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["#error(\"error message\")","#warning(\"warning message\")"]},{"inlineContent":[{"type":"text","text":"The first form emits the "},{"inlineContent":[{"type":"text","text":"error message"}],"type":"emphasis"},{"type":"text","text":" as a fatal error and terminates the compilation process. The second form emits the "},{"inlineContent":[{"type":"text","text":"warning message"}],"type":"emphasis"},{"type":"text","text":" as a nonfatal warning and allows compilation to proceed. You write the diagnostic message as a static string literal. Static string literals can’t use features like string interpolation or concatenation, but they can use the multiline string literal syntax."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"}],"name":"Grammar of a compile-time diagnostic statement","style":"note","type":"aside"},{"level":2,"anchor":"Availability-Condition","type":"heading","text":"Availability Condition"},{"inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"text":"availability condition","type":"text"}]},{"type":"text","text":" is used as a condition of an "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":", and "},{"type":"codeVoice","code":"guard"},{"type":"text","text":" statement to query the availability of APIs at runtime, based on specified platforms arguments."}],"type":"paragraph"},{"inlineContent":[{"text":"An availability condition has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if #available(platform name version, ..., *) {","    statements to execute if the APIs are available","} else {","    fallback statements to execute if the APIs are unavailable","}"]},{"inlineContent":[{"text":"You use an availability condition to execute a block of code, depending on whether the APIs you want to use are available at runtime. The compiler uses the information from the availability condition when it verifies that the APIs in that block of code are available.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The availability condition takes a comma-separated list of platform names and versions. Use "},{"code":"iOS","type":"codeVoice"},{"type":"text","text":", "},{"code":"macOS","type":"codeVoice"},{"type":"text","text":", "},{"code":"watchOS","type":"codeVoice"},{"type":"text","text":", and "},{"code":"tvOS","type":"codeVoice"},{"type":"text","text":" for the platform names, and include the corresponding version numbers. The "},{"code":"*","type":"codeVoice"},{"type":"text","text":" argument is required and specifies that, on any other platform, the body of the code block guarded by the availability condition executes on the minimum deployment target specified by your target."}],"type":"paragraph"},{"inlineContent":[{"text":"Unlike Boolean conditions, you can’t combine availability conditions using logical operators like ","type":"text"},{"type":"codeVoice","code":"&&"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"||"},{"text":". Instead of using ","type":"text"},{"type":"codeVoice","code":"!"},{"text":" to negate an availability condition, use an unavailability condition, which has the following form:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if #unavailable(platform name version, ...) {","    fallback statements to execute if the APIs are unavailable","} else {","    statements to execute if the APIs are available","}"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"#unavailable","type":"codeVoice"},{"type":"text","text":" form is syntactic sugar that negates the condition. In an unavailability condition, the "},{"code":"*","type":"codeVoice"},{"type":"text","text":" argument is implicit and must not be included. It has the same meaning as the "},{"code":"*","type":"codeVoice"},{"type":"text","text":" argument in an availability condition."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]}],"name":"Grammar of an availability condition","style":"note","type":"aside"}],"kind":"content"}],"references":{"doc://com.apple.Swift/documentation/Swift/TheBasics#Optional-Binding":{"url":"\/documentation\/swift\/thebasics#Optional-Binding","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Optional-Binding","title":"Optional Binding","abstract":[],"kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Statements#Control-Transfer-Statements":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Control-Transfer-Statements","type":"topic","kind":"section","abstract":[],"url":"\/documentation\/swift\/statements#Control-Transfer-Statements","title":"Control Transfer Statements"},"doc://com.apple.Swift/documentation/Swift/Statements#Fallthrough-Statement":{"kind":"section","title":"Fallthrough Statement","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Fallthrough-Statement","url":"\/documentation\/swift\/statements#Fallthrough-Statement","type":"topic","abstract":[]},"doc://com.apple.Swift/documentation/Swift/ControlFlow#Control-Transfer-Statements":{"type":"topic","url":"\/documentation\/swift\/controlflow#Control-Transfer-Statements","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Control-Transfer-Statements","kind":"section","title":"Control Transfer Statements"},"doc://com.apple.Swift/documentation/Swift/Attributes#frozen":{"url":"\/documentation\/swift\/attributes#frozen","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Attributes#frozen","title":"frozen","abstract":[],"kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ControlFlow#Labeled-Statements":{"url":"\/documentation\/swift\/controlflow#Labeled-Statements","title":"Labeled Statements","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Labeled-Statements","kind":"section","abstract":[],"type":"topic"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling#Propagating-Errors-Using-Throwing-Functions":{"abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling#Propagating-Errors-Using-Throwing-Functions","type":"topic","url":"\/documentation\/swift\/errorhandling#Propagating-Errors-Using-Throwing-Functions","title":"Propagating Errors Using Throwing Functions","kind":"section"},"doc://com.apple.Swift/documentation/Swift/AboutTheLanguageReference":{"abstract":[{"text":"This part of the book describes the formal grammar of the Swift programming language. The grammar described here is intended to help you understand the language in more detail, rather than to allow you to directly implement a parser or compiler.","type":"text"}],"url":"\/documentation\/swift\/aboutthelanguagereference","role":"article","title":"About the Language Reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AboutTheLanguageReference","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ControlFlow#Continue":{"kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Continue","type":"topic","title":"Continue","url":"\/documentation\/swift\/controlflow#Continue"},"doc://com.apple.Swift/documentation/Swift/ControlFlow#Switch":{"url":"\/documentation\/swift\/controlflow#Switch","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Switch","title":"Switch","abstract":[],"kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Declarations#Functions-that-Never-Return":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Functions-that-Never-Return","kind":"section","url":"\/documentation\/swift\/declarations#Functions-that-Never-Return","title":"Functions that Never Return","type":"topic","abstract":[]},"doc://com.apple.Swift/documentation/Swift/Expressions#Literal-Expression":{"type":"topic","title":"Literal Expression","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions#Literal-Expression","url":"\/documentation\/swift\/expressions#Literal-Expression","abstract":[]},"doc://com.apple.Swift/documentation/Swift/ControlFlow#Break":{"type":"topic","kind":"section","title":"Break","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#Break","url":"\/documentation\/swift\/controlflow#Break","abstract":[]},"doc://com.apple.Swift/documentation/Swift/GenericParametersAndArguments":{"abstract":[{"text":"This chapter describes parameters and arguments for generic types, functions, and initializers. When you declare a generic type, function, subscript, or initializer, you specify the type parameters that the generic type, function, or initializer can work with. These type parameters act as placeholders that are replaced by actual concrete type arguments when an instance of a generic type is created or a generic function or initializer is called.","type":"text"}],"url":"\/documentation\/swift\/genericparametersandarguments","role":"article","title":"Generic Parameters and Arguments","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/GenericParametersAndArguments","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Expressions":{"abstract":[{"text":"In Swift, there are four kinds of expressions: prefix expressions, infix expressions, primary expressions, and postfix expressions. Evaluating an expression returns a value, causes a side effect, or both.","type":"text"}],"url":"\/documentation\/swift\/expressions","role":"article","title":"Expressions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Types":{"abstract":[{"text":"In Swift, there are two kinds of types: named types and compound types. A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"named type","type":"text"}]},{"text":" is a type that can be given a particular name when it’s defined. Named types include classes, structures, enumerations, and protocols. For example, instances of a user-defined class named ","type":"text"},{"type":"codeVoice","code":"MyClass"},{"text":" have the type ","type":"text"},{"type":"codeVoice","code":"MyClass"},{"text":". In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.","type":"text"}],"url":"\/documentation\/swift\/types","role":"article","title":"Types","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Types","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Declarations":{"abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"declaration","type":"text"}]},{"text":" introduces a new name or construct into your program. For example, you use declarations to introduce functions and methods, to introduce variables and constants, and to define enumeration, structure, class, and protocol types. You can also use a declaration to extend the behavior of an existing named type and to import symbols into your program that are declared elsewhere.","type":"text"}],"url":"\/documentation\/swift\/declarations","role":"article","title":"Declarations","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"url":"\/documentation\/swift\/errorhandling","role":"article","title":"Error Handling","abstract":[{"inlineContent":[{"type":"text","text":"Error handling"}],"type":"emphasis"},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","type":"topic"},"https://developer.apple.com/documentation/swift/iteratorprotocol":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/iteratorprotocol","title":"IteratorProtocol","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/iteratorprotocol","titleInlineContent":[{"text":"IteratorProtocol","type":"text"}],"type":"link"},"doc://com.apple.Swift/documentation/Swift/LexicalStructure":{"abstract":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"lexical structure","type":"text"}]},{"text":" of Swift describes what sequence of characters form valid tokens of the language. These valid tokens form the lowest-level building blocks of the language and are used to describe the rest of the language in subsequent chapters. A token consists of an identifier, keyword, punctuation, literal, or operator.","type":"text"}],"url":"\/documentation\/swift\/lexicalstructure","role":"article","title":"Lexical Structure","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/LexicalStructure","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Expressions#Explicit-Member-Expression":{"type":"topic","title":"Explicit Member Expression","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions#Explicit-Member-Expression","url":"\/documentation\/swift\/expressions#Explicit-Member-Expression","abstract":[]},"doc://com.apple.Swift/documentation/Swift/Attributes":{"abstract":[{"text":"There are two kinds of attributes in Swift—those that apply to declarations and those that apply to types. An attribute provides additional information about the declaration or type. For example, the ","type":"text"},{"type":"codeVoice","code":"discardableResult"},{"text":" attribute on a function declaration indicates that, although the function returns a value, the compiler shouldn’t generate a warning if the return value is unused.","type":"text"}],"url":"\/documentation\/swift\/attributes","role":"article","title":"Attributes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Attributes","type":"topic","kind":"article"},"https://developer.apple.com/documentation/swift/sequence":{"titleInlineContent":[{"text":"Sequence","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/sequence","type":"link","title":"Sequence","url":"https:\/\/developer.apple.com\/documentation\/swift\/sequence"},"doc://com.apple.Swift/documentation/Swift/Patterns":{"abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" represents the structure of a single value or a composite value. For example, the structure of a tuple ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"text":" is a comma-separated list of two elements. Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values. For instance, the pattern ","type":"text"},{"type":"codeVoice","code":"(x, y)"},{"text":" matches the tuple ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"text":" and any other two-element tuple. In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.","type":"text"}],"url":"\/documentation\/swift\/patterns","role":"article","title":"Patterns","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Patterns","type":"topic","kind":"article"},"https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation":{"titleInlineContent":[{"text":"Mirror.AncestorRepresentation","type":"text"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/mirror\/ancestorrepresentation","type":"link","title":"Mirror.AncestorRepresentation","url":"https:\/\/developer.apple.com\/documentation\/swift\/mirror\/ancestorrepresentation"},"doc://com.apple.Swift/documentation/Swift/zzSummaryOfTheGrammar":{"abstract":[],"url":"\/documentation\/swift\/zzsummaryofthegrammar","role":"article","title":"Summary of the Grammar","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/zzSummaryOfTheGrammar","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling#Handling-Errors":{"url":"\/documentation\/swift\/errorhandling#Handling-Errors","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling#Handling-Errors","title":"Handling Errors","abstract":[],"kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Declarations#Failable-Initializers":{"abstract":[],"title":"Failable Initializers","type":"topic","url":"\/documentation\/swift\/declarations#Failable-Initializers","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Failable-Initializers","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Statements#Break-Statement":{"url":"\/documentation\/swift\/statements#Break-Statement","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Break-Statement","title":"Break Statement","abstract":[],"kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Statements#Continue-Statement":{"kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Statements#Continue-Statement","type":"topic","title":"Continue Statement","url":"\/documentation\/swift\/statements#Continue-Statement"}}}