{"kind":"article","hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling"},"schemaVersion":{"major":0,"minor":3,"patch":0},"variants":[{"paths":["\/documentation\/swift\/errorhandling"],"traits":[{"interfaceLanguage":"swift"}]}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"title":"Language Guide"}],"abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"metadata":{"roleHeading":"Article","title":"Error Handling","role":"article","modules":[{"name":"Swift"}]},"primaryContentSections":[{"content":[{"text":"Overview","level":2,"anchor":"overview","type":"heading"},{"inlineContent":[{"text":"Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve.","type":"text"}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"Error handling in Swift interoperates with error handling patterns that use the ","type":"text"},{"code":"NSError","type":"codeVoice"},{"text":" class in Cocoa and Objective-C. For more information about this class, see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/cocoa_design_patterns\/handling_cocoa_errors_in_swift","isActive":true,"type":"reference"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/cocoa_design_patterns\/handling_cocoa_errors_in_swift]","type":"text"},{"text":".","type":"text"}]}],"type":"aside","name":"Note","style":"note"},{"text":"Representing and Throwing Errors","level":2,"anchor":"Representing-and-Throwing-Errors","type":"heading"},{"inlineContent":[{"type":"text","text":"In Swift, errors are represented by values of types that conform to the "},{"type":"codeVoice","code":"Error"},{"text":" protocol. This empty protocol indicates that a type can be used for error handling.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game:","type":"text"}],"type":"paragraph"},{"code":["enum VendingMachineError: Error {","    case invalidSelection","    case insufficientFunds(coinsNeeded: Int)","    case outOfStock","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a ","type":"text"},{"code":"throw","type":"codeVoice"},{"text":" statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["throw VendingMachineError.insufficientFunds(coinsNeeded: 5)"],"type":"codeListing"},{"anchor":"Handling-Errors","text":"Handling Errors","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"There are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a "},{"code":"do","type":"codeVoice"},{"type":"text","text":"-"},{"code":"catch","type":"codeVoice"},{"type":"text","text":" statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below."}],"type":"paragraph"},{"inlineContent":[{"text":"When a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the ","type":"text"},{"type":"codeVoice","code":"try"},{"text":" keyword—or the ","type":"text"},{"type":"codeVoice","code":"try?"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"try!"},{"text":" variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below.","type":"text"}],"type":"paragraph"},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"Error handling in Swift resembles exception handling in other languages, with the use of the "},{"code":"try","type":"codeVoice"},{"type":"text","text":", "},{"code":"catch","type":"codeVoice"},{"type":"text","text":" and "},{"code":"throw","type":"codeVoice"},{"type":"text","text":" keywords. Unlike exception handling in many languages—including Objective-C—error handling in Swift doesn’t involve unwinding the call stack, a process that can be computationally expensive. As such, the performance characteristics of a "},{"code":"throw","type":"codeVoice"},{"type":"text","text":" statement are comparable to those of a "},{"code":"return","type":"codeVoice"},{"type":"text","text":" statement."}],"type":"paragraph"}]},{"anchor":"Propagating-Errors-Using-Throwing-Functions","text":"Propagating Errors Using Throwing Functions","type":"heading","level":3},{"inlineContent":[{"text":"To indicate that a function, method, or initializer can throw an error, you write the ","type":"text"},{"type":"codeVoice","code":"throws"},{"text":" keyword in the function’s declaration after its parameters. A function marked with ","type":"text"},{"type":"codeVoice","code":"throws"},{"text":" is called a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"throwing function"}]},{"text":". If the function specifies a return type, you write the ","type":"text"},{"type":"codeVoice","code":"throws"},{"text":" keyword before the return arrow (","type":"text"},{"type":"codeVoice","code":"->"},{"text":").","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["func canThrowErrors() throws -> String","","func cannotThrowErrors() -> String"]},{"inlineContent":[{"text":"A throwing function propagates errors that are thrown inside of it to the scope from which it’s called.","type":"text"}],"type":"paragraph"},{"type":"aside","name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Only throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function."}]}]},{"inlineContent":[{"text":"In the example below, the ","type":"text"},{"type":"codeVoice","code":"VendingMachine"},{"text":" class has a ","type":"text"},{"type":"codeVoice","code":"vend(itemNamed:)"},{"text":" method that throws an appropriate ","type":"text"},{"type":"codeVoice","code":"VendingMachineError"},{"text":" if the requested item isn’t available, is out of stock, or has a cost that exceeds the current deposited amount:","type":"text"}],"type":"paragraph"},{"code":["struct Item {","    var price: Int","    var count: Int","}","","class VendingMachine {","    var inventory = [","        \"Candy Bar\": Item(price: 12, count: 7),","        \"Chips\": Item(price: 10, count: 4),","        \"Pretzels\": Item(price: 7, count: 11)","    ]","    var coinsDeposited = 0","","    func vend(itemNamed name: String) throws {","        guard let item = inventory[name] else {","            throw VendingMachineError.invalidSelection","        }","","        guard item.count > 0 else {","            throw VendingMachineError.outOfStock","        }","","        guard item.price <= coinsDeposited else {","            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)","        }","","        coinsDeposited -= item.price","","        var newItem = item","        newItem.count -= 1","        inventory[name] = newItem","","        print(\"Dispensing \\(name)\")","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The implementation of the ","type":"text"},{"type":"codeVoice","code":"vend(itemNamed:)"},{"text":" method uses ","type":"text"},{"type":"codeVoice","code":"guard"},{"text":" statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a ","type":"text"},{"type":"codeVoice","code":"throw"},{"text":" statement immediately transfers program control, an item will be vended only if all of these requirements are met.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Because the "},{"code":"vend(itemNamed:)","type":"codeVoice"},{"type":"text","text":" method propagates any errors it throws, any code that calls this method must either handle the errors—using a "},{"code":"do","type":"codeVoice"},{"type":"text","text":"-"},{"code":"catch","type":"codeVoice"},{"type":"text","text":" statement, "},{"code":"try?","type":"codeVoice"},{"type":"text","text":", or "},{"code":"try!","type":"codeVoice"},{"type":"text","text":"—or continue to propagate them. For example, the "},{"code":"buyFavoriteSnack(person:vendingMachine:)","type":"codeVoice"},{"type":"text","text":" in the example below is also a throwing function, and any errors that the "},{"code":"vend(itemNamed:)","type":"codeVoice"},{"type":"text","text":" method throws will propagate up to the point where the "},{"code":"buyFavoriteSnack(person:vendingMachine:)","type":"codeVoice"},{"type":"text","text":" function is called."}],"type":"paragraph"},{"code":["let favoriteSnacks = [","    \"Alice\": \"Chips\",","    \"Bob\": \"Licorice\",","    \"Eve\": \"Pretzels\",","]","func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {","    let snackName = favoriteSnacks[person] ?? \"Candy Bar\"","    try vendingMachine.vend(itemNamed: snackName)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"In this example, the "},{"code":"buyFavoriteSnack(person: vendingMachine:)","type":"codeVoice"},{"type":"text","text":" function looks up a given person’s favorite snack and tries to buy it for them by calling the "},{"code":"vend(itemNamed:)","type":"codeVoice"},{"type":"text","text":" method. Because the "},{"code":"vend(itemNamed:)","type":"codeVoice"},{"type":"text","text":" method can throw an error, it’s called with the "},{"code":"try","type":"codeVoice"},{"type":"text","text":" keyword in front of it."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Throwing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the "},{"code":"PurchasedSnack","type":"codeVoice"},{"type":"text","text":" structure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller."}],"type":"paragraph"},{"code":["struct PurchasedSnack {","    let name: String","    init(name: String, vendingMachine: VendingMachine) throws {","        try vendingMachine.vend(itemNamed: name)","        self.name = name","    }","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Handling-Errors-Using-Do-Catch","text":"Handling Errors Using Do-Catch","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"You use a "},{"type":"codeVoice","code":"do"},{"type":"text","text":"-"},{"type":"codeVoice","code":"catch"},{"type":"text","text":" statement to handle errors by running a block of code. If an error is thrown by the code in the "},{"type":"codeVoice","code":"do"},{"type":"text","text":" clause, it’s matched against the "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clauses to determine which one of them can handle the error."}],"type":"paragraph"},{"inlineContent":[{"text":"Here is the general form of a ","type":"text"},{"code":"do","type":"codeVoice"},{"text":"-","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" statement:","type":"text"}],"type":"paragraph"},{"code":["do {","    try expression","    statements","} catch pattern 1 {","    statements","} catch pattern 2 where condition {","    statements","} catch pattern 3, pattern 4 where condition {","    statements","} catch {","    statements","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"You write a pattern after ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" to indicate what errors that clause can handle. If a ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named ","type":"text"},{"code":"error","type":"codeVoice"},{"text":". For more information about pattern matching, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Patterns","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, the following code matches against all three cases of the "},{"code":"VendingMachineError","type":"codeVoice"},{"type":"text","text":" enumeration."}],"type":"paragraph"},{"code":["var vendingMachine = VendingMachine()","vendingMachine.coinsDeposited = 8","do {","    try buyFavoriteSnack(person: \"Alice\", vendingMachine: vendingMachine)","    print(\"Success! Yum.\")","} catch VendingMachineError.invalidSelection {","    print(\"Invalid Selection.\")","} catch VendingMachineError.outOfStock {","    print(\"Out of Stock.\")","} catch VendingMachineError.insufficientFunds(let coinsNeeded) {","    print(\"Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\")","} catch {","    print(\"Unexpected error: \\(error).\")","}","\/\/ Prints \"Insufficient funds. Please insert an additional 2 coins.\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In the above example, the ","type":"text"},{"code":"buyFavoriteSnack(person:vendingMachine:)","type":"codeVoice"},{"text":" function is called in a ","type":"text"},{"code":"try","type":"codeVoice"},{"text":" expression, because it can throw an error. If an error is thrown, execution immediately transfers to the ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clauses, which decide whether to allow propagation to continue. If no pattern is matched, the error gets caught by the final ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clause and is bound to a local ","type":"text"},{"code":"error","type":"codeVoice"},{"text":" constant. If no error is thrown, the remaining statements in the ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" statement are executed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clauses don’t have to handle every possible error that the code in the ","type":"text"},{"code":"do","type":"codeVoice"},{"text":" clause can throw. If none of the ","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" clauses handle the error, the error propagates to the surrounding scope. However, the propagated error must be handled by ","type":"text"},{"inlineContent":[{"type":"text","text":"some"}],"type":"emphasis"},{"text":" surrounding scope. In a nonthrowing function, an enclosing ","type":"text"},{"code":"do","type":"codeVoice"},{"text":"-","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" statement must handle the error. In a throwing function, either an enclosing ","type":"text"},{"code":"do","type":"codeVoice"},{"text":"-","type":"text"},{"code":"catch","type":"codeVoice"},{"text":" statement or the caller must handle the error. If the error propagates to the top-level scope without being handled, you’ll get a runtime error.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, the above example can be written so any error that isn’t a "},{"code":"VendingMachineError","type":"codeVoice"},{"type":"text","text":" is instead caught by the calling function:"}],"type":"paragraph"},{"code":["func nourish(with item: String) throws {","    do {","        try vendingMachine.vend(itemNamed: item)","    } catch is VendingMachineError {","        print(\"Couldn't buy that from the vending machine.\")","    }","}","","do {","    try nourish(with: \"Beet-Flavored Chips\")","} catch {","    print(\"Unexpected non-vending-machine-related error: \\(error)\")","}","\/\/ Prints \"Couldn't buy that from the vending machine.\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In the ","type":"text"},{"type":"codeVoice","code":"nourish(with:)"},{"text":" function, if ","type":"text"},{"type":"codeVoice","code":"vend(itemNamed:)"},{"text":" throws an error that’s one of the cases of the ","type":"text"},{"type":"codeVoice","code":"VendingMachineError"},{"text":" enumeration, ","type":"text"},{"type":"codeVoice","code":"nourish(with:)"},{"text":" handles the error by printing a message. Otherwise, ","type":"text"},{"type":"codeVoice","code":"nourish(with:)"},{"text":" propagates the error to its call site. The error is then caught by the general ","type":"text"},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clause."}],"type":"paragraph"},{"inlineContent":[{"text":"Another way to catch several related errors is to list them after ","type":"text"},{"type":"codeVoice","code":"catch"},{"text":", separated by commas. For example:","type":"text"}],"type":"paragraph"},{"code":["func eat(item: String) throws {","    do {","        try vendingMachine.vend(itemNamed: item)","    } catch VendingMachineError.invalidSelection, VendingMachineError.insufficientFunds, VendingMachineError.outOfStock {","        print(\"Invalid selection, out of stock, or not enough money.\")","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"code":"eat(item:)","type":"codeVoice"},{"type":"text","text":" function lists the vending machine errors to catch, and its error text corresponds to the items in that list. If any of the three listed errors are thrown, this "},{"code":"catch","type":"codeVoice"},{"type":"text","text":" clause handles them by printing a message. Any other errors are propagated to the surrounding scope, including any vending-machine errors that might be added later."}],"type":"paragraph"},{"anchor":"Converting-Errors-to-Optional-Values","text":"Converting Errors to Optional Values","level":3,"type":"heading"},{"inlineContent":[{"text":"You use ","type":"text"},{"code":"try?","type":"codeVoice"},{"text":" to handle an error by converting it to an optional value. If an error is thrown while evaluating the ","type":"text"},{"code":"try?","type":"codeVoice"},{"text":" expression, the value of the expression is ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". For example, in the following code ","type":"text"},{"code":"x","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"y","type":"codeVoice"},{"text":" have the same value and behavior:","type":"text"}],"type":"paragraph"},{"code":["func someThrowingFunction() throws -> Int {","    \/\/ ...","}","","let x = try? someThrowingFunction()","","let y: Int?","do {","    y = try someThrowingFunction()","} catch {","    y = nil","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"If ","type":"text"},{"type":"codeVoice","code":"someThrowingFunction()"},{"text":" throws an error, the value of ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":". Otherwise, the value of ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" is the value that the function returned. Note that ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" are an optional of whatever type ","type":"text"},{"type":"codeVoice","code":"someThrowingFunction()"},{"text":" returns. Here the function returns an integer, so ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" are optional integers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Using "},{"type":"codeVoice","code":"try?"},{"type":"text","text":" lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" if all of the approaches fail."}],"type":"paragraph"},{"code":["func fetchData() -> Data? {","    if let data = try? fetchDataFromDisk() { return data }","    if let data = try? fetchDataFromServer() { return data }","    return nil","}"],"syntax":"swift","type":"codeListing"},{"anchor":"Disabling-Error-Propagation","text":"Disabling Error Propagation","level":3,"type":"heading"},{"inlineContent":[{"text":"Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write ","type":"text"},{"code":"try!","type":"codeVoice"},{"text":" before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, the following code uses a "},{"type":"codeVoice","code":"loadImage(atPath:)"},{"type":"text","text":" function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it’s appropriate to disable error propagation."}],"type":"paragraph"},{"code":["let photo = try! loadImage(atPath: \".\/Resources\/John Appleseed.jpg\")"],"syntax":"swift","type":"codeListing"},{"anchor":"Specifying-Cleanup-Actions","text":"Specifying Cleanup Actions","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"You use a "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of "},{"inlineContent":[{"type":"text","text":"how"}],"type":"emphasis"},{"type":"text","text":" execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as "},{"type":"codeVoice","code":"return"},{"type":"text","text":" or "},{"type":"codeVoice","code":"break"},{"type":"text","text":". For example, you can use a "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement to ensure that file descriptors are closed and manually allocated memory is freed."}],"type":"paragraph"},{"inlineContent":[{"text":"A ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" statement defers execution until the current scope is exited. This statement consists of the ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a ","type":"text"},{"code":"break","type":"codeVoice"},{"text":" or a ","type":"text"},{"code":"return","type":"codeVoice"},{"text":" statement, or by throwing an error. Deferred actions are executed in the reverse of the order that they’re written in your source code. That is, the code in the first ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" statement executes last, the code in the second ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" statement executes second to last, and so on. The last ","type":"text"},{"code":"defer","type":"codeVoice"},{"text":" statement in source code order executes first.","type":"text"}],"type":"paragraph"},{"code":["func processFile(filename: String) throws {","    if exists(filename) {","        let file = open(filename)","        defer {","            close(file)","        }","        while let line = try file.readline() {","            \/\/ Work with the file.","        }","        \/\/ close(file) is called here, at the end of the scope.","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The above example uses a "},{"type":"codeVoice","code":"defer"},{"type":"text","text":" statement to ensure that the "},{"type":"codeVoice","code":"open(_:)"},{"type":"text","text":" function has a corresponding call to "},{"type":"codeVoice","code":"close(_:)"},{"type":"text","text":"."}],"type":"paragraph"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"You can use a ","type":"text"},{"type":"codeVoice","code":"defer"},{"text":" statement even when no error handling code is involved.","type":"text"}]}],"type":"aside"}],"kind":"content"}],"references":{"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"url":"\/documentation\/swift\/stringsandcharacters","role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","kind":"article","url":"\/documentation\/swift\/extensions","title":"Extensions"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"title":"Initialization","url":"\/documentation\/swift\/initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"text":"inherit","type":"text"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"text":"subclass","type":"text"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/inheritance","title":"Inheritance","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","url":"\/documentation\/swift\/concurrency","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"type":"text","text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"url":"\/documentation\/swift\/collectiontypes","role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Closures":{"url":"\/documentation\/swift\/closures","role":"article","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Generics":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"url":"\/documentation\/swift\/generics","role":"article","title":"Generics","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","type":"topic","kind":"article"},"https://developer.apple.com/documentation/swift/cocoa_design_patterns/handling_cocoa_errors_in_swift":{"type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/cocoa_design_patterns\/handling_cocoa_errors_in_swift","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/cocoa_design_patterns\/handling_cocoa_errors_in_swift","titleInlineContent":[{"text":"Handling Cocoa Errors in Swift","type":"text"}],"title":"Handling Cocoa Errors in Swift"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"url":"\/documentation\/swift\/advancedoperators","role":"article","title":"Advanced Operators","abstract":[{"type":"text","text":"In addition to the operators described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"title":"Automatic Reference Counting","url":"\/documentation\/swift\/automaticreferencecounting","abstract":[{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"text":"conform","type":"text"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","url":"\/documentation\/swift\/protocols","title":"Protocols"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"title":"Nested Types","url":"\/documentation\/swift\/nestedtypes","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nested types","type":"text"}]},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"role":"article","abstract":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","kind":"article","url":"\/documentation\/swift\/enumerations","title":"Enumerations"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"text":" is called immediately before a class instance is deallocated. You write deinitializers with the ","type":"text"},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","kind":"article","url":"\/documentation\/swift\/deinitialization","title":"Deinitialization"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","url":"\/documentation\/swift\/functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","abstract":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") adds two numbers, as in ","type":"text"},{"code":"let i = 1 + 2","type":"codeVoice"},{"text":", and the logical AND operator (","type":"text"},{"code":"&&","type":"codeVoice"},{"text":") combines two Boolean values, as in ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"text":".","type":"text"}],"kind":"article","url":"\/documentation\/swift\/basicoperators","title":"Basic Operators","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"title":"Subscripts","url":"\/documentation\/swift\/subscripts","abstract":[{"text":"Classes, structures, and enumerations can define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instance as "},{"code":"someArray[index]","type":"codeVoice"},{"type":"text","text":" and elements in a "},{"code":"Dictionary","type":"codeVoice"},{"text":" instance as ","type":"text"},{"type":"codeVoice","code":"someDictionary[key]"},{"text":".","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","url":"\/documentation\/swift\/accesscontrol","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/swift\/optionalchaining","role":"article","title":"Optional Chaining","abstract":[{"inlineContent":[{"text":"Optional chaining","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", the property, method, or subscript call returns "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},"doc://com.apple.Swift/documentation/Swift/Patterns":{"abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" represents the structure of a single value or a composite value. For example, the structure of a tuple ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"text":" is a comma-separated list of two elements. Because patterns represent the structure of a value rather than any one particular value, you can match them with a variety of values. For instance, the pattern ","type":"text"},{"type":"codeVoice","code":"(x, y)"},{"text":" matches the tuple ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"text":" and any other two-element tuple. In addition to matching a pattern with a value, you can extract part or all of a composite value and bind each part to a constant or variable name.","type":"text"}],"url":"\/documentation\/swift\/patterns","role":"article","title":"Patterns","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Patterns","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"title":"Opaque Types","role":"article","kind":"article","url":"\/documentation\/swift\/opaquetypes","type":"topic","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"url":"\/documentation\/swift\/typecasting","role":"article","title":"Type Casting","abstract":[{"inlineContent":[{"type":"text","text":"Type casting"}],"type":"emphasis"},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"classes","type":"text"}]},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","kind":"article","url":"\/documentation\/swift\/classesandstructures","title":"Structures and Classes"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"title":"Memory Safety","url":"\/documentation\/swift\/memorysafety","abstract":[{"text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","role":"article","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","type":"topic"}}}