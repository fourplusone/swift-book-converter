{"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","interfaceLanguage":"swift"},"metadata":{"role":"article","title":"Functions","roleHeading":"Article","modules":[{"name":"Swift"}]},"primaryContentSections":[{"content":[{"level":2,"type":"heading","anchor":"overview","text":"Overview"},{"inlineContent":[{"type":"text","text":"Swift’s unified function syntax is flexible enough to express anything from a simple C-style function with no parameter names to a complex Objective-C-style method with names and argument labels for each parameter. Parameters can provide default values to simplify function calls and can be passed as in-out parameters, which modify a passed variable once the function has completed its execution."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Every function in Swift has a type, consisting of the function’s parameter types and return type. You can use this type like any other type in Swift, which makes it easy to pass functions as parameters to other functions, and to return functions from functions. Functions can also be written within other functions to encapsulate useful functionality within a nested function scope."}],"type":"paragraph"},{"level":2,"type":"heading","anchor":"Defining-and-Calling-Functions","text":"Defining and Calling Functions"},{"inlineContent":[{"type":"text","text":"When you define a function, you can optionally define one or more named, typed values that the function takes as input, known as "},{"type":"emphasis","inlineContent":[{"text":"parameters","type":"text"}]},{"type":"text","text":". You can also optionally define a type of value that the function will pass back as output when it’s done, known as its "},{"type":"emphasis","inlineContent":[{"text":"return type","type":"text"}]},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Every function has a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function name"}]},{"type":"text","text":", which describes the task that the function performs. To use a function, you “call” that function with its name and pass it input values (known as "},{"type":"emphasis","inlineContent":[{"text":"arguments","type":"text"}]},{"type":"text","text":") that match the types of the function’s parameters. A function’s arguments must always be provided in the same order as the function’s parameter list."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The function in the example below is called "},{"type":"codeVoice","code":"greet(person:)"},{"type":"text","text":", because that’s what it does—it takes a person’s name as input and returns a greeting for that person. To accomplish this, you define one input parameter—a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value called "},{"type":"codeVoice","code":"person"},{"type":"text","text":"—and a return type of "},{"type":"codeVoice","code":"String"},{"type":"text","text":", which will contain a greeting for that person:"}],"type":"paragraph"},{"code":["func greet(person: String) -> String {","    let greeting = \"Hello, \" + person + \"!\"","    return greeting","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"All of this information is rolled up into the function’s "},{"type":"emphasis","inlineContent":[{"type":"text","text":"definition"}]},{"type":"text","text":", which is prefixed with the "},{"type":"codeVoice","code":"func"},{"type":"text","text":" keyword. You indicate the function’s return type with the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"return arrow"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"->"},{"type":"text","text":" (a hyphen followed by a right angle bracket), which is followed by the name of the type to return."}],"type":"paragraph"},{"inlineContent":[{"text":"The definition describes what the function does, what it expects to receive, and what it returns when it’s done. The definition makes it easy for the function to be called unambiguously from elsewhere in your code:","type":"text"}],"type":"paragraph"},{"code":["print(greet(person: \"Anna\"))","\/\/ Prints \"Hello, Anna!\"","print(greet(person: \"Brian\"))","\/\/ Prints \"Hello, Brian!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"You call the "},{"type":"codeVoice","code":"greet(person:)"},{"type":"text","text":" function by passing it a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value after the "},{"type":"codeVoice","code":"person"},{"type":"text","text":" argument label, such as "},{"type":"codeVoice","code":"greet(person: \"Anna\")"},{"type":"text","text":". Because the function returns a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value, "},{"type":"codeVoice","code":"greet(person:)"},{"type":"text","text":" can be wrapped in a call to the "},{"type":"codeVoice","code":"print(_:separator:terminator:)"},{"type":"text","text":" function to print that string and see its return value, as shown above."}],"type":"paragraph"},{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"print(_:separator:terminator:)","type":"codeVoice"},{"text":" function doesn’t have a label for its first argument, and its other arguments are optional because they have a default value. These variations on function syntax are discussed below in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Function-Argument-Labels-and-Parameter-Names","type":"reference"},{"text":" and ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Default-Parameter-Values","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}]},{"inlineContent":[{"type":"text","text":"The body of the "},{"code":"greet(person:)","type":"codeVoice"},{"type":"text","text":" function starts by defining a new "},{"code":"String","type":"codeVoice"},{"type":"text","text":" constant called "},{"code":"greeting","type":"codeVoice"},{"type":"text","text":" and setting it to a simple greeting message. This greeting is then passed back out of the function using the "},{"code":"return","type":"codeVoice"},{"type":"text","text":" keyword. In the line of code that says "},{"code":"return greeting","type":"codeVoice"},{"type":"text","text":", the function finishes its execution and returns the current value of "},{"code":"greeting","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"You can call the ","type":"text"},{"type":"codeVoice","code":"greet(person:)"},{"text":" function multiple times with different input values. The example above shows what happens if it’s called with an input value of ","type":"text"},{"type":"codeVoice","code":"\"Anna\""},{"text":", and an input value of ","type":"text"},{"type":"codeVoice","code":"\"Brian\""},{"text":". The function returns a tailored greeting in each case.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"To make the body of this function shorter, you can combine the message creation and the return statement into one line:","type":"text"}],"type":"paragraph"},{"code":["func greetAgain(person: String) -> String {","    return \"Hello again, \" + person + \"!\"","}","print(greetAgain(person: \"Anna\"))","\/\/ Prints \"Hello again, Anna!\""],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","anchor":"Function-Parameters-and-Return-Values","text":"Function Parameters and Return Values"},{"inlineContent":[{"text":"Function parameters and return values are extremely flexible in Swift. You can define anything from a simple utility function with a single unnamed parameter to a complex function with expressive parameter names and different parameter options.","type":"text"}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Functions-Without-Parameters","text":"Functions Without Parameters"},{"inlineContent":[{"text":"Functions aren’t required to define input parameters. Here’s a function with no input parameters, which always returns the same ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" message whenever it’s called:","type":"text"}],"type":"paragraph"},{"code":["func sayHelloWorld() -> String {","    return \"hello, world\"","}","print(sayHelloWorld())","\/\/ Prints \"hello, world\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The function definition still needs parentheses after the function’s name, even though it doesn’t take any parameters. The function name is also followed by an empty pair of parentheses when the function is called."}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Functions-With-Multiple-Parameters","text":"Functions With Multiple Parameters"},{"inlineContent":[{"type":"text","text":"Functions can have multiple input parameters, which are written within the function’s parentheses, separated by commas."}],"type":"paragraph"},{"inlineContent":[{"text":"This function takes a person’s name and whether they have already been greeted as input, and returns an appropriate greeting for that person:","type":"text"}],"type":"paragraph"},{"code":["func greet(person: String, alreadyGreeted: Bool) -> String {","    if alreadyGreeted {","        return greetAgain(person: person)","    } else {","        return greet(person: person)","    }","}","print(greet(person: \"Tim\", alreadyGreeted: true))","\/\/ Prints \"Hello again, Tim!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"You call the "},{"type":"codeVoice","code":"greet(person:alreadyGreeted:)"},{"type":"text","text":" function by passing it both a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" argument value labeled "},{"type":"codeVoice","code":"person"},{"type":"text","text":" and a "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" argument value labeled "},{"type":"codeVoice","code":"alreadyGreeted"},{"type":"text","text":" in parentheses, separated by commas. Note that this function is distinct from the "},{"type":"codeVoice","code":"greet(person:)"},{"type":"text","text":" function shown in an earlier section. Although both functions have names that begin with "},{"type":"codeVoice","code":"greet"},{"type":"text","text":", the "},{"type":"codeVoice","code":"greet(person:alreadyGreeted:)"},{"type":"text","text":" function takes two arguments but the "},{"type":"codeVoice","code":"greet(person:)"},{"type":"text","text":" function takes only one."}],"type":"paragraph"},{"level":3,"type":"heading","anchor":"Functions-Without-Return-Values","text":"Functions Without Return Values"},{"inlineContent":[{"text":"Functions aren’t required to define a return type. Here’s a version of the ","type":"text"},{"code":"greet(person:)","type":"codeVoice"},{"text":" function, which prints its own ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value rather than returning it:","type":"text"}],"type":"paragraph"},{"code":["func greet(person: String) {","    print(\"Hello, \\(person)!\")","}","greet(person: \"Dave\")","\/\/ Prints \"Hello, Dave!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Because it doesn’t need to return a value, the function’s definition doesn’t include the return arrow ("},{"type":"codeVoice","code":"->"},{"type":"text","text":") or a return type."}],"type":"paragraph"},{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"text":"Strictly speaking, this version of the ","type":"text"},{"type":"codeVoice","code":"greet(person:)"},{"text":" function ","type":"text"},{"inlineContent":[{"type":"text","text":"does"}],"type":"emphasis"},{"text":" still return a value, even though no return value is defined. Functions without a defined return type return a special value of type ","type":"text"},{"type":"codeVoice","code":"Void"},{"text":". This is simply an empty tuple, which is written as ","type":"text"},{"type":"codeVoice","code":"()"},{"text":".","type":"text"}],"type":"paragraph"}]},{"inlineContent":[{"text":"The return value of a function can be ignored when it’s called:","type":"text"}],"type":"paragraph"},{"code":["func printAndCount(string: String) -> Int {","    print(string)","    return string.count","}","func printWithoutCounting(string: String) {","    let _ = printAndCount(string: string)","}","printAndCount(string: \"hello, world\")","\/\/ prints \"hello, world\" and returns a value of 12","printWithoutCounting(string: \"hello, world\")","\/\/ prints \"hello, world\" but doesn't return a value"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The first function, "},{"code":"printAndCount(string:)","type":"codeVoice"},{"type":"text","text":", prints a string, and then returns its character count as an "},{"code":"Int","type":"codeVoice"},{"type":"text","text":". The second function, "},{"code":"printWithoutCounting(string:)","type":"codeVoice"},{"type":"text","text":", calls the first function, but ignores its return value. When the second function is called, the message is still printed by the first function, but the returned value isn’t used."}],"type":"paragraph"},{"style":"note","name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Return values can be ignored, but a function that says it will return a value must always do so. A function with a defined return type can’t allow control to fall out of the bottom of the function without returning a value, and attempting to do so will result in a compile-time error."}]}]},{"level":3,"type":"heading","anchor":"Functions-with-Multiple-Return-Values","text":"Functions with Multiple Return Values"},{"inlineContent":[{"type":"text","text":"You can use a tuple type as the return type for a function to return multiple values as part of one compound return value."}],"type":"paragraph"},{"inlineContent":[{"text":"The example below defines a function called ","type":"text"},{"code":"minMax(array:)","type":"codeVoice"},{"text":", which finds the smallest and largest numbers in an array of ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" values:","type":"text"}],"type":"paragraph"},{"code":["func minMax(array: [Int]) -> (min: Int, max: Int) {","    var currentMin = array[0]","    var currentMax = array[0]","    for value in array[1..<array.count] {","        if value < currentMin {","            currentMin = value","        } else if value > currentMax {","            currentMax = value","        }","    }","    return (currentMin, currentMax)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"minMax(array:)"},{"type":"text","text":" function returns a tuple containing two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values. These values are labeled "},{"type":"codeVoice","code":"min"},{"type":"text","text":" and "},{"type":"codeVoice","code":"max"},{"type":"text","text":" so that they can be accessed by name when querying the function’s return value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The body of the "},{"code":"minMax(array:)","type":"codeVoice"},{"type":"text","text":" function starts by setting two working variables called "},{"type":"codeVoice","code":"currentMin"},{"type":"text","text":" and "},{"type":"codeVoice","code":"currentMax"},{"type":"text","text":" to the value of the first integer in the array. The function then iterates over the remaining values in the array and checks each value to see if it’s smaller or larger than the values of "},{"type":"codeVoice","code":"currentMin"},{"type":"text","text":" and "},{"type":"codeVoice","code":"currentMax"},{"type":"text","text":" respectively. Finally, the overall minimum and maximum values are returned as a tuple of two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values."}]},{"type":"paragraph","inlineContent":[{"text":"Because the tuple’s member values are named as part of the function’s return type, they can be accessed with dot syntax to retrieve the minimum and maximum found values:","type":"text"}]},{"syntax":"swift","code":["let bounds = minMax(array: [8, -6, 2, 109, 3, 71])","print(\"min is \\(bounds.min) and max is \\(bounds.max)\")","\/\/ Prints \"min is -6 and max is 109\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Note that the tuple’s members don’t need to be named at the point that the tuple is returned from the function, because their names are already specified as part of the function’s return type.","type":"text"}]},{"anchor":"Optional-Tuple-Return-Types","level":4,"text":"Optional Tuple Return Types","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"If the tuple type to be returned from a function has the potential to have “no value” for the entire tuple, you can use an ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional"}]},{"text":" tuple return type to reflect the fact that the entire tuple can be ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". You write an optional tuple return type by placing a question mark after the tuple type’s closing parenthesis, such as ","type":"text"},{"code":"(Int, Int)?","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"(String, Int, Bool)?","type":"codeVoice"},{"text":".","type":"text"}]},{"name":"Note","content":[{"inlineContent":[{"text":"An optional tuple type such as ","type":"text"},{"type":"codeVoice","code":"(Int, Int)?"},{"text":" is different from a tuple that contains optional types such as ","type":"text"},{"type":"codeVoice","code":"(Int?, Int?)"},{"text":". With an optional tuple type, the entire tuple is optional, not just each individual value within the tuple.","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"minMax(array:)","type":"codeVoice"},{"type":"text","text":" function above returns a tuple containing two "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values. However, the function doesn’t perform any safety checks on the array it’s passed. If the "},{"code":"array","type":"codeVoice"},{"type":"text","text":" argument contains an empty array, the "},{"code":"minMax(array:)","type":"codeVoice"},{"type":"text","text":" function, as defined above, will trigger a runtime error when attempting to access "},{"code":"array[0]","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To handle an empty array safely, write the "},{"code":"minMax(array:)","type":"codeVoice"},{"type":"text","text":" function with an optional tuple return type and return a value of "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" when the array is empty:"}]},{"syntax":"swift","code":["func minMax(array: [Int]) -> (min: Int, max: Int)? {","    if array.isEmpty { return nil }","    var currentMin = array[0]","    var currentMax = array[0]","    for value in array[1..<array.count] {","        if value < currentMin {","            currentMin = value","        } else if value > currentMax {","            currentMax = value","        }","    }","    return (currentMin, currentMax)","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"You can use optional binding to check whether this version of the ","type":"text"},{"code":"minMax(array:)","type":"codeVoice"},{"text":" function returns an actual tuple value or ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {","    print(\"min is \\(bounds.min) and max is \\(bounds.max)\")","}","\/\/ Prints \"min is -6 and max is 109\""],"type":"codeListing"},{"anchor":"Functions-With-an-Implicit-Return","level":3,"text":"Functions With an Implicit Return","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the entire body of the function is a single expression, the function implicitly returns that expression. For example, both functions below have the same behavior:"}]},{"syntax":"swift","code":["func greeting(for person: String) -> String {","    \"Hello, \" + person + \"!\"","}","print(greeting(for: \"Dave\"))","\/\/ Prints \"Hello, Dave!\"","","func anotherGreeting(for person: String) -> String {","    return \"Hello, \" + person + \"!\"","}","print(anotherGreeting(for: \"Dave\"))","\/\/ Prints \"Hello, Dave!\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The entire definition of the "},{"type":"codeVoice","code":"greeting(for:)"},{"type":"text","text":" function is the greeting message that it returns, which means it can use this shorter form. The "},{"type":"codeVoice","code":"anotherGreeting(for:)"},{"type":"text","text":" function returns the same greeting message, using the "},{"type":"codeVoice","code":"return"},{"type":"text","text":" keyword like a longer function. Any function that you write as just one "},{"type":"codeVoice","code":"return"},{"type":"text","text":" line can omit the "},{"type":"codeVoice","code":"return"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As you’ll see in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties#Shorthand-Getter-Declaration","isActive":true,"type":"reference"},{"type":"text","text":", property getters can also use an implicit return."}]},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The code you write as an implicit return value needs to return some value. For example, you can’t use "},{"type":"codeVoice","code":"print(13)"},{"type":"text","text":" as an implicit return value. However, you can use a function that never returns like "},{"type":"codeVoice","code":"fatalError(\"Oh no!\")"},{"type":"text","text":" as an implicit return value, because Swift knows that the implicit return doesn’t happen."}]}],"style":"note","type":"aside"},{"anchor":"Function-Argument-Labels-and-Parameter-Names","level":2,"text":"Function Argument Labels and Parameter Names","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each function parameter has both an "},{"type":"emphasis","inlineContent":[{"text":"argument label","type":"text"}]},{"type":"text","text":" and a "},{"type":"emphasis","inlineContent":[{"text":"parameter name","type":"text"}]},{"type":"text","text":". The argument label is used when calling the function; each argument is written in the function call with its argument label before it. The parameter name is used in the implementation of the function. By default, parameters use their parameter name as their argument label."}]},{"syntax":"swift","code":["func someFunction(firstParameterName: Int, secondParameterName: Int) {","    \/\/ In the function body, firstParameterName and secondParameterName","    \/\/ refer to the argument values for the first and second parameters.","}","someFunction(firstParameterName: 1, secondParameterName: 2)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All parameters must have unique names. Although it’s possible for multiple parameters to have the same argument label, unique argument labels help make your code more readable."}]},{"anchor":"Specifying-Argument-Labels","level":3,"text":"Specifying Argument Labels","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You write an argument label before the parameter name, separated by a space:","type":"text"}]},{"syntax":"swift","code":["func someFunction(argumentLabel parameterName: Int) {","    \/\/ In the function body, parameterName refers to the argument value","    \/\/ for that parameter.","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a variation of the "},{"type":"codeVoice","code":"greet(person:)"},{"type":"text","text":" function that takes a person’s name and hometown and returns a greeting:"}]},{"syntax":"swift","code":["func greet(person: String, from hometown: String) -> String {","    return \"Hello \\(person)!  Glad you could visit from \\(hometown).\"","}","print(greet(person: \"Bill\", from: \"Cupertino\"))","\/\/ Prints \"Hello Bill!  Glad you could visit from Cupertino.\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The use of argument labels can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that’s readable and clear in intent.","type":"text"}]},{"anchor":"Omitting-Argument-Labels","level":3,"text":"Omitting Argument Labels","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you don’t want an argument label for a parameter, write an underscore ("},{"type":"codeVoice","code":"_"},{"type":"text","text":") instead of an explicit argument label for that parameter."}]},{"syntax":"swift","code":["func someFunction(_ firstParameterName: Int, secondParameterName: Int) {","    \/\/ In the function body, firstParameterName and secondParameterName","    \/\/ refer to the argument values for the first and second parameters.","}","someFunction(1, secondParameterName: 2)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"If a parameter has an argument label, the argument ","type":"text"},{"inlineContent":[{"text":"must","type":"text"}],"type":"emphasis"},{"text":" be labeled when you call the function.","type":"text"}]},{"anchor":"Default-Parameter-Values","level":3,"text":"Default Parameter Values","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can define a ","type":"text"},{"inlineContent":[{"type":"text","text":"default value"}],"type":"emphasis"},{"text":" for any parameter in a function by assigning a value to the parameter after that parameter’s type. If a default value is defined, you can omit that parameter when calling the function.","type":"text"}]},{"syntax":"swift","code":["func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {","    \/\/ If you omit the second argument when calling this function, then","    \/\/ the value of parameterWithDefault is 12 inside the function body.","}","someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) \/\/ parameterWithDefault is 6","someFunction(parameterWithoutDefault: 4) \/\/ parameterWithDefault is 12"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Place parameters that don’t have default values at the beginning of a function’s parameter list, before the parameters that have default values. Parameters that don’t have default values are usually more important to the function’s meaning—writing them first makes it easier to recognize that the same function is being called, regardless of whether any default parameters are omitted.","type":"text"}]},{"anchor":"Variadic-Parameters","level":3,"text":"Variadic Parameters","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"variadic parameter","type":"text"}]},{"type":"text","text":" accepts zero or more values of a specified type. You use a variadic parameter to specify that the parameter can be passed a varying number of input values when the function is called. Write variadic parameters by inserting three period characters ("},{"type":"codeVoice","code":"..."},{"type":"text","text":") after the parameter’s type name."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The values passed to a variadic parameter are made available within the function’s body as an array of the appropriate type. For example, a variadic parameter with a name of "},{"code":"numbers","type":"codeVoice"},{"type":"text","text":" and a type of "},{"code":"Double...","type":"codeVoice"},{"type":"text","text":" is made available within the function’s body as a constant array called "},{"code":"numbers","type":"codeVoice"},{"type":"text","text":" of type "},{"code":"[Double]","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below calculates the "},{"inlineContent":[{"type":"text","text":"arithmetic mean"}],"type":"emphasis"},{"type":"text","text":" (also known as the "},{"inlineContent":[{"text":"average","type":"text"}],"type":"emphasis"},{"type":"text","text":") for a list of numbers of any length:"}]},{"syntax":"swift","code":["func arithmeticMean(_ numbers: Double...) -> Double {","    var total: Double = 0","    for number in numbers {","        total += number","    }","    return total \/ Double(numbers.count)","}","arithmeticMean(1, 2, 3, 4, 5)","\/\/ returns 3.0, which is the arithmetic mean of these five numbers","arithmeticMean(3, 8.25, 18.75)","\/\/ returns 10.0, which is the arithmetic mean of these three numbers"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"A function can have multiple variadic parameters. The first parameter that comes after a variadic parameter must have an argument label. The argument label makes it unambiguous which arguments are passed to the variadic parameter and which arguments are passed to the parameters that come after the variadic parameter.","type":"text"}]},{"anchor":"In-Out-Parameters","level":3,"text":"In-Out Parameters","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Function parameters are constants by default. Trying to change the value of a function parameter from within the body of that function results in a compile-time error. This means that you can’t change the value of a parameter by mistake. If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an ","type":"text"},{"inlineContent":[{"type":"text","text":"in-out parameter"}],"type":"emphasis"},{"text":" instead.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You write an in-out parameter by placing the ","type":"text"},{"code":"inout","type":"codeVoice"},{"text":" keyword right before a parameter’s type. An in-out parameter has a value that’s passed ","type":"text"},{"inlineContent":[{"type":"text","text":"in"}],"type":"emphasis"},{"text":" to the function, is modified by the function, and is passed back ","type":"text"},{"inlineContent":[{"text":"out","type":"text"}],"type":"emphasis"},{"text":" of the function to replace the original value. For a detailed discussion of the behavior of in-out parameters and associated compiler optimizations, see ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#In-Out-Parameters","type":"reference"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can only pass a variable as the argument for an in-out parameter. You can’t pass a constant or a literal value as the argument, because constants and literals can’t be modified. You place an ampersand (","type":"text"},{"type":"codeVoice","code":"&"},{"text":") directly before a variable’s name when you pass it as an argument to an in-out parameter, to indicate that it can be modified by the function.","type":"text"}]},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In-out parameters can’t have default values, and variadic parameters can’t be marked as "},{"code":"inout","type":"codeVoice"},{"type":"text","text":"."}]}],"style":"note","type":"aside"},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of a function called ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":", which has two in-out integer parameters called ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"b","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["func swapTwoInts(_ a: inout Int, _ b: inout Int) {","    let temporaryA = a","    a = b","    b = temporaryA","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function simply swaps the value of ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" into ","type":"text"},{"code":"a","type":"codeVoice"},{"text":", and the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" into ","type":"text"},{"code":"b","type":"codeVoice"},{"text":". The function performs this swap by storing the value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" in a temporary constant called ","type":"text"},{"code":"temporaryA","type":"codeVoice"},{"text":", assigning the value of ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"a","type":"codeVoice"},{"text":", and then assigning ","type":"text"},{"code":"temporaryA","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"b","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can call the ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function with two variables of type ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" to swap their values. Note that the names of ","type":"text"},{"code":"someInt","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"anotherInt","type":"codeVoice"},{"text":" are prefixed with an ampersand when they’re passed to the ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function:","type":"text"}]},{"syntax":"swift","code":["var someInt = 3","var anotherInt = 107","swapTwoInts(&someInt, &anotherInt)","print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")","\/\/ Prints \"someInt is now 107, and anotherInt is now 3\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above shows that the original values of "},{"type":"codeVoice","code":"someInt"},{"type":"text","text":" and "},{"type":"codeVoice","code":"anotherInt"},{"type":"text","text":" are modified by the "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":" function, even though they were originally defined outside of the function."}]},{"name":"Note","content":[{"inlineContent":[{"text":"In-out parameters aren’t the same as returning a value from a function. The ","type":"text"},{"code":"swapTwoInts","type":"codeVoice"},{"text":" example above doesn’t define a return type or return a value, but it still modifies the values of ","type":"text"},{"code":"someInt","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"anotherInt","type":"codeVoice"},{"text":". In-out parameters are an alternative way for a function to have an effect outside of the scope of its function body.","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside"},{"anchor":"Function-Types","level":2,"text":"Function Types","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every function has a specific "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function type"}]},{"type":"text","text":", made up of the parameter types and the return type of the function."}]},{"type":"paragraph","inlineContent":[{"text":"For example:","type":"text"}]},{"syntax":"swift","code":["func addTwoInts(_ a: Int, _ b: Int) -> Int {","    return a + b","}","func multiplyTwoInts(_ a: Int, _ b: Int) -> Int {","    return a * b","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This example defines two simple mathematical functions called ","type":"text"},{"code":"addTwoInts","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"multiplyTwoInts","type":"codeVoice"},{"text":". These functions each take two ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" values, and return an ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" value, which is the result of performing an appropriate mathematical operation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The type of both of these functions is ","type":"text"},{"code":"(Int, Int) -> Int","type":"codeVoice"},{"text":". This can be read as:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"“A function that has two parameters, both of type "},{"code":"Int","type":"codeVoice"},{"type":"text","text":", and that returns a value of type "},{"code":"Int","type":"codeVoice"},{"type":"text","text":".”"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s another example, for a function with no parameters or return value:"}]},{"syntax":"swift","code":["func printHelloWorld() {","    print(\"hello, world\")","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The type of this function is ","type":"text"},{"code":"() -> Void","type":"codeVoice"},{"text":", or “a function that has no parameters, and returns ","type":"text"},{"code":"Void","type":"codeVoice"},{"text":".”","type":"text"}]},{"anchor":"Using-Function-Types","level":3,"text":"Using Function Types","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You use function types just like any other types in Swift. For example, you can define a constant or variable to be of a function type and assign an appropriate function to that variable:"}]},{"syntax":"swift","code":["var mathFunction: (Int, Int) -> Int = addTwoInts"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This can be read as:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"“Define a variable called "},{"type":"codeVoice","code":"mathFunction"},{"type":"text","text":", which has a type of ‘a function that takes two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values, and returns an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value.’ Set this new variable to refer to the function called "},{"type":"codeVoice","code":"addTwoInts"},{"type":"text","text":".”"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"addTwoInts(_:_:)"},{"text":" function has the same type as the ","type":"text"},{"type":"codeVoice","code":"mathFunction"},{"text":" variable, and so this assignment is allowed by Swift’s type-checker.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can now call the assigned function with the name ","type":"text"},{"code":"mathFunction","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["print(\"Result: \\(mathFunction(2, 3))\")","\/\/ Prints \"Result: 5\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"A different function with the same matching type can be assigned to the same variable, in the same way as for nonfunction types:","type":"text"}]},{"syntax":"swift","code":["mathFunction = multiplyTwoInts","print(\"Result: \\(mathFunction(2, 3))\")","\/\/ Prints \"Result: 6\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with any other type, you can leave it to Swift to infer the function type when you assign a function to a constant or variable:"}]},{"syntax":"swift","code":["let anotherMathFunction = addTwoInts","\/\/ anotherMathFunction is inferred to be of type (Int, Int) -> Int"],"type":"codeListing"},{"anchor":"Function-Types-as-Parameter-Types","level":3,"text":"Function Types as Parameter Types","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use a function type such as "},{"type":"codeVoice","code":"(Int, Int) -> Int"},{"type":"text","text":" as a parameter type for another function. This enables you to leave some aspects of a function’s implementation for the function’s caller to provide when the function is called."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example to print the results of the math functions from above:"}]},{"syntax":"swift","code":["func printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {","    print(\"Result: \\(mathFunction(a, b))\")","}","printMathResult(addTwoInts, 3, 5)","\/\/ Prints \"Result: 8\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example defines a function called "},{"code":"printMathResult(_:_:_:)","type":"codeVoice"},{"type":"text","text":", which has three parameters. The first parameter is called "},{"code":"mathFunction","type":"codeVoice"},{"type":"text","text":", and is of type "},{"code":"(Int, Int) -> Int","type":"codeVoice"},{"type":"text","text":". You can pass any function of that type as the argument for this first parameter. The second and third parameters are called "},{"code":"a","type":"codeVoice"},{"type":"text","text":" and "},{"code":"b","type":"codeVoice"},{"type":"text","text":", and are both of type "},{"code":"Int","type":"codeVoice"},{"type":"text","text":". These are used as the two input values for the provided math function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When "},{"type":"codeVoice","code":"printMathResult(_:_:_:)"},{"type":"text","text":" is called, it’s passed the "},{"type":"codeVoice","code":"addTwoInts(_:_:)"},{"type":"text","text":" function, and the integer values "},{"type":"codeVoice","code":"3"},{"type":"text","text":" and "},{"type":"codeVoice","code":"5"},{"type":"text","text":". It calls the provided function with the values "},{"type":"codeVoice","code":"3"},{"type":"text","text":" and "},{"type":"codeVoice","code":"5"},{"type":"text","text":", and prints the result of "},{"type":"codeVoice","code":"8"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The role of "},{"type":"codeVoice","code":"printMathResult(_:_:_:)"},{"type":"text","text":" is to print the result of a call to a math function of an appropriate type. It doesn’t matter what that function’s implementation actually does—it matters only that the function is of the correct type. This enables "},{"type":"codeVoice","code":"printMathResult(_:_:_:)"},{"type":"text","text":" to hand off some of its functionality to the caller of the function in a type-safe way."}]},{"anchor":"Function-Types-as-Return-Types","level":3,"text":"Function Types as Return Types","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"You can use a function type as the return type of another function. You do this by writing a complete function type immediately after the return arrow (","type":"text"},{"code":"->","type":"codeVoice"},{"text":") of the returning function.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The next example defines two simple functions called ","type":"text"},{"code":"stepForward(_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"stepBackward(_:)","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"stepForward(_:)","type":"codeVoice"},{"text":" function returns a value one more than its input value, and the ","type":"text"},{"code":"stepBackward(_:)","type":"codeVoice"},{"text":" function returns a value one less than its input value. Both functions have a type of ","type":"text"},{"code":"(Int) -> Int","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["func stepForward(_ input: Int) -> Int {","    return input + 1","}","func stepBackward(_ input: Int) -> Int {","    return input - 1","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Here’s a function called ","type":"text"},{"code":"chooseStepFunction(backward:)","type":"codeVoice"},{"text":", whose return type is ","type":"text"},{"code":"(Int) -> Int","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"chooseStepFunction(backward:)","type":"codeVoice"},{"text":" function returns the ","type":"text"},{"code":"stepForward(_:)","type":"codeVoice"},{"text":" function or the ","type":"text"},{"code":"stepBackward(_:)","type":"codeVoice"},{"text":" function based on a Boolean parameter called ","type":"text"},{"code":"backward","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","code":["func chooseStepFunction(backward: Bool) -> (Int) -> Int {","    return backward ? stepBackward : stepForward","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"You can now use ","type":"text"},{"code":"chooseStepFunction(backward:)","type":"codeVoice"},{"text":" to obtain a function that will step in one direction or the other:","type":"text"}]},{"syntax":"swift","code":["var currentValue = 3","let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)","\/\/ moveNearerToZero now refers to the stepBackward() function"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above determines whether a positive or negative step is needed to move a variable called "},{"type":"codeVoice","code":"currentValue"},{"type":"text","text":" progressively closer to zero. "},{"type":"codeVoice","code":"currentValue"},{"type":"text","text":" has an initial value of "},{"type":"codeVoice","code":"3"},{"type":"text","text":", which means that "},{"type":"codeVoice","code":"currentValue > 0"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"true"},{"type":"text","text":", causing "},{"type":"codeVoice","code":"chooseStepFunction(backward:)"},{"type":"text","text":" to return the "},{"type":"codeVoice","code":"stepBackward(_:)"},{"type":"text","text":" function. A reference to the returned function is stored in a constant called "},{"type":"codeVoice","code":"moveNearerToZero"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that "},{"code":"moveNearerToZero","type":"codeVoice"},{"type":"text","text":" refers to the correct function, it can be used to count to zero:"}]},{"syntax":"swift","code":["print(\"Counting to zero:\")","\/\/ Counting to zero:","while currentValue != 0 {","    print(\"\\(currentValue)... \")","    currentValue = moveNearerToZero(currentValue)","}","print(\"zero!\")","\/\/ 3...","\/\/ 2...","\/\/ 1...","\/\/ zero!"],"type":"codeListing"},{"anchor":"Nested-Functions","level":2,"text":"Nested Functions","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of the functions you have encountered so far in this chapter have been examples of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"global functions"}]},{"type":"text","text":", which are defined at a global scope. You can also define functions inside the bodies of other functions, known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"nested functions"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nested functions are hidden from the outside world by default, but can still be called and used by their enclosing function. An enclosing function can also return one of its nested functions to allow the nested function to be used in another scope."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can rewrite the "},{"type":"codeVoice","code":"chooseStepFunction(backward:)"},{"type":"text","text":" example above to use and return nested functions:"}]},{"syntax":"swift","code":["func chooseStepFunction(backward: Bool) -> (Int) -> Int {","    func stepForward(input: Int) -> Int { return input + 1 }","    func stepBackward(input: Int) -> Int { return input - 1 }","    return backward ? stepBackward : stepForward","}","var currentValue = -4","let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)","\/\/ moveNearerToZero now refers to the nested stepForward() function","while currentValue != 0 {","    print(\"\\(currentValue)... \")","    currentValue = moveNearerToZero(currentValue)","}","print(\"zero!\")","\/\/ -4...","\/\/ -3...","\/\/ -2...","\/\/ -1...","\/\/ zero!"],"type":"codeListing"}],"kind":"content"}],"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/functions"]}],"seeAlsoSections":[{"title":"Language Guide","generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"abstract":[{"inlineContent":[{"text":"Functions","type":"text"}],"type":"emphasis"},{"text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.","type":"text"}],"references":{"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"title":"Automatic Reference Counting","url":"\/documentation\/swift\/automaticreferencecounting","abstract":[{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Properties#Shorthand-Getter-Declaration":{"title":"Shorthand Getter Declaration","url":"\/documentation\/swift\/properties#Shorthand-Getter-Declaration","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties#Shorthand-Getter-Declaration","abstract":[],"kind":"section"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"url":"\/documentation\/swift\/stringsandcharacters","role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","role":"article","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Generics":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"url":"\/documentation\/swift\/generics","role":"article","title":"Generics","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Declarations#In-Out-Parameters":{"type":"topic","kind":"section","title":"In-Out Parameters","url":"\/documentation\/swift\/declarations#In-Out-Parameters","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#In-Out-Parameters","abstract":[]},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"text":" is called immediately before a class instance is deallocated. You write deinitializers with the ","type":"text"},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","kind":"article","url":"\/documentation\/swift\/deinitialization","title":"Deinitialization"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","url":"\/documentation\/swift\/accesscontrol","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"title":"Initialization","url":"\/documentation\/swift\/initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","kind":"article","url":"\/documentation\/swift\/extensions","title":"Extensions"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"text":"conform","type":"text"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","url":"\/documentation\/swift\/protocols","title":"Protocols"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"title":"Nested Types","url":"\/documentation\/swift\/nestedtypes","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nested types","type":"text"}]},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Functions#Function-Argument-Labels-and-Parameter-Names":{"title":"Function Argument Labels and Parameter Names","url":"\/documentation\/swift\/functions#Function-Argument-Labels-and-Parameter-Names","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Function-Argument-Labels-and-Parameter-Names","abstract":[],"kind":"section"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"url":"\/documentation\/swift\/typecasting","role":"article","title":"Type Casting","abstract":[{"inlineContent":[{"type":"text","text":"Type casting"}],"type":"emphasis"},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","abstract":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") adds two numbers, as in ","type":"text"},{"code":"let i = 1 + 2","type":"codeVoice"},{"text":", and the logical AND operator (","type":"text"},{"code":"&&","type":"codeVoice"},{"text":") combines two Boolean values, as in ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"text":".","type":"text"}],"kind":"article","url":"\/documentation\/swift\/basicoperators","title":"Basic Operators","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"url":"\/documentation\/swift\/collectiontypes","role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","url":"\/documentation\/swift\/concurrency","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"type":"text","text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"url":"\/documentation\/swift\/advancedoperators","role":"article","title":"Advanced Operators","abstract":[{"type":"text","text":"In addition to the operators described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Functions#Default-Parameter-Values":{"abstract":[],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Default-Parameter-Values","title":"Default Parameter Values","kind":"section","url":"\/documentation\/swift\/functions#Default-Parameter-Values"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"title":"Subscripts","url":"\/documentation\/swift\/subscripts","abstract":[{"text":"Classes, structures, and enumerations can define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instance as "},{"code":"someArray[index]","type":"codeVoice"},{"type":"text","text":" and elements in a "},{"code":"Dictionary","type":"codeVoice"},{"text":" instance as ","type":"text"},{"type":"codeVoice","code":"someDictionary[key]"},{"text":".","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"title":"Memory Safety","url":"\/documentation\/swift\/memorysafety","abstract":[{"text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"title":"Opaque Types","role":"article","kind":"article","url":"\/documentation\/swift\/opaquetypes","type":"topic","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"text":"inherit","type":"text"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"text":"subclass","type":"text"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/inheritance","title":"Inheritance","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/swift\/optionalchaining","role":"article","title":"Optional Chaining","abstract":[{"inlineContent":[{"text":"Optional chaining","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", the property, method, or subscript call returns "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"url":"\/documentation\/swift\/errorhandling","role":"article","title":"Error Handling","abstract":[{"inlineContent":[{"type":"text","text":"Error handling"}],"type":"emphasis"},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"role":"article","abstract":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","kind":"article","url":"\/documentation\/swift\/enumerations","title":"Enumerations"},"doc://com.apple.Swift/documentation/Swift/Closures":{"url":"\/documentation\/swift\/closures","role":"article","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"classes","type":"text"}]},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","kind":"article","url":"\/documentation\/swift\/classesandstructures","title":"Structures and Classes"}}}