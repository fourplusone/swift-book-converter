{"sections":[],"abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"string"}],"type":"emphasis"},{"text":" is a series of characters, such as ","type":"text"},{"type":"codeVoice","code":"\"hello, world\""},{"text":" or ","type":"text"},{"type":"codeVoice","code":"\"albatross\""},{"text":". Swift strings are represented by the ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/stringsandcharacters"]}],"seeAlsoSections":[{"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"generated":true,"title":"Language Guide"}],"metadata":{"title":"Strings and Characters","modules":[{"name":"Swift"}],"roleHeading":"Article","role":"article"},"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s "},{"type":"codeVoice","code":"String"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" types provide a fast, Unicode-compliant way to work with text in your code. The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that’s similar to C. String concatenation is as simple as combining two strings with the "},{"type":"codeVoice","code":"+"},{"type":"text","text":" operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift. You can also use strings to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation. This makes it easy to create custom string values for display, storage, and printing."}]},{"type":"paragraph","inlineContent":[{"text":"Despite this simplicity of syntax, Swift’s ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type is a fast, modern string implementation. Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.","type":"text"}]},{"name":"Note","content":[{"inlineContent":[{"type":"text","text":"Swift’s "},{"code":"String","type":"codeVoice"},{"type":"text","text":" type is bridged with Foundation’s "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":" class. Foundation also extends "},{"code":"String","type":"codeVoice"},{"type":"text","text":" to expose methods defined by "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":". This means, if you import Foundation, you can access those "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":" methods on "},{"code":"String","type":"codeVoice"},{"type":"text","text":" without casting."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For more information about using "},{"code":"String","type":"codeVoice"},{"type":"text","text":" with Foundation and Cocoa, see "},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/string#2919514","isActive":true,"type":"reference"},{"type":"text","text":" [https:\/\/developer.apple.com\/documentation\/swift\/string#2919514]"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside","style":"note"},{"level":2,"text":"String Literals","type":"heading","anchor":"String-Literals"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can include predefined "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values within your code as "},{"type":"emphasis","inlineContent":[{"text":"string literals","type":"text"}]},{"type":"text","text":". A string literal is a sequence of characters surrounded by double quotation marks ("},{"code":"\"","type":"codeVoice"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"text":"Use a string literal as an initial value for a constant or variable:","type":"text"}]},{"syntax":"swift","code":["let someString = \"Some string literal value\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that Swift infers a type of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" for the "},{"type":"codeVoice","code":"someString"},{"type":"text","text":" constant because it’s initialized with a string literal value."}]},{"text":"Multiline String Literals","anchor":"Multiline-String-Literals","level":3,"type":"heading"},{"inlineContent":[{"type":"text","text":"If you need a string that spans several lines, use a multiline string literal—a sequence of characters surrounded by three double quotation marks:"}],"type":"paragraph"},{"syntax":"swift","code":["let quotation = \"\"\"","The White Rabbit put on his spectacles.  \"Where shall I begin,","please your Majesty?\" he asked.","","\"Begin at the beginning,\" the King said gravely, \"and go on","till you come to the end; then stop.\"","\"\"\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"A multiline string literal includes all of the lines between its opening and closing quotation marks. The string begins on the first line after the opening quotation marks ("},{"type":"codeVoice","code":"\"\"\""},{"type":"text","text":") and ends on the line before the closing quotation marks, which means that neither of the strings below start or end with a line break:"}],"type":"paragraph"},{"syntax":"swift","code":["let singleLineString = \"These are the same.\"","let multilineString = \"\"\"","These are the same.","\"\"\""],"type":"codeListing"},{"inlineContent":[{"text":"When your source code includes a line break inside of a multiline string literal, that line break also appears in the string’s value. If you want to use line breaks to make your source code easier to read, but you don’t want the line breaks to be part of the string’s value, write a backslash (","type":"text"},{"code":"\\","type":"codeVoice"},{"text":") at the end of those lines:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let softWrappedQuotation = \"\"\"","The White Rabbit put on his spectacles.  \"Where shall I begin, \\","please your Majesty?\" he asked.","","\"Begin at the beginning,\" the King said gravely, \"and go on \\","till you come to the end; then stop.\"","\"\"\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"To make a multiline string literal that begins or ends with a line feed, write a blank line as the first or last line. For example:"}],"type":"paragraph"},{"syntax":"swift","code":["let lineBreaks = \"\"\"","","This string starts with a line break.","It also ends with a line break.","","\"\"\""],"type":"codeListing"},{"inlineContent":[{"text":"A multiline string can be indented to match the surrounding code. The whitespace before the closing quotation marks (","type":"text"},{"code":"\"\"\"","type":"codeVoice"},{"text":") tells Swift what whitespace to ignore before all of the other lines. However, if you write whitespace at the beginning of a line in addition to what’s before the closing quotation marks, that whitespace ","type":"text"},{"inlineContent":[{"text":"is","type":"text"}],"type":"emphasis"},{"text":" included.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"multilineStringWhitespace","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"In the example above, even though the entire multiline string literal is indented, the first and last lines in the string don’t begin with any whitespace. The middle line has more indentation than the closing quotation marks, so it starts with that extra four-space indentation.","type":"text"}],"type":"paragraph"},{"text":"Special Characters in String Literals","level":3,"anchor":"Special-Characters-in-String-Literals","type":"heading"},{"inlineContent":[{"text":"String literals can include the following special characters:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The escaped special characters "},{"code":"\\0","type":"codeVoice"},{"type":"text","text":" (null character), "},{"code":"\\\\","type":"codeVoice"},{"type":"text","text":" (backslash), "},{"code":"\\t","type":"codeVoice"},{"type":"text","text":" (horizontal tab), "},{"code":"\\n","type":"codeVoice"},{"type":"text","text":" (line feed), "},{"code":"\\r","type":"codeVoice"},{"type":"text","text":" (carriage return), "},{"code":"\\\"","type":"codeVoice"},{"type":"text","text":" (double quotation mark) and "},{"code":"\\'","type":"codeVoice"},{"type":"text","text":" (single quotation mark)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An arbitrary Unicode scalar value, written as "},{"code":"\\u{","type":"codeVoice"},{"inlineContent":[{"text":"n","type":"text"}],"type":"emphasis"},{"code":"}","type":"codeVoice"},{"type":"text","text":", where "},{"inlineContent":[{"text":"n","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a 1–8 digit hexadecimal number (Unicode is discussed in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters#Unicode","type":"reference","isActive":true},{"type":"text","text":" below)"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The code below shows four examples of these special characters. The ","type":"text"},{"code":"wiseWords","type":"codeVoice"},{"text":" constant contains two escaped double quotation marks. The ","type":"text"},{"code":"dollarSign","type":"codeVoice"},{"text":", ","type":"text"},{"code":"blackHeart","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"sparklingHeart","type":"codeVoice"},{"text":" constants demonstrate the Unicode scalar format:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let wiseWords = \"\\\"Imagination is more important than knowledge\\\" - Einstein\"","\/\/ \"Imagination is more important than knowledge\" - Einstein","let dollarSign = \"\\u{24}\"        \/\/ $,  Unicode scalar U+0024","let blackHeart = \"\\u{2665}\"      \/\/ ♥,  Unicode scalar U+2665","let sparklingHeart = \"\\u{1F496}\" \/\/ 💖, Unicode scalar U+1F496"]},{"inlineContent":[{"text":"Because multiline string literals use three double quotation marks instead of just one, you can include a double quotation mark (","type":"text"},{"code":"\"","type":"codeVoice"},{"text":") inside of a multiline string literal without escaping it. To include the text ","type":"text"},{"code":"\"\"\"","type":"codeVoice"},{"text":" in a multiline string, escape at least one of the quotation marks. For example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let threeDoubleQuotationMarks = \"\"\"","Escaping the first quotation mark \\\"\"\"","Escaping all three quotation marks \\\"\\\"\\\"","\"\"\""]},{"text":"Extended String Delimiters","level":3,"anchor":"Extended-String-Delimiters","type":"heading"},{"inlineContent":[{"type":"text","text":"You can place a string literal within "},{"type":"emphasis","inlineContent":[{"type":"text","text":"extended delimiters"}]},{"type":"text","text":" to include special characters in a string without invoking their effect. You place your string within quotation marks ("},{"type":"codeVoice","code":"\""},{"type":"text","text":") and surround that with number signs ("},{"type":"codeVoice","code":"#"},{"type":"text","text":"). For example, printing the string literal "},{"type":"codeVoice","code":"#\"Line 1\\nLine 2\"#"},{"type":"text","text":" prints the line feed escape sequence ("},{"type":"codeVoice","code":"\\n"},{"type":"text","text":") rather than printing the string across two lines."}],"type":"paragraph"},{"inlineContent":[{"text":"If you need the special effects of a character in a string literal, match the number of number signs within the string following the escape character (","type":"text"},{"code":"\\","type":"codeVoice"},{"text":"). For example, if your string is ","type":"text"},{"code":"#\"Line 1\\nLine 2\"#","type":"codeVoice"},{"text":" and you want to break the line, you can use ","type":"text"},{"type":"codeVoice","code":"#\"Line 1\\#nLine 2\"#"},{"type":"text","text":" instead. Similarly, "},{"type":"codeVoice","code":"###\"Line1\\###nLine2\"###"},{"type":"text","text":" also breaks the line."}],"type":"paragraph"},{"inlineContent":[{"text":"String literals created using extended delimiters can also be multiline string literals. You can use extended delimiters to include the text ","type":"text"},{"type":"codeVoice","code":"\"\"\""},{"text":" in a multiline string, overriding the default behavior that ends the literal. For example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let threeMoreDoubleQuotationMarks = #\"\"\"","Here are three more double quotes: \"\"\"","\"\"\"#"]},{"text":"Initializing an Empty String","level":2,"anchor":"Initializing-an-Empty-String","type":"heading"},{"inlineContent":[{"text":"To create an empty ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" instance with initializer syntax:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var emptyString = \"\"               \/\/ empty string literal","var anotherEmptyString = String()  \/\/ initializer syntax","\/\/ these two strings are both empty, and are equivalent to each other"]},{"inlineContent":[{"type":"text","text":"Find out whether a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value is empty by checking its Boolean "},{"type":"codeVoice","code":"isEmpty"},{"type":"text","text":" property:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["if emptyString.isEmpty {","    print(\"Nothing to see here\")","}","\/\/ Prints \"Nothing to see here\""]},{"text":"String Mutability","level":2,"anchor":"String-Mutability","type":"heading"},{"inlineContent":[{"type":"text","text":"You indicate whether a particular "},{"type":"codeVoice","code":"String"},{"type":"text","text":" can be modified (or "},{"inlineContent":[{"type":"text","text":"mutated"}],"type":"emphasis"},{"type":"text","text":") by assigning it to a variable (in which case it can be modified), or to a constant (in which case it can’t be modified):"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var variableString = \"Horse\"","variableString += \" and carriage\"","\/\/ variableString is now \"Horse and carriage\"","","let constantString = \"Highlander\"","constantString += \" and another Highlander\"","\/\/ this reports a compile-time error - a constant string cannot be modified"]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (","type":"text"},{"type":"codeVoice","code":"NSString"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"NSMutableString"},{"text":") to indicate whether a string can be mutated.","type":"text"}]}],"type":"aside"},{"text":"Strings Are Value Types","level":2,"anchor":"Strings-Are-Value-Types","type":"heading"},{"inlineContent":[{"type":"text","text":"Swift’s "},{"code":"String","type":"codeVoice"},{"type":"text","text":" type is a "},{"inlineContent":[{"text":"value type","type":"text"}],"type":"emphasis"},{"type":"text","text":". If you create a new "},{"code":"String","type":"codeVoice"},{"type":"text","text":" value, that "},{"code":"String","type":"codeVoice"},{"type":"text","text":" value is "},{"inlineContent":[{"type":"text","text":"copied"}],"type":"emphasis"},{"type":"text","text":" when it’s passed to a function or method, or when it’s assigned to a constant or variable. In each case, a new copy of the existing "},{"code":"String","type":"codeVoice"},{"type":"text","text":" value is created, and the new copy is passed or assigned, not the original version. Value types are described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Swift’s copy-by-default "},{"type":"codeVoice","code":"String"},{"type":"text","text":" behavior ensures that when a function or method passes you a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value, it’s clear that you own that exact "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value, regardless of where it came from. You can be confident that the string you are passed won’t be modified unless you modify it yourself."}],"type":"paragraph"},{"inlineContent":[{"text":"Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.","type":"text"}],"type":"paragraph"},{"text":"Working with Characters","level":2,"anchor":"Working-with-Characters","type":"heading"},{"inlineContent":[{"type":"text","text":"You can access the individual "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" values for a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" by iterating over the string with a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" loop:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for character in \"Dog!🐶\" {","    print(character)","}","\/\/ D","\/\/ o","\/\/ g","\/\/ !","\/\/ 🐶"]},{"inlineContent":[{"text":"The ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" loop is described in ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#For-In-Loops"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Alternatively, you can create a stand-alone "},{"code":"Character","type":"codeVoice"},{"type":"text","text":" constant or variable from a single-character string literal by providing a "},{"code":"Character","type":"codeVoice"},{"type":"text","text":" type annotation:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let exclamationMark: Character = \"!\""]},{"inlineContent":[{"type":"codeVoice","code":"String"},{"type":"text","text":" values can be constructed by passing an array of "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" values as an argument to its initializer:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let catCharacters: [Character] = [\"C\", \"a\", \"t\", \"!\", \"🐱\"]","let catString = String(catCharacters)","print(catString)","\/\/ Prints \"Cat!🐱\""]},{"text":"Concatenating Strings and Characters","level":2,"anchor":"Concatenating-Strings-and-Characters","type":"heading"},{"inlineContent":[{"code":"String","type":"codeVoice"},{"text":" values can be added together (or ","type":"text"},{"inlineContent":[{"text":"concatenated","type":"text"}],"type":"emphasis"},{"text":") with the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") to create a new ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let string1 = \"hello\"","let string2 = \" there\"","var welcome = string1 + string2","\/\/ welcome now equals \"hello there\""]},{"inlineContent":[{"type":"text","text":"You can also append a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value to an existing "},{"type":"codeVoice","code":"String"},{"type":"text","text":" variable with the addition assignment operator ("},{"type":"codeVoice","code":"+="},{"type":"text","text":"):"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var instruction = \"look over\"","instruction += string2","\/\/ instruction now equals \"look over there\""]},{"inlineContent":[{"type":"text","text":"You can append a "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" value to a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" variable with the "},{"type":"codeVoice","code":"String"},{"type":"text","text":" type’s "},{"type":"codeVoice","code":"append()"},{"type":"text","text":" method:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let exclamationMark: Character = \"!\"","welcome.append(exclamationMark)","\/\/ welcome now equals \"hello there!\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can’t append a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" or "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" to an existing "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" variable, because a "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" value must contain a single character only."}]}],"type":"aside"},{"inlineContent":[{"text":"If you’re using multiline string literals to build up the lines of a longer string, you want every line in the string to end with a line break, including the last line. For example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let badStart = \"\"\"","one","two","\"\"\"","let end = \"\"\"","three","\"\"\"","print(badStart + end)","\/\/ Prints two lines:","\/\/ one","\/\/ twothree","","let goodStart = \"\"\"","one","two","","\"\"\"","print(goodStart + end)","\/\/ Prints three lines:","\/\/ one","\/\/ two","\/\/ three"]},{"inlineContent":[{"type":"text","text":"In the code above, concatenating "},{"code":"badStart","type":"codeVoice"},{"type":"text","text":" with "},{"code":"end","type":"codeVoice"},{"type":"text","text":" produces a two-line string, which isn’t the desired result. Because the last line of "},{"code":"badStart","type":"codeVoice"},{"type":"text","text":" doesn’t end with a line break, that line gets combined with the first line of "},{"code":"end","type":"codeVoice"},{"type":"text","text":". In contrast, both lines of "},{"code":"goodStart","type":"codeVoice"},{"type":"text","text":" end with a line break, so when it’s combined with "},{"code":"end","type":"codeVoice"},{"type":"text","text":" the result has three lines, as expected."}],"type":"paragraph"},{"text":"String Interpolation","level":2,"anchor":"String-Interpolation","type":"heading"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"String interpolation"}]},{"text":" is a way to construct a new ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. You can use string interpolation in both single-line and multiline string literals. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash (","type":"text"},{"type":"codeVoice","code":"\\"},{"text":"):","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let multiplier = 3","let message = \"\\(multiplier) times 2.5 is \\(Double(multiplier) * 2.5)\"","\/\/ message is \"3 times 2.5 is 7.5\""]},{"inlineContent":[{"text":"In the example above, the value of ","type":"text"},{"type":"codeVoice","code":"multiplier"},{"text":" is inserted into a string literal as ","type":"text"},{"type":"codeVoice","code":"\\(multiplier)"},{"text":". This placeholder is replaced with the actual value of ","type":"text"},{"type":"codeVoice","code":"multiplier"},{"text":" when the string interpolation is evaluated to create an actual string.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The value of ","type":"text"},{"code":"multiplier","type":"codeVoice"},{"text":" is also part of a larger expression later in the string. This expression calculates the value of ","type":"text"},{"code":"Double(multiplier) * 2.5","type":"codeVoice"},{"text":" and inserts the result (","type":"text"},{"code":"7.5","type":"codeVoice"},{"text":") into the string. In this case, the expression is written as ","type":"text"},{"code":"\\(Double(multiplier) * 2.5)","type":"codeVoice"},{"text":" when it’s included inside the string literal.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can use extended string delimiters to create strings containing characters that would otherwise be treated as a string interpolation. For example:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["print(#\"Write an interpolated string in Swift using \\(multiplier).\"#)","\/\/ Prints \"Write an interpolated string in Swift using \\(multiplier).\""]},{"inlineContent":[{"type":"text","text":"To use string interpolation inside a string that uses extended delimiters, match the number of number signs after the backslash to the number of number signs at the beginning and end of the string. For example:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["print(#\"6 times 7 is \\#(6 * 7).\"#)","\/\/ Prints \"6 times 7 is 42.\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"The expressions you write inside parentheses within an interpolated string can’t contain an unescaped backslash (","type":"text"},{"type":"codeVoice","code":"\\"},{"text":"), a carriage return, or a line feed. However, they can contain other string literals.","type":"text"}]}],"type":"aside"},{"text":"Unicode","level":2,"anchor":"Unicode","type":"heading"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Unicode"}]},{"type":"text","text":" is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift’s "},{"code":"String","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Character","type":"codeVoice"},{"type":"text","text":" types are fully Unicode-compliant, as described in this section."}],"type":"paragraph"},{"text":"Unicode Scalar Values","level":3,"anchor":"Unicode-Scalar-Values","type":"heading"},{"inlineContent":[{"text":"Behind the scenes, Swift’s native ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type is built from ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Unicode scalar values"}]},{"text":". A Unicode scalar value is a unique 21-bit number for a character or modifier, such as ","type":"text"},{"code":"U+0061","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"LATIN SMALL LETTER A","type":"codeVoice"},{"text":" (","type":"text"},{"code":"\"a\"","type":"codeVoice"},{"text":"), or ","type":"text"},{"code":"U+1F425","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"FRONT-FACING BABY CHICK","type":"codeVoice"},{"text":" (","type":"text"},{"code":"\"🐥\"","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that not all 21-bit Unicode scalar values are assigned to a character—some scalars are reserved for future assignment or for use in UTF-16 encoding. Scalar values that have been assigned to a character typically also have a name, such as ","type":"text"},{"code":"LATIN SMALL LETTER A","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"FRONT-FACING BABY CHICK","type":"codeVoice"},{"text":" in the examples above.","type":"text"}],"type":"paragraph"},{"text":"Extended Grapheme Clusters","level":3,"anchor":"Extended-Grapheme-Clusters","type":"heading"},{"inlineContent":[{"type":"text","text":"Every instance of Swift’s "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" type represents a single "},{"inlineContent":[{"type":"text","text":"extended grapheme cluster"}],"type":"emphasis"},{"type":"text","text":". An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s an example. The letter "},{"code":"é","type":"codeVoice"},{"type":"text","text":" can be represented as the single Unicode scalar "},{"code":"é","type":"codeVoice"},{"type":"text","text":" ("},{"code":"LATIN SMALL LETTER E WITH ACUTE","type":"codeVoice"},{"type":"text","text":", or "},{"code":"U+00E9","type":"codeVoice"},{"type":"text","text":"). However, the same letter can also be represented as a "},{"type":"emphasis","inlineContent":[{"text":"pair","type":"text"}]},{"type":"text","text":" of scalars—a standard letter "},{"code":"e","type":"codeVoice"},{"type":"text","text":" ("},{"code":"LATIN SMALL LETTER E","type":"codeVoice"},{"type":"text","text":", or "},{"code":"U+0065","type":"codeVoice"},{"type":"text","text":"), followed by the "},{"code":"COMBINING ACUTE ACCENT","type":"codeVoice"},{"type":"text","text":" scalar ("},{"code":"U+0301","type":"codeVoice"},{"type":"text","text":"). The "},{"code":"COMBINING ACUTE ACCENT","type":"codeVoice"},{"type":"text","text":" scalar is graphically applied to the scalar that precedes it, turning an "},{"code":"e","type":"codeVoice"},{"type":"text","text":" into an "},{"code":"é","type":"codeVoice"},{"type":"text","text":" when it’s rendered by a Unicode-aware text-rendering system."}],"type":"paragraph"},{"inlineContent":[{"text":"In both cases, the letter ","type":"text"},{"code":"é","type":"codeVoice"},{"text":" is represented as a single Swift ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it’s a cluster of two scalars:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let eAcute: Character = \"\\u{E9}\"                         \/\/ é","let combinedEAcute: Character = \"\\u{65}\\u{301}\"          \/\/ e followed by ́","\/\/ eAcute is é, combinedEAcute is é"]},{"inlineContent":[{"text":"Extended grapheme clusters are a flexible way to represent many complex script characters as a single ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" value in Swift:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let precomposed: Character = \"\\u{D55C}\"                  \/\/ 한","let decomposed: Character = \"\\u{1112}\\u{1161}\\u{11AB}\"   \/\/ ᄒ, ᅡ, ᆫ","\/\/ precomposed is 한, decomposed is 한"]},{"inlineContent":[{"text":"Extended grapheme clusters enable scalars for enclosing marks (such as ","type":"text"},{"code":"COMBINING ENCLOSING CIRCLE","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"U+20DD","type":"codeVoice"},{"text":") to enclose other Unicode scalars as part of a single ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" value:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let enclosedEAcute: Character = \"\\u{E9}\\u{20DD}\"","\/\/ enclosedEAcute is é⃝"]},{"inlineContent":[{"text":"Unicode scalars for regional indicator symbols can be combined in pairs to make a single ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" value, such as this combination of ","type":"text"},{"code":"REGIONAL INDICATOR SYMBOL LETTER U","type":"codeVoice"},{"text":" (","type":"text"},{"code":"U+1F1FA","type":"codeVoice"},{"text":") and ","type":"text"},{"code":"REGIONAL INDICATOR SYMBOL LETTER S","type":"codeVoice"},{"text":" (","type":"text"},{"code":"U+1F1F8","type":"codeVoice"},{"text":"):","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let regionalIndicatorForUS: Character = \"\\u{1F1FA}\\u{1F1F8}\"","\/\/ regionalIndicatorForUS is 🇺🇸"]},{"text":"Counting Characters","level":2,"anchor":"Counting-Characters","type":"heading"},{"inlineContent":[{"text":"To retrieve a count of the ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values in a string, use the ","type":"text"},{"type":"codeVoice","code":"count"},{"text":" property of the string:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let unusualMenagerie = \"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪\"","print(\"unusualMenagerie has \\(unusualMenagerie.count) characters\")","\/\/ Prints \"unusualMenagerie has 40 characters\""]},{"inlineContent":[{"text":"Note that Swift’s use of extended grapheme clusters for ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values means that string concatenation and modification may not always affect a string’s character count.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, if you initialize a new string with the four-character word "},{"type":"codeVoice","code":"cafe"},{"type":"text","text":", and then append a "},{"type":"codeVoice","code":"COMBINING ACUTE ACCENT"},{"type":"text","text":" ("},{"type":"codeVoice","code":"U+0301"},{"type":"text","text":") to the end of the string, the resulting string will still have a character count of "},{"type":"codeVoice","code":"4"},{"type":"text","text":", with a fourth character of "},{"type":"codeVoice","code":"é"},{"type":"text","text":", not "},{"type":"codeVoice","code":"e"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var word = \"cafe\"","print(\"the number of characters in \\(word) is \\(word.count)\")","\/\/ Prints \"the number of characters in cafe is 4\"","","word += \"\\u{301}\"    \/\/ COMBINING ACUTE ACCENT, U+0301","","print(\"the number of characters in \\(word) is \\(word.count)\")","\/\/ Prints \"the number of characters in café is 4\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"Extended grapheme clusters can be composed of multiple Unicode scalars. This means that different characters—and different representations of the same character—can require different amounts of memory to store. Because of this, characters in Swift don’t each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string can’t be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the ","type":"text"},{"code":"count","type":"codeVoice"},{"text":" property must iterate over the Unicode scalars in the entire string in order to determine the characters for that string.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The count of the characters returned by the "},{"code":"count","type":"codeVoice"},{"type":"text","text":" property isn’t always the same as the "},{"code":"length","type":"codeVoice"},{"type":"text","text":" property of an "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":" that contains the same characters. The length of an "},{"code":"NSString","type":"codeVoice"},{"type":"text","text":" is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string."}]}],"type":"aside"},{"text":"Accessing and Modifying a String","level":2,"anchor":"Accessing-and-Modifying-a-String","type":"heading"},{"inlineContent":[{"text":"You access and modify a string through its methods and properties, or by using subscript syntax.","type":"text"}],"type":"paragraph"},{"text":"String Indices","level":3,"anchor":"String-Indices","type":"heading"},{"inlineContent":[{"text":"Each ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value has an associated ","type":"text"},{"inlineContent":[{"type":"text","text":"index type"}],"type":"emphasis"},{"text":", ","type":"text"},{"code":"String.Index","type":"codeVoice"},{"text":", which corresponds to the position of each ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" in the string.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"As mentioned above, different characters can require different amounts of memory to store, so in order to determine which ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" is at a particular position, you must iterate over each Unicode scalar from the start or end of that ","type":"text"},{"code":"String","type":"codeVoice"},{"text":". For this reason, Swift strings can’t be indexed by integer values.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Use the ","type":"text"},{"code":"startIndex","type":"codeVoice"},{"text":" property to access the position of the first ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"endIndex","type":"codeVoice"},{"text":" property is the position after the last character in a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":". As a result, the ","type":"text"},{"code":"endIndex","type":"codeVoice"},{"text":" property isn’t a valid argument to a string’s subscript. If a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" is empty, ","type":"text"},{"code":"startIndex","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"endIndex","type":"codeVoice"},{"text":" are equal.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You access the indices before and after a given index using the "},{"type":"codeVoice","code":"index(before:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"index(after:)"},{"type":"text","text":" methods of "},{"type":"codeVoice","code":"String"},{"type":"text","text":". To access an index farther away from the given index, you can use the "},{"type":"codeVoice","code":"index(_:offsetBy:)"},{"type":"text","text":" method instead of calling one of these methods multiple times."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can use subscript syntax to access the "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" at a particular "},{"type":"codeVoice","code":"String"},{"type":"text","text":" index."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let greeting = \"Guten Tag!\"","greeting[greeting.startIndex]","\/\/ G","greeting[greeting.index(before: greeting.endIndex)]","\/\/ !","greeting[greeting.index(after: greeting.startIndex)]","\/\/ u","let index = greeting.index(greeting.startIndex, offsetBy: 7)","greeting[index]","\/\/ a"]},{"inlineContent":[{"text":"Attempting to access an index outside of a string’s range or a ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" at an index outside of a string’s range will trigger a runtime error.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["greeting[greeting.endIndex] \/\/ Error","greeting.index(after: greeting.endIndex) \/\/ Error"]},{"inlineContent":[{"text":"Use the ","type":"text"},{"type":"codeVoice","code":"indices"},{"text":" property to access all of the indices of individual characters in a string.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for index in greeting.indices {","    print(\"\\(greeting[index]) \", terminator: \"\")","}","\/\/ Prints \"G u t e n   T a g ! \""]},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"You can use the "},{"type":"codeVoice","code":"startIndex"},{"type":"text","text":" and "},{"type":"codeVoice","code":"endIndex"},{"type":"text","text":" properties and the "},{"type":"codeVoice","code":"index(before:)"},{"type":"text","text":", "},{"type":"codeVoice","code":"index(after:)"},{"type":"text","text":", and "},{"type":"codeVoice","code":"index(_:offsetBy:)"},{"type":"text","text":" methods on any type that conforms to the "},{"type":"codeVoice","code":"Collection"},{"type":"text","text":" protocol. This includes "},{"type":"codeVoice","code":"String"},{"type":"text","text":", as shown here, as well as collection types such as "},{"type":"codeVoice","code":"Array"},{"type":"text","text":", "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Set"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside"},{"text":"Inserting and Removing","level":3,"anchor":"Inserting-and-Removing","type":"heading"},{"inlineContent":[{"type":"text","text":"To insert a single character into a string at a specified index, use the "},{"type":"codeVoice","code":"insert(_:at:)"},{"type":"text","text":" method, and to insert the contents of another string at a specified index, use the "},{"type":"codeVoice","code":"insert(contentsOf:at:)"},{"type":"text","text":" method."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var welcome = \"hello\"","welcome.insert(\"!\", at: welcome.endIndex)","\/\/ welcome now equals \"hello!\"","","welcome.insert(contentsOf: \" there\", at: welcome.index(before: welcome.endIndex))","\/\/ welcome now equals \"hello there!\""]},{"inlineContent":[{"text":"To remove a single character from a string at a specified index, use the ","type":"text"},{"code":"remove(at:)","type":"codeVoice"},{"text":" method, and to remove a substring at a specified range, use the ","type":"text"},{"code":"removeSubrange(_:)","type":"codeVoice"},{"text":" method:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["welcome.remove(at: welcome.index(before: welcome.endIndex))","\/\/ welcome now equals \"hello there\"","","let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endIndex","welcome.removeSubrange(range)","\/\/ welcome now equals \"hello\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use the "},{"code":"insert(_:at:)","type":"codeVoice"},{"type":"text","text":", "},{"code":"insert(contentsOf:at:)","type":"codeVoice"},{"type":"text","text":", "},{"code":"remove(at:)","type":"codeVoice"},{"type":"text","text":", and "},{"code":"removeSubrange(_:)","type":"codeVoice"},{"type":"text","text":" methods on any type that conforms to the "},{"code":"RangeReplaceableCollection","type":"codeVoice"},{"type":"text","text":" protocol. This includes "},{"code":"String","type":"codeVoice"},{"type":"text","text":", as shown here, as well as collection types such as "},{"code":"Array","type":"codeVoice"},{"type":"text","text":", "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Set","type":"codeVoice"},{"type":"text","text":"."}]}],"type":"aside"},{"text":"Substrings","level":2,"anchor":"Substrings","type":"heading"},{"inlineContent":[{"text":"When you get a substring from a string—for example, using a subscript or a method like ","type":"text"},{"type":"codeVoice","code":"prefix(_:)"},{"text":"—the result is an instance of ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/substring","type":"reference"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/substring]","type":"text"},{"text":", not another string. Substrings in Swift have most of the same methods as strings, which means you can work with substrings the same way you work with strings. However, unlike strings, you use substrings for only a short amount of time while performing actions on a string. When you’re ready to store the result for a longer time, you convert the substring to an instance of ","type":"text"},{"type":"codeVoice","code":"String"},{"text":". For example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let greeting = \"Hello, world!\"","let index = greeting.firstIndex(of: \",\") ?? greeting.endIndex","let beginning = greeting[..<index]","\/\/ beginning is \"Hello\"","","\/\/ Convert the result to a String for long-term storage.","let newString = String(beginning)"]},{"inlineContent":[{"type":"text","text":"Like strings, each substring has a region of memory where the characters that make up the substring are stored. The difference between strings and substrings is that, as a performance optimization, a substring can reuse part of the memory that’s used to store the original string, or part of the memory that’s used to store another substring. (Strings have a similar optimization, but if two strings share memory, they’re equal.) This performance optimization means you don’t have to pay the performance cost of copying memory until you modify either the string or substring. As mentioned above, substrings aren’t suitable for long-term storage—because they reuse the storage of the original string, the entire original string must be kept in memory as long as any of its substrings are being used."}],"type":"paragraph"},{"inlineContent":[{"text":"In the example above, ","type":"text"},{"code":"greeting","type":"codeVoice"},{"text":" is a string, which means it has a region of memory where the characters that make up the string are stored. Because ","type":"text"},{"code":"beginning","type":"codeVoice"},{"text":" is a substring of ","type":"text"},{"code":"greeting","type":"codeVoice"},{"text":", it reuses the memory that ","type":"text"},{"code":"greeting","type":"codeVoice"},{"text":" uses. In contrast, ","type":"text"},{"code":"newString","type":"codeVoice"},{"text":" is a string—when it’s created from the substring, it has its own storage. The figure below shows these relationships:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"stringSubstring"}],"type":"paragraph"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Both "},{"code":"String","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Substring","type":"codeVoice"},{"type":"text","text":" conform to the "},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/stringprotocol"},{"type":"text","text":" [https:\/\/developer.apple.com\/documentation\/swift\/stringprotocol]"},{"type":"text","text":" protocol, which means it’s often convenient for string-manipulation functions to accept a "},{"code":"StringProtocol","type":"codeVoice"},{"type":"text","text":" value. You can call such functions with either a "},{"code":"String","type":"codeVoice"},{"type":"text","text":" or "},{"code":"Substring","type":"codeVoice"},{"type":"text","text":" value."}]}],"type":"aside"},{"text":"Comparing Strings","level":2,"anchor":"Comparing-Strings","type":"heading"},{"inlineContent":[{"text":"Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.","type":"text"}],"type":"paragraph"},{"text":"String and Character Equality","level":3,"anchor":"String-and-Character-Equality","type":"heading"},{"inlineContent":[{"type":"text","text":"String and character equality is checked with the “equal to” operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":") and the “not equal to” operator ("},{"type":"codeVoice","code":"!="},{"type":"text","text":"), as described in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators#Comparison-Operators"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let quotation = \"We're a lot alike, you and I.\"","let sameQuotation = \"We're a lot alike, you and I.\"","if quotation == sameQuotation {","    print(\"These two strings are considered equal\")","}","\/\/ Prints \"These two strings are considered equal\""]},{"inlineContent":[{"text":"Two ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" values (or two ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values) are considered equal if their extended grapheme clusters are ","type":"text"},{"inlineContent":[{"type":"text","text":"canonically equivalent"}],"type":"emphasis"},{"text":". Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they’re composed from different Unicode scalars behind the scenes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For example, ","type":"text"},{"code":"LATIN SMALL LETTER E WITH ACUTE","type":"codeVoice"},{"text":" (","type":"text"},{"code":"U+00E9","type":"codeVoice"},{"text":") is canonically equivalent to ","type":"text"},{"code":"LATIN SMALL LETTER E","type":"codeVoice"},{"text":" (","type":"text"},{"code":"U+0065","type":"codeVoice"},{"text":") followed by ","type":"text"},{"code":"COMBINING ACUTE ACCENT","type":"codeVoice"},{"text":" (","type":"text"},{"code":"U+0301","type":"codeVoice"},{"text":"). Both of these extended grapheme clusters are valid ways to represent the character ","type":"text"},{"code":"é","type":"codeVoice"},{"text":", and so they’re considered to be canonically equivalent:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ \"Voulez-vous un café?\" using LATIN SMALL LETTER E WITH ACUTE","let eAcuteQuestion = \"Voulez-vous un caf\\u{E9}?\"","","\/\/ \"Voulez-vous un café?\" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT","let combinedEAcuteQuestion = \"Voulez-vous un caf\\u{65}\\u{301}?\"","","if eAcuteQuestion == combinedEAcuteQuestion {","    print(\"These two strings are considered equal\")","}","\/\/ Prints \"These two strings are considered equal\""]},{"inlineContent":[{"type":"text","text":"Conversely, "},{"code":"LATIN CAPITAL LETTER A","type":"codeVoice"},{"type":"text","text":" ("},{"code":"U+0041","type":"codeVoice"},{"type":"text","text":", or "},{"code":"\"A\"","type":"codeVoice"},{"type":"text","text":"), as used in English, is "},{"inlineContent":[{"text":"not","type":"text"}],"type":"emphasis"},{"type":"text","text":" equivalent to "},{"code":"CYRILLIC CAPITAL LETTER A","type":"codeVoice"},{"type":"text","text":" ("},{"code":"U+0410","type":"codeVoice"},{"type":"text","text":", or "},{"code":"\"А\"","type":"codeVoice"},{"type":"text","text":"), as used in Russian. The characters are visually similar, but don’t have the same linguistic meaning:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let latinCapitalLetterA: Character = \"\\u{41}\"","","let cyrillicCapitalLetterA: Character = \"\\u{0410}\"","","if latinCapitalLetterA != cyrillicCapitalLetterA {","    print(\"These two characters aren't equivalent.\")","}","\/\/ Prints \"These two characters aren't equivalent.\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"String and character comparisons in Swift aren’t locale-sensitive.","type":"text"}]}],"type":"aside"},{"text":"Prefix and Suffix Equality","level":3,"anchor":"Prefix-and-Suffix-Equality","type":"heading"},{"inlineContent":[{"type":"text","text":"To check whether a string has a particular string prefix or suffix, call the string’s "},{"type":"codeVoice","code":"hasPrefix(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"hasSuffix(_:)"},{"type":"text","text":" methods, both of which take a single argument of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":" and return a Boolean value."}],"type":"paragraph"},{"inlineContent":[{"text":"The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Romeo and Juliet"}]},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let romeoAndJuliet = [","    \"Act 1 Scene 1: Verona, A public place\",","    \"Act 1 Scene 2: Capulet's mansion\",","    \"Act 1 Scene 3: A room in Capulet's mansion\",","    \"Act 1 Scene 4: A street outside Capulet's mansion\",","    \"Act 1 Scene 5: The Great Hall in Capulet's mansion\",","    \"Act 2 Scene 1: Outside Capulet's mansion\",","    \"Act 2 Scene 2: Capulet's orchard\",","    \"Act 2 Scene 3: Outside Friar Lawrence's cell\",","    \"Act 2 Scene 4: A street in Verona\",","    \"Act 2 Scene 5: Capulet's mansion\",","    \"Act 2 Scene 6: Friar Lawrence's cell\"","]"]},{"inlineContent":[{"type":"text","text":"You can use the "},{"type":"codeVoice","code":"hasPrefix(_:)"},{"type":"text","text":" method with the "},{"type":"codeVoice","code":"romeoAndJuliet"},{"type":"text","text":" array to count the number of scenes in Act 1 of the play:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var act1SceneCount = 0","for scene in romeoAndJuliet {","    if scene.hasPrefix(\"Act 1 \") {","        act1SceneCount += 1","    }","}","print(\"There are \\(act1SceneCount) scenes in Act 1\")","\/\/ Prints \"There are 5 scenes in Act 1\""]},{"inlineContent":[{"text":"Similarly, use the ","type":"text"},{"code":"hasSuffix(_:)","type":"codeVoice"},{"text":" method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["var mansionCount = 0","var cellCount = 0","for scene in romeoAndJuliet {","    if scene.hasSuffix(\"Capulet's mansion\") {","        mansionCount += 1","    } else if scene.hasSuffix(\"Friar Lawrence's cell\") {","        cellCount += 1","    }","}","print(\"\\(mansionCount) mansion scenes; \\(cellCount) cell scenes\")","\/\/ Prints \"6 mansion scenes; 2 cell scenes\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"hasPrefix(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"hasSuffix(_:)"},{"type":"text","text":" methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters#String-and-Character-Equality","isActive":true,"type":"reference"},{"type":"text","text":"."}]}],"type":"aside"},{"text":"Unicode Representations of Strings","level":2,"anchor":"Unicode-Representations-of-Strings","type":"heading"},{"inlineContent":[{"text":"When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined ","type":"text"},{"inlineContent":[{"type":"text","text":"encoding forms"}],"type":"emphasis"},{"text":". Each form encodes the string in small chunks known as ","type":"text"},{"inlineContent":[{"text":"code units","type":"text"}],"type":"emphasis"},{"text":". These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a ","type":"text"},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" statement, to access its individual ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values as Unicode extended grapheme clusters. This process is described in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters#Working-with-Characters","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Alternatively, access a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value in one of three other Unicode-compliant representations:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"A collection of UTF-8 code units (accessed with the string’s "},{"code":"utf8","type":"codeVoice"},{"type":"text","text":" property)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"A collection of UTF-16 code units (accessed with the string’s "},{"type":"codeVoice","code":"utf16"},{"type":"text","text":" property)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s "},{"type":"codeVoice","code":"unicodeScalars"},{"type":"text","text":" property)"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Each example below shows a different representation of the following string, which is made up of the characters "},{"code":"D","type":"codeVoice"},{"type":"text","text":", "},{"code":"o","type":"codeVoice"},{"type":"text","text":", "},{"code":"g","type":"codeVoice"},{"type":"text","text":", "},{"code":"‼","type":"codeVoice"},{"type":"text","text":" ("},{"code":"DOUBLE EXCLAMATION MARK","type":"codeVoice"},{"type":"text","text":", or Unicode scalar "},{"code":"U+203C","type":"codeVoice"},{"type":"text","text":"), and the 🐶 character ("},{"code":"DOG FACE","type":"codeVoice"},{"type":"text","text":", or Unicode scalar "},{"code":"U+1F436","type":"codeVoice"},{"type":"text","text":"):"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let dogString = \"Dog‼🐶\""]},{"text":"UTF-8 Representation","level":3,"anchor":"UTF-8-Representation","type":"heading"},{"inlineContent":[{"text":"You can access a UTF-8 representation of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" by iterating over its ","type":"text"},{"code":"utf8","type":"codeVoice"},{"text":" property. This property is of type ","type":"text"},{"code":"String.UTF8View","type":"codeVoice"},{"text":", which is a collection of unsigned 8-bit (","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":") values, one for each byte in the string’s UTF-8 representation:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"UTF8"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for codeUnit in dogString.utf8 {","    print(\"\\(codeUnit) \", terminator: \"\")","}","print(\"\")","\/\/ Prints \"68 111 103 226 128 188 240 159 144 182 \""]},{"inlineContent":[{"text":"In the example above, the first three decimal ","type":"text"},{"code":"codeUnit","type":"codeVoice"},{"text":" values (","type":"text"},{"code":"68","type":"codeVoice"},{"text":", ","type":"text"},{"code":"111","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"103"},{"type":"text","text":") represent the characters "},{"type":"codeVoice","code":"D"},{"type":"text","text":", "},{"type":"codeVoice","code":"o"},{"type":"text","text":", and "},{"type":"codeVoice","code":"g"},{"type":"text","text":", whose UTF-8 representation is the same as their ASCII representation. The next three decimal "},{"type":"codeVoice","code":"codeUnit"},{"type":"text","text":" values ("},{"type":"codeVoice","code":"226"},{"type":"text","text":", "},{"type":"codeVoice","code":"128"},{"type":"text","text":", "},{"type":"codeVoice","code":"188"},{"type":"text","text":") are a three-byte UTF-8 representation of the "},{"type":"codeVoice","code":"DOUBLE EXCLAMATION MARK"},{"type":"text","text":" character. The last four "},{"type":"codeVoice","code":"codeUnit"},{"type":"text","text":" values ("},{"type":"codeVoice","code":"240"},{"type":"text","text":", "},{"type":"codeVoice","code":"159"},{"type":"text","text":", "},{"type":"codeVoice","code":"144"},{"type":"text","text":", "},{"type":"codeVoice","code":"182"},{"type":"text","text":") are a four-byte UTF-8 representation of the "},{"type":"codeVoice","code":"DOG FACE"},{"type":"text","text":" character."}],"type":"paragraph"},{"text":"UTF-16 Representation","level":3,"anchor":"UTF-16-Representation","type":"heading"},{"inlineContent":[{"type":"text","text":"You can access a UTF-16 representation of a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" by iterating over its "},{"type":"codeVoice","code":"utf16"},{"type":"text","text":" property. This property is of type "},{"type":"codeVoice","code":"String.UTF16View"},{"type":"text","text":", which is a collection of unsigned 16-bit ("},{"type":"codeVoice","code":"UInt16"},{"type":"text","text":") values, one for each 16-bit code unit in the string’s UTF-16 representation:"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"UTF16"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for codeUnit in dogString.utf16 {","    print(\"\\(codeUnit) \", terminator: \"\")","}","print(\"\")","\/\/ Prints \"68 111 103 8252 55357 56374 \""]},{"inlineContent":[{"type":"text","text":"Again, the first three "},{"type":"codeVoice","code":"codeUnit"},{"type":"text","text":" values ("},{"type":"codeVoice","code":"68"},{"type":"text","text":", "},{"type":"codeVoice","code":"111"},{"type":"text","text":", "},{"type":"codeVoice","code":"103"},{"type":"text","text":") represent the characters "},{"type":"codeVoice","code":"D"},{"type":"text","text":", "},{"type":"codeVoice","code":"o"},{"type":"text","text":", and "},{"type":"codeVoice","code":"g"},{"type":"text","text":", whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters)."}],"type":"paragraph"},{"inlineContent":[{"text":"The fourth ","type":"text"},{"code":"codeUnit","type":"codeVoice"},{"text":" value (","type":"text"},{"code":"8252","type":"codeVoice"},{"text":") is a decimal equivalent of the hexadecimal value ","type":"text"},{"code":"203C","type":"codeVoice"},{"text":", which represents the Unicode scalar ","type":"text"},{"code":"U+203C","type":"codeVoice"},{"text":" for the ","type":"text"},{"code":"DOUBLE EXCLAMATION MARK","type":"codeVoice"},{"text":" character. This character can be represented as a single code unit in UTF-16.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The fifth and sixth "},{"code":"codeUnit","type":"codeVoice"},{"type":"text","text":" values ("},{"code":"55357","type":"codeVoice"},{"type":"text","text":" and "},{"code":"56374","type":"codeVoice"},{"type":"text","text":") are a UTF-16 surrogate pair representation of the "},{"code":"DOG FACE","type":"codeVoice"},{"type":"text","text":" character. These values are a high-surrogate value of "},{"code":"U+D83D","type":"codeVoice"},{"type":"text","text":" (decimal value "},{"code":"55357","type":"codeVoice"},{"type":"text","text":") and a low-surrogate value of "},{"code":"U+DC36","type":"codeVoice"},{"type":"text","text":" (decimal value "},{"code":"56374","type":"codeVoice"},{"type":"text","text":")."}],"type":"paragraph"},{"text":"Unicode Scalar Representation","level":3,"anchor":"Unicode-Scalar-Representation","type":"heading"},{"inlineContent":[{"type":"text","text":"You can access a Unicode scalar representation of a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value by iterating over its "},{"type":"codeVoice","code":"unicodeScalars"},{"type":"text","text":" property. This property is of type "},{"type":"codeVoice","code":"UnicodeScalarView"},{"type":"text","text":", which is a collection of values of type "},{"type":"codeVoice","code":"UnicodeScalar"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Each "},{"type":"codeVoice","code":"UnicodeScalar"},{"type":"text","text":" has a "},{"type":"codeVoice","code":"value"},{"type":"text","text":" property that returns the scalar’s 21-bit value, represented within a "},{"type":"codeVoice","code":"UInt32"},{"type":"text","text":" value:"}],"type":"paragraph"},{"inlineContent":[{"identifier":"UnicodeScalar","type":"image"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for scalar in dogString.unicodeScalars {","    print(\"\\(scalar.value) \", terminator: \"\")","}","print(\"\")","\/\/ Prints \"68 111 103 8252 128054 \""]},{"inlineContent":[{"type":"text","text":"The "},{"code":"value","type":"codeVoice"},{"type":"text","text":" properties for the first three "},{"code":"UnicodeScalar","type":"codeVoice"},{"type":"text","text":" values ("},{"code":"68","type":"codeVoice"},{"type":"text","text":", "},{"code":"111","type":"codeVoice"},{"type":"text","text":", "},{"code":"103","type":"codeVoice"},{"type":"text","text":") once again represent the characters "},{"code":"D","type":"codeVoice"},{"type":"text","text":", "},{"code":"o","type":"codeVoice"},{"type":"text","text":", and "},{"code":"g","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The fourth "},{"code":"codeUnit","type":"codeVoice"},{"type":"text","text":" value ("},{"code":"8252","type":"codeVoice"},{"type":"text","text":") is again a decimal equivalent of the hexadecimal value "},{"code":"203C","type":"codeVoice"},{"type":"text","text":", which represents the Unicode scalar "},{"code":"U+203C","type":"codeVoice"},{"type":"text","text":" for the "},{"code":"DOUBLE EXCLAMATION MARK","type":"codeVoice"},{"type":"text","text":" character."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"value"},{"type":"text","text":" property of the fifth and final "},{"type":"codeVoice","code":"UnicodeScalar"},{"type":"text","text":", "},{"type":"codeVoice","code":"128054"},{"type":"text","text":", is a decimal equivalent of the hexadecimal value "},{"type":"codeVoice","code":"1F436"},{"type":"text","text":", which represents the Unicode scalar "},{"type":"codeVoice","code":"U+1F436"},{"type":"text","text":" for the "},{"type":"codeVoice","code":"DOG FACE"},{"type":"text","text":" character."}],"type":"paragraph"},{"inlineContent":[{"text":"As an alternative to querying their ","type":"text"},{"code":"value","type":"codeVoice"},{"text":" properties, each ","type":"text"},{"code":"UnicodeScalar","type":"codeVoice"},{"text":" value can also be used to construct a new ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value, such as with string interpolation:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["for scalar in dogString.unicodeScalars {","    print(\"\\(scalar) \")","}","\/\/ D","\/\/ o","\/\/ g","\/\/ ‼","\/\/ 🐶"]}]}],"references":{"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"url":"\/documentation\/swift\/opaquetypes","title":"Opaque Types","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"kind":"article","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","title":"Extensions","type":"topic","url":"\/documentation\/swift\/extensions"},"https://developer.apple.com/documentation/swift/stringprotocol":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/stringprotocol","type":"link","titleInlineContent":[{"text":"StringProtocol","type":"text"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/stringprotocol","title":"StringProtocol"},"doc://com.apple.Swift/documentation/Swift/Functions":{"role":"article","type":"topic","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"kind":"article","url":"\/documentation\/swift\/functions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","title":"Subscripts","url":"\/documentation\/swift\/subscripts","role":"article","kind":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","role":"article","url":"\/documentation\/swift\/advancedoperators","abstract":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.","type":"text"}],"title":"Advanced Operators","kind":"article"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","role":"article","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","title":"Memory Safety","type":"topic","url":"\/documentation\/swift\/memorysafety"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters#Unicode":{"url":"\/documentation\/swift\/stringsandcharacters#Unicode","abstract":[],"title":"Unicode","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters#Unicode","type":"topic","kind":"section"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters#String-and-Character-Equality":{"url":"\/documentation\/swift\/stringsandcharacters#String-and-Character-Equality","abstract":[],"title":"String and Character Equality","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters#String-and-Character-Equality","type":"topic","kind":"section"},"doc://com.apple.Swift/documentation/Swift/BasicOperators#Comparison-Operators":{"url":"\/documentation\/swift\/basicoperators#Comparison-Operators","abstract":[],"title":"Comparison Operators","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators#Comparison-Operators","type":"topic","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"kind":"article","role":"article","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"text":"inherit","type":"text"}]},{"type":"text","text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":", and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"text":"superclass","type":"text"}]},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","type":"topic","url":"\/documentation\/swift\/inheritance"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"url":"\/documentation\/swift\/initialization","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","type":"topic","title":"Initialization","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}]},"doc://com.apple.Swift/documentation/Swift/ControlFlow#For-In-Loops":{"url":"\/documentation\/swift\/controlflow#For-In-Loops","abstract":[],"title":"For-In Loops","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow#For-In-Loops","type":"topic","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"type":"topic","role":"article","kind":"article","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"inlineContent":[{"type":"text","text":"Asynchronous code"}],"type":"emphasis"},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"inlineContent":[{"type":"text","text":"Parallel code"}],"type":"emphasis"},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"title":"Concurrency","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"title":"Enumerations","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"url":"\/documentation\/swift\/automaticreferencecounting","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"Automatic Reference Counting","type":"text"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","kind":"article","role":"article"},"stringSubstring":{"identifier":"stringSubstring","alt":null,"type":"image","variants":[{"url":"\/images\/stringSubstring@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"title":"Error Handling","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","url":"\/documentation\/swift\/errorhandling"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword. Deinitializers are only available on class types.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization"},"doc://com.apple.Swift/documentation/Swift/Closures":{"role":"article","type":"topic","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures"},"doc://com.apple.Swift/documentation/Swift/Generics":{"role":"article","type":"topic","title":"Generics","kind":"article","abstract":[{"inlineContent":[{"type":"text","text":"Generic code"}],"type":"emphasis"},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","url":"\/documentation\/swift\/generics"},"UTF8":{"identifier":"UTF8","alt":null,"type":"image","variants":[{"url":"\/images\/UTF8@2x.png","traits":["2x","light"]}]},"https://developer.apple.com/documentation/swift/string#2919514":{"title":"Bridging Between String and NSString","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/string#2919514","url":"https:\/\/developer.apple.com\/documentation\/swift\/string#2919514","type":"link","titleInlineContent":[{"text":"Bridging Between String and NSString","type":"text"}]},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"role":"article","type":"topic","title":"Control Flow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"kind":"article","url":"\/documentation\/swift\/controlflow","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"url":"\/documentation\/swift\/protocols","title":"Protocols","abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"protocol","type":"text"}],"type":"emphasis"},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"type":"text","text":"adopted"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"conform","type":"text"}]},{"text":" to that protocol.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","abstract":[{"inlineContent":[{"text":"Structures","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.","type":"text"}],"title":"Structures and Classes","url":"\/documentation\/swift\/classesandstructures","role":"article"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","abstract":[{"inlineContent":[{"text":"Access control","type":"text"}],"type":"emphasis"},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/accesscontrol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},"multilineStringWhitespace":{"identifier":"multilineStringWhitespace","type":"image","alt":null,"variants":[{"url":"\/images\/multilineStringWhitespace@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"role":"article","type":"topic","title":"Nested Types","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"inlineContent":[{"text":"nested types","type":"text"}],"type":"emphasis"},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/nestedtypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"abstract":[{"type":"text","text":"An "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"type":"codeVoice","code":"+"},{"text":") adds two numbers, as in ","type":"text"},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"type":"topic","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","url":"\/documentation\/swift\/basicoperators","kind":"article","title":"Basic Operators"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","title":"Collection Types","abstract":[{"text":"Swift provides three primary ","type":"text"},{"inlineContent":[{"text":"collection types","type":"text"}],"type":"emphasis"},{"text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/collectiontypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes"},"UnicodeScalar":{"identifier":"UnicodeScalar","type":"image","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/UnicodeScalar@2x.png"}]},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"title":"Swift","url":"\/documentation\/swift","role":"collection"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"title":"Optional Chaining","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic"},"UTF16":{"identifier":"UTF16","type":"image","alt":null,"variants":[{"url":"\/images\/UTF16@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types":{"kind":"section","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","abstract":[],"title":"Structures and Enumerations Are Value Types","url":"\/documentation\/swift\/classesandstructures#Structures-and-Enumerations-Are-Value-Types"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","role":"article","abstract":[{"inlineContent":[{"text":"Type casting","type":"text"}],"type":"emphasis"},{"text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.","type":"text"}],"title":"Type Casting","url":"\/documentation\/swift\/typecasting","type":"topic"},"https://developer.apple.com/documentation/swift/substring":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/substring","type":"link","titleInlineContent":[{"text":"Substring","type":"text"}],"url":"https:\/\/developer.apple.com\/documentation\/swift\/substring","title":"Substring"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters#Working-with-Characters":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters#Working-with-Characters","type":"topic","kind":"section","url":"\/documentation\/swift\/stringsandcharacters#Working-with-Characters","abstract":[],"title":"Working with Characters"}}}