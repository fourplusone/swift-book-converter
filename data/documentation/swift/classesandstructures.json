{"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"sections":[],"variants":[{"paths":["\/documentation\/swift\/classesandstructures"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"content":[{"text":"Overview","anchor":"overview","type":"heading","level":2},{"inlineContent":[{"text":"Unlike other programming languages, Swift doesn’t require you to create separate interface and implementation files for custom structures and classes. In Swift, you define a structure or class in a single file, and the external interface to that class or structure is automatically made available for other code to use.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"text":"An instance of a class is traditionally known as an ","type":"text"},{"inlineContent":[{"text":"object","type":"text"}],"type":"emphasis"},{"text":". However, Swift structures and classes are much closer in functionality than in other languages, and much of this chapter describes functionality that applies to instances of ","type":"text"},{"inlineContent":[{"type":"text","text":"either"}],"type":"emphasis"},{"text":" a class or a structure type. Because of this, the more general term ","type":"text"},{"inlineContent":[{"text":"instance","type":"text"}],"type":"emphasis"},{"text":" is used.","type":"text"}],"type":"paragraph"}]},{"text":"Comparing Structures and Classes","anchor":"Comparing-Structures-and-Classes","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Structures and classes in Swift have many things in common. Both can:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Define properties to store values","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define methods to provide functionality"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Define subscripts to provide access to their values using subscript syntax","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define initializers to set up their initial state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Be extended to expand their functionality beyond a default implementation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Conform to protocols to provide standard functionality of a certain kind"}]}]}]},{"inlineContent":[{"text":"For more information, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","isActive":true,"type":"reference"},{"text":", ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","isActive":true,"type":"reference"},{"text":", ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","isActive":true,"type":"reference"},{"text":", ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","isActive":true,"type":"reference"},{"text":", ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","isActive":true,"type":"reference"},{"text":", and ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Classes have additional capabilities that structures don’t have:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Inheritance enables one class to inherit the characteristics of another."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Type casting enables you to check and interpret the type of a class instance at runtime."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Deinitializers enable an instance of a class to free up any resources it has assigned."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Reference counting allows more than one reference to a class instance.","type":"text"}],"type":"paragraph"}]}]},{"inlineContent":[{"type":"text","text":"For more information, see "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","type":"reference","isActive":true},{"type":"text","text":", "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"reference","isActive":true},{"type":"text","text":", "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","type":"reference","isActive":true},{"type":"text","text":", and "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The additional capabilities that classes support come at the cost of increased complexity. As a general guideline, prefer structures because they’re easier to reason about, and use classes when they’re appropriate or necessary. In practice, this means most of the custom data types you define will be structures and enumerations. For a more detailed comparison, see ","type":"text"},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes","type":"reference"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes]","type":"text"},{"text":".","type":"text"}],"type":"paragraph"},{"style":"note","name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"Classes and actors share many of the same characteristics and behaviors. For information about actors, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency"},{"text":".","type":"text"}]}]},{"text":"Definition Syntax","anchor":"Definition-Syntax","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Structures and classes have a similar definition syntax. You introduce structures with the "},{"code":"struct","type":"codeVoice"},{"type":"text","text":" keyword and classes with the "},{"code":"class","type":"codeVoice"},{"type":"text","text":" keyword. Both place their entire definition within a pair of braces:"}],"type":"paragraph"},{"code":["struct SomeStructure {","    \/\/ structure definition goes here","}","class SomeClass {","    \/\/ class definition goes here","}"],"syntax":"swift","type":"codeListing"},{"name":"Note","content":[{"inlineContent":[{"text":"Whenever you define a new structure or class, you define a new Swift type. Give types ","type":"text"},{"code":"UpperCamelCase","type":"codeVoice"},{"text":" names (such as ","type":"text"},{"code":"SomeStructure","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"SomeClass","type":"codeVoice"},{"text":" here) to match the capitalization of standard Swift types (such as ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":"). Give properties and methods ","type":"text"},{"code":"lowerCamelCase","type":"codeVoice"},{"text":" names (such as ","type":"text"},{"code":"frameRate","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"incrementCount","type":"codeVoice"},{"text":") to differentiate them from type names.","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside"},{"inlineContent":[{"type":"text","text":"Here’s an example of a structure definition and a class definition:"}],"type":"paragraph"},{"code":["struct Resolution {","    var width = 0","    var height = 0","}","class VideoMode {","    var resolution = Resolution()","    var interlaced = false","    var frameRate = 0.0","    var name: String?","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The example above defines a new structure called "},{"code":"Resolution","type":"codeVoice"},{"text":", to describe a pixel-based display resolution. This structure has two stored properties called ","type":"text"},{"code":"width","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"height","type":"codeVoice"},{"text":". Stored properties are constants or variables that are bundled up and stored as part of the structure or class. These two properties are inferred to be of type ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" by setting them to an initial integer value of ","type":"text"},{"code":"0","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example above also defines a new class called "},{"code":"VideoMode","type":"codeVoice"},{"type":"text","text":", to describe a specific video mode for video display. This class has four variable stored properties. The first, "},{"code":"resolution","type":"codeVoice"},{"type":"text","text":", is initialized with a new "},{"code":"Resolution","type":"codeVoice"},{"type":"text","text":" structure instance, which infers a property type of "},{"code":"Resolution","type":"codeVoice"},{"type":"text","text":". For the other three properties, new "},{"code":"VideoMode","type":"codeVoice"},{"type":"text","text":" instances will be initialized with an "},{"code":"interlaced","type":"codeVoice"},{"type":"text","text":" setting of "},{"code":"false","type":"codeVoice"},{"type":"text","text":" (meaning “noninterlaced video”), a playback frame rate of "},{"code":"0.0","type":"codeVoice"},{"type":"text","text":", and an optional "},{"code":"String","type":"codeVoice"},{"text":" value called ","type":"text"},{"code":"name","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" property is automatically given a default value of ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", or “no ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" value”, because it’s of an optional type.","type":"text"}],"type":"paragraph"},{"anchor":"Structure-and-Class-Instances","level":3,"type":"heading","text":"Structure and Class Instances"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" structure definition and the "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" class definition only describe what a "},{"type":"codeVoice","code":"Resolution"},{"type":"text","text":" or "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" will look like. They themselves don’t describe a specific resolution or video mode. To do that, you need to create an instance of the structure or class."}],"type":"paragraph"},{"inlineContent":[{"text":"The syntax for creating instances is very similar for both structures and classes:","type":"text"}],"type":"paragraph"},{"code":["let someResolution = Resolution()","let someVideoMode = VideoMode()"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Structures and classes both use initializer syntax for new instances. The simplest form of initializer syntax uses the type name of the class or structure followed by empty parentheses, such as ","type":"text"},{"type":"codeVoice","code":"Resolution()"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"VideoMode()"},{"type":"text","text":". This creates a new instance of the class or structure, with any properties initialized to their default values. Class and structure initialization is described in more detail in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Accessing-Properties","level":3,"type":"heading","text":"Accessing Properties"},{"inlineContent":[{"type":"text","text":"You can access the properties of an instance using "},{"type":"emphasis","inlineContent":[{"type":"text","text":"dot syntax"}]},{"type":"text","text":". In dot syntax, you write the property name immediately after the instance name, separated by a period ("},{"type":"codeVoice","code":"."},{"type":"text","text":"), without any spaces:"}],"type":"paragraph"},{"code":["print(\"The width of someResolution is \\(someResolution.width)\")","\/\/ Prints \"The width of someResolution is 0\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In this example, ","type":"text"},{"type":"codeVoice","code":"someResolution.width"},{"text":" refers to the ","type":"text"},{"type":"codeVoice","code":"width"},{"text":" property of ","type":"text"},{"type":"codeVoice","code":"someResolution"},{"text":", and returns its default initial value of ","type":"text"},{"type":"codeVoice","code":"0"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can drill down into subproperties, such as the "},{"type":"codeVoice","code":"width"},{"type":"text","text":" property in the "},{"type":"codeVoice","code":"resolution"},{"type":"text","text":" property of a "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["print(\"The width of someVideoMode is \\(someVideoMode.resolution.width)\")","\/\/ Prints \"The width of someVideoMode is 0\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"You can also use dot syntax to assign a new value to a variable property:"}],"type":"paragraph"},{"code":["someVideoMode.resolution.width = 1280","print(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")","\/\/ Prints \"The width of someVideoMode is now 1280\""],"syntax":"swift","type":"codeListing"},{"anchor":"Memberwise-Initializers-for-Structure-Types","level":3,"type":"heading","text":"Memberwise Initializers for Structure Types"},{"inlineContent":[{"text":"All structures have an automatically generated ","type":"text"},{"inlineContent":[{"type":"text","text":"memberwise initializer"}],"type":"emphasis"},{"text":", which you can use to initialize the member properties of new structure instances. Initial values for the properties of the new instance can be passed to the memberwise initializer by name:","type":"text"}],"type":"paragraph"},{"code":["let vga = Resolution(width: 640, height: 480)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Unlike structures, class instances don’t receive a default memberwise initializer. Initializers are described in more detail in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Structures-and-Enumerations-Are-Value-Types","level":2,"type":"heading","text":"Structures and Enumerations Are Value Types"},{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"value type","type":"text"}],"type":"emphasis"},{"text":" is a type whose value is ","type":"text"},{"inlineContent":[{"text":"copied","type":"text"}],"type":"emphasis"},{"text":" when it’s assigned to a variable or constant, or when it’s passed to a function.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You’ve actually been using value types extensively throughout the previous chapters. In fact, all of the basic types in Swift—integers, floating-point numbers, Booleans, strings, arrays and dictionaries—are value types, and are implemented as structures behind the scenes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"All structures and enumerations are value types in Swift. This means that any structure and enumeration instances you create—and any value types they have as properties—are always copied when they’re passed around in your code.","type":"text"}],"type":"paragraph"},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"Collections defined by the standard library like arrays, dictionaries, and strings use an optimization to reduce the performance cost of copying. Instead of making a copy immediately, these collections share the memory where the elements are stored between the original instance and any copies. If one of the copies of the collection is modified, the elements are copied just before the modification. The behavior you see in your code is always as if a copy took place immediately.","type":"text"}]}],"style":"note","type":"aside"},{"inlineContent":[{"text":"Consider this example, which uses the ","type":"text"},{"code":"Resolution","type":"codeVoice"},{"text":" structure from the previous example:","type":"text"}],"type":"paragraph"},{"code":["let hd = Resolution(width: 1920, height: 1080)","var cinema = hd"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This example declares a constant called ","type":"text"},{"code":"hd","type":"codeVoice"},{"text":" and sets it to a ","type":"text"},{"code":"Resolution","type":"codeVoice"},{"text":" instance initialized with the width and height of full HD video (1920 pixels wide by 1080 pixels high).","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"It then declares a variable called ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":" and sets it to the current value of ","type":"text"},{"code":"hd","type":"codeVoice"},{"text":". Because ","type":"text"},{"code":"Resolution","type":"codeVoice"},{"text":" is a structure, a ","type":"text"},{"inlineContent":[{"type":"text","text":"copy"}],"type":"emphasis"},{"text":" of the existing instance is made, and this new copy is assigned to ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":". Even though ","type":"text"},{"code":"hd","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":" now have the same width and height, they’re two completely different instances behind the scenes.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Next, the "},{"type":"codeVoice","code":"width"},{"type":"text","text":" property of "},{"type":"codeVoice","code":"cinema"},{"type":"text","text":" is amended to be the width of the slightly wider 2K standard used for digital cinema projection (2048 pixels wide and 1080 pixels high):"}],"type":"paragraph"},{"code":["cinema.width = 2048"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Checking the ","type":"text"},{"code":"width","type":"codeVoice"},{"text":" property of ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":" shows that it has indeed changed to be ","type":"text"},{"code":"2048","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["print(\"cinema is now \\(cinema.width) pixels wide\")","\/\/ Prints \"cinema is now 2048 pixels wide\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"However, the "},{"code":"width","type":"codeVoice"},{"type":"text","text":" property of the original "},{"code":"hd","type":"codeVoice"},{"type":"text","text":" instance still has the old value of "},{"code":"1920","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["print(\"hd is still \\(hd.width) pixels wide\")","\/\/ Prints \"hd is still 1920 pixels wide\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"When ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":" was given the current value of ","type":"text"},{"code":"hd","type":"codeVoice"},{"text":", the ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"values","type":"text"}]},{"text":" stored in ","type":"text"},{"code":"hd","type":"codeVoice"},{"text":" were copied into the new ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":" instance. The end result was two completely separate instances that contained the same numeric values. However, because they’re separate instances, setting the width of ","type":"text"},{"code":"cinema","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"2048","type":"codeVoice"},{"text":" doesn’t affect the width stored in ","type":"text"},{"code":"hd","type":"codeVoice"},{"text":", as shown in the figure below:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"sharedStateStruct","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The same behavior applies to enumerations:"}],"type":"paragraph"},{"code":["enum CompassPoint {","    case north, south, east, west","    mutating func turnNorth() {","        self = .north","    }","}","var currentDirection = CompassPoint.west","let rememberedDirection = currentDirection","currentDirection.turnNorth()","","print(\"The current direction is \\(currentDirection)\")","print(\"The remembered direction is \\(rememberedDirection)\")","\/\/ Prints \"The current direction is north\"","\/\/ Prints \"The remembered direction is west\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"When ","type":"text"},{"code":"rememberedDirection","type":"codeVoice"},{"text":" is assigned the value of ","type":"text"},{"code":"currentDirection","type":"codeVoice"},{"text":", it’s actually set to a copy of that value. Changing the value of ","type":"text"},{"code":"currentDirection","type":"codeVoice"},{"text":" thereafter doesn’t affect the copy of the original value that was stored in ","type":"text"},{"code":"rememberedDirection","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Classes-Are-Reference-Types","level":2,"type":"heading","text":"Classes Are Reference Types"},{"inlineContent":[{"type":"text","text":"Unlike value types, "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference types"}]},{"type":"text","text":" are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" copied when they’re assigned to a variable or constant, or when they’re passed to a function. Rather than a copy, a reference to the same existing instance is used."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s an example, using the ","type":"text"},{"code":"VideoMode","type":"codeVoice"},{"text":" class defined above:","type":"text"}],"type":"paragraph"},{"code":["let tenEighty = VideoMode()","tenEighty.resolution = hd","tenEighty.interlaced = true","tenEighty.name = \"1080i\"","tenEighty.frameRate = 25.0"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example declares a new constant called "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" and sets it to refer to a new instance of the "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" class. The video mode is assigned a copy of the HD resolution of "},{"type":"codeVoice","code":"1920"},{"text":" by ","type":"text"},{"code":"1080","type":"codeVoice"},{"text":" from before. It’s set to be interlaced, its name is set to ","type":"text"},{"code":"\"1080i\"","type":"codeVoice"},{"text":", and its frame rate is set to ","type":"text"},{"code":"25.0","type":"codeVoice"},{"text":" frames per second.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Next, ","type":"text"},{"code":"tenEighty","type":"codeVoice"},{"text":" is assigned to a new constant, called ","type":"text"},{"code":"alsoTenEighty","type":"codeVoice"},{"text":", and the frame rate of ","type":"text"},{"code":"alsoTenEighty","type":"codeVoice"},{"text":" is modified:","type":"text"}],"type":"paragraph"},{"code":["let alsoTenEighty = tenEighty","alsoTenEighty.frameRate = 30.0"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Because classes are reference types, "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" and "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" actually both refer to the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"same"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" instance. Effectively, they’re just two different names for the same single instance, as shown in the figure below:"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"sharedStateClass"}],"type":"paragraph"},{"inlineContent":[{"text":"Checking the ","type":"text"},{"type":"codeVoice","code":"frameRate"},{"text":" property of ","type":"text"},{"type":"codeVoice","code":"tenEighty"},{"text":" shows that it correctly reports the new frame rate of ","type":"text"},{"type":"codeVoice","code":"30.0"},{"text":" from the underlying ","type":"text"},{"type":"codeVoice","code":"VideoMode"},{"text":" instance:","type":"text"}],"type":"paragraph"},{"code":["print(\"The frameRate property of tenEighty is now \\(tenEighty.frameRate)\")","\/\/ Prints \"The frameRate property of tenEighty is now 30.0\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This example also shows how reference types can be harder to reason about. If ","type":"text"},{"code":"tenEighty","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"alsoTenEighty","type":"codeVoice"},{"text":" were far apart in your program’s code, it could be difficult to find all the ways that the video mode is changed. Wherever you use ","type":"text"},{"code":"tenEighty","type":"codeVoice"},{"text":", you also have to think about the code that uses ","type":"text"},{"code":"alsoTenEighty","type":"codeVoice"},{"text":", and vice versa. In contrast, value types are easier to reason about because all of the code that interacts with the same value is close together in your source files.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" and "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" are declared as "},{"type":"emphasis","inlineContent":[{"text":"constants","type":"text"}]},{"type":"text","text":", rather than variables. However, you can still change "},{"type":"codeVoice","code":"tenEighty.frameRate"},{"type":"text","text":" and "},{"type":"codeVoice","code":"alsoTenEighty.frameRate"},{"type":"text","text":" because the values of the "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" and "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" constants themselves don’t actually change. "},{"type":"codeVoice","code":"tenEighty"},{"type":"text","text":" and "},{"type":"codeVoice","code":"alsoTenEighty"},{"type":"text","text":" themselves don’t “store” the "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" instance—instead, they both "},{"type":"emphasis","inlineContent":[{"text":"refer","type":"text"}]},{"type":"text","text":" to a "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" instance behind the scenes. It’s the "},{"type":"codeVoice","code":"frameRate"},{"type":"text","text":" property of the underlying "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":" that’s changed, not the values of the constant references to that "},{"type":"codeVoice","code":"VideoMode"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Identity-Operators","level":3,"type":"heading","text":"Identity Operators"},{"inlineContent":[{"text":"Because classes are reference types, it’s possible for multiple constants and variables to refer to the same single instance of a class behind the scenes. (The same isn’t true for structures and enumerations, because they’re always copied when they’re assigned to a constant or variable, or passed to a function.)","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It can sometimes be useful to find out whether two constants or variables refer to exactly the same instance of a class. To enable this, Swift provides two identity operators:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Identical to ("},{"type":"codeVoice","code":"==="},{"type":"text","text":")"}]}]},{"content":[{"inlineContent":[{"text":"Not identical to (","type":"text"},{"code":"!==","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Use these operators to check whether two constants or variables refer to the same single instance:"}],"type":"paragraph"},{"code":["if tenEighty === alsoTenEighty {","    print(\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\")","}","\/\/ Prints \"tenEighty and alsoTenEighty refer to the same VideoMode instance.\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note that "},{"type":"emphasis","inlineContent":[{"text":"identical to","type":"text"}]},{"type":"text","text":" (represented by three equals signs, or "},{"code":"===","type":"codeVoice"},{"type":"text","text":") doesn’t mean the same thing as "},{"type":"emphasis","inlineContent":[{"text":"equal to","type":"text"}]},{"type":"text","text":" (represented by two equals signs, or "},{"code":"==","type":"codeVoice"},{"type":"text","text":"). "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Identical to"}]},{"type":"text","text":" means that two constants or variables of class type refer to exactly the same class instance. "},{"type":"emphasis","inlineContent":[{"text":"Equal to","type":"text"}]},{"type":"text","text":" means that two instances are considered equal or equivalent in value, for some appropriate meaning of "},{"type":"emphasis","inlineContent":[{"text":"equal","type":"text"}]},{"type":"text","text":", as defined by the type’s designer."}],"type":"paragraph"},{"inlineContent":[{"text":"When you define your own custom structures and classes, it’s your responsibility to decide what qualifies as two instances being equal. The process of defining your own implementations of the ","type":"text"},{"type":"codeVoice","code":"=="},{"text":" and ","type":"text"},{"type":"codeVoice","code":"!="},{"text":" operators is described in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Equivalence-Operators"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Pointers","level":3,"type":"heading","text":"Pointers"},{"inlineContent":[{"text":"If you have experience with C, C++, or Objective-C, you may know that these languages use ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pointers"}]},{"text":" to refer to addresses in memory. A Swift constant or variable that refers to an instance of some reference type is similar to a pointer in C, but isn’t a direct pointer to an address in memory, and doesn’t require you to write an asterisk (","type":"text"},{"code":"*","type":"codeVoice"},{"text":") to indicate that you are creating a reference. Instead, these references are defined like any other constant or variable in Swift. The standard library provides pointer and buffer types that you can use if you need to interact with pointers directly—see ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management]","type":"text"},{"text":".","type":"text"}],"type":"paragraph"}],"kind":"content"}],"metadata":{"modules":[{"name":"Swift"}],"roleHeading":"Article","role":"article","title":"Structures and Classes"},"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"classes"}]},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"seeAlsoSections":[{"generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"title":"Language Guide"}],"references":{"https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes","titleInlineContent":[{"text":"Choosing Between Structures and Classes","type":"text"}],"title":"Choosing Between Structures and Classes","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/choosing_between_structures_and_classes","type":"link"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"url":"\/documentation\/swift\/stringsandcharacters","role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","kind":"article","url":"\/documentation\/swift\/extensions","title":"Extensions"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"title":"Initialization","url":"\/documentation\/swift\/initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"text":"inherit","type":"text"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"text":"subclass","type":"text"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/inheritance","title":"Inheritance","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","url":"\/documentation\/swift\/concurrency","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"type":"text","text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Generics":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"url":"\/documentation\/swift\/generics","role":"article","title":"Generics","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"url":"\/documentation\/swift\/collectiontypes","role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Closures":{"url":"\/documentation\/swift\/closures","role":"article","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"url":"\/documentation\/swift\/advancedoperators","role":"article","title":"Advanced Operators","abstract":[{"type":"text","text":"In addition to the operators described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","type":"topic"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"title":"Nested Types","url":"\/documentation\/swift\/nestedtypes","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nested types","type":"text"}]},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"title":"Automatic Reference Counting","url":"\/documentation\/swift\/automaticreferencecounting","abstract":[{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"text":"conform","type":"text"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","url":"\/documentation\/swift\/protocols","title":"Protocols"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"role":"article","abstract":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","kind":"article","url":"\/documentation\/swift\/enumerations","title":"Enumerations"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"text":" is called immediately before a class instance is deallocated. You write deinitializers with the ","type":"text"},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","kind":"article","url":"\/documentation\/swift\/deinitialization","title":"Deinitialization"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","type":"topic"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","abstract":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") adds two numbers, as in ","type":"text"},{"code":"let i = 1 + 2","type":"codeVoice"},{"text":", and the logical AND operator (","type":"text"},{"code":"&&","type":"codeVoice"},{"text":") combines two Boolean values, as in ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"text":".","type":"text"}],"kind":"article","url":"\/documentation\/swift\/basicoperators","title":"Basic Operators","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","url":"\/documentation\/swift\/functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"title":"Subscripts","url":"\/documentation\/swift\/subscripts","abstract":[{"text":"Classes, structures, and enumerations can define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instance as "},{"code":"someArray[index]","type":"codeVoice"},{"type":"text","text":" and elements in a "},{"code":"Dictionary","type":"codeVoice"},{"text":" instance as ","type":"text"},{"type":"codeVoice","code":"someDictionary[key]"},{"text":".","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","url":"\/documentation\/swift\/accesscontrol","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/swift\/optionalchaining","role":"article","title":"Optional Chaining","abstract":[{"inlineContent":[{"text":"Optional chaining","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", the property, method, or subscript call returns "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},"sharedStateStruct":{"variants":[{"traits":["2x","light"],"url":"\/images\/sharedStateStruct@2x.png"}],"identifier":"sharedStateStruct","alt":null,"type":"image"},"sharedStateClass":{"type":"image","alt":null,"identifier":"sharedStateClass","variants":[{"url":"\/images\/sharedStateClass@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators#Equivalence-Operators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Equivalence-Operators","kind":"section","url":"\/documentation\/swift\/advancedoperators#Equivalence-Operators","title":"Equivalence Operators","type":"topic","abstract":[]},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"title":"Opaque Types","role":"article","kind":"article","url":"\/documentation\/swift\/opaquetypes","type":"topic","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"url":"\/documentation\/swift\/typecasting","role":"article","title":"Type Casting","abstract":[{"inlineContent":[{"type":"text","text":"Type casting"}],"type":"emphasis"},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"title":"Memory Safety","url":"\/documentation\/swift\/memorysafety","abstract":[{"text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"url":"\/documentation\/swift\/errorhandling","role":"article","title":"Error Handling","abstract":[{"inlineContent":[{"type":"text","text":"Error handling"}],"type":"emphasis"},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","type":"topic"},"https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management":{"titleInlineContent":[{"type":"text","text":"Manual Memory Management"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management","type":"link","url":"https:\/\/developer.apple.com\/documentation\/swift\/swift_standard_library\/manual_memory_management","title":"Manual Memory Management"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","role":"article","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","type":"topic"}}}