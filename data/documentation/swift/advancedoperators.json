{"sections":[],"metadata":{"modules":[{"name":"Swift"}],"title":"Advanced Operators","role":"article","roleHeading":"Article"},"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","interfaceLanguage":"swift"},"schemaVersion":{"minor":3,"patch":0,"major":0},"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"kind":"article","abstract":[{"type":"text","text":"In addition to the operators described in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true,"type":"reference"},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"seeAlsoSections":[{"title":"Language Guide","generated":true,"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"]}],"primaryContentSections":[{"content":[{"anchor":"overview","text":"Overview","type":"heading","level":2},{"inlineContent":[{"text":"Unlike arithmetic operators in C, arithmetic operators in Swift don’t overflow by default. Overflow behavior is trapped and reported as an error. To opt in to overflow behavior, use Swift’s second set of arithmetic operators that overflow by default, such as the overflow addition operator (","type":"text"},{"type":"codeVoice","code":"&+"},{"text":"). All of these overflow operators begin with an ampersand (","type":"text"},{"type":"codeVoice","code":"&"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"When you define your own structures, classes, and enumerations, it can be useful to provide your own implementations of the standard Swift operators for these custom types. Swift makes it easy to provide tailored implementations of these operators and to determine exactly what their behavior should be for each type you create.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You’re not limited to the predefined operators. Swift gives you the freedom to define your own custom infix, prefix, postfix, and assignment operators, with custom precedence and associativity values. These operators can be used and adopted in your code like any of the predefined operators, and you can even extend existing types to support the custom operators you define.","type":"text"}],"type":"paragraph"},{"anchor":"Bitwise-Operators","text":"Bitwise Operators","type":"heading","level":2},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Bitwise operators"}],"type":"emphasis"},{"text":" enable you to manipulate the individual raw data bits within a data structure. They’re often used in low-level programming, such as graphics programming and device driver creation. Bitwise operators can also be useful when you work with raw data from external sources, such as encoding and decoding data for communication over a custom protocol.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Swift supports all of the bitwise operators found in C, as described below."}],"type":"paragraph"},{"anchor":"Bitwise-NOT-Operator","text":"Bitwise NOT Operator","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"bitwise NOT operator","type":"text"}]},{"type":"text","text":" ("},{"type":"codeVoice","code":"~"},{"text":") inverts all bits in a number:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"bitwiseNOT","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The bitwise NOT operator is a prefix operator, and appears immediately before the value it operates on, without any white space:"}],"type":"paragraph"},{"code":["let initialBits: UInt8 = 0b00001111","let invertedBits = ~initialBits  \/\/ equals 11110000"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"code":"UInt8","type":"codeVoice"},{"text":" integers have eight bits and can store any value between ","type":"text"},{"code":"0","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"255","type":"codeVoice"},{"text":". This example initializes a ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":" integer with the binary value ","type":"text"},{"type":"codeVoice","code":"00001111"},{"text":", which has its first four bits set to ","type":"text"},{"type":"codeVoice","code":"0"},{"text":", and its second four bits set to ","type":"text"},{"type":"codeVoice","code":"1"},{"text":". This is equivalent to a decimal value of ","type":"text"},{"type":"codeVoice","code":"15"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The bitwise NOT operator is then used to create a new constant called "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":", which is equal to "},{"type":"codeVoice","code":"initialBits"},{"type":"text","text":", but with all of the bits inverted. Zeros become ones, and ones become zeros. The value of "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":" is "},{"type":"codeVoice","code":"11110000"},{"type":"text","text":", which is equal to an unsigned decimal value of "},{"type":"codeVoice","code":"240"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Bitwise-AND-Operator","text":"Bitwise AND Operator","type":"heading","level":3},{"inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise AND operator"}]},{"text":" (","type":"text"},{"code":"&","type":"codeVoice"},{"text":") combines the bits of two numbers. It returns a new number whose bits are set to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" only if the bits were equal to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" in ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"both"}]},{"text":" input numbers:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitwiseAND"}],"type":"paragraph"},{"inlineContent":[{"text":"In the example below, the values of ","type":"text"},{"type":"codeVoice","code":"firstSixBits"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"lastSixBits"},{"text":" both have four middle bits equal to ","type":"text"},{"type":"codeVoice","code":"1"},{"text":". The bitwise AND operator combines them to make the number ","type":"text"},{"type":"codeVoice","code":"00111100"},{"text":", which is equal to an unsigned decimal value of ","type":"text"},{"type":"codeVoice","code":"60"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["let firstSixBits: UInt8 = 0b11111100","let lastSixBits: UInt8  = 0b00111111","let middleFourBits = firstSixBits & lastSixBits  \/\/ equals 00111100"],"syntax":"swift","type":"codeListing"},{"anchor":"Bitwise-OR-Operator","text":"Bitwise OR Operator","type":"heading","level":3},{"inlineContent":[{"text":"The ","type":"text"},{"inlineContent":[{"text":"bitwise OR operator","type":"text"}],"type":"emphasis"},{"text":" (","type":"text"},{"code":"|","type":"codeVoice"},{"text":") compares the bits of two numbers. The operator returns a new number whose bits are set to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" if the bits are equal to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" in ","type":"text"},{"inlineContent":[{"text":"either","type":"text"}],"type":"emphasis"},{"text":" input number:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"bitwiseOR","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"In the example below, the values of ","type":"text"},{"code":"someBits","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"moreBits","type":"codeVoice"},{"text":" have different bits set to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":". The bitwise OR operator combines them to make the number ","type":"text"},{"code":"11111110","type":"codeVoice"},{"text":", which equals an unsigned decimal of ","type":"text"},{"code":"254","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["let someBits: UInt8 = 0b10110010","let moreBits: UInt8 = 0b01011110","let combinedbits = someBits | moreBits  \/\/ equals 11111110"],"syntax":"swift","type":"codeListing"},{"anchor":"Bitwise-XOR-Operator","text":"Bitwise XOR Operator","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"bitwise XOR operator","type":"text"}]},{"type":"text","text":", or “exclusive OR operator” ("},{"type":"codeVoice","code":"^"},{"type":"text","text":"), compares the bits of two numbers. The operator returns a new number whose bits are set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" where the input bits are different and are set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" where the input bits are the same:"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitwiseXOR"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"In the example below, the values of "},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"type":"codeVoice","code":"otherBits"},{"type":"text","text":" each have a bit set to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" in a location that the other does not. The bitwise XOR operator sets both of these bits to "},{"code":"1","type":"codeVoice"},{"text":" in its output value. All of the other bits in ","type":"text"},{"code":"firstBits","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"otherBits","type":"codeVoice"},{"text":" match and are set to ","type":"text"},{"code":"0","type":"codeVoice"},{"text":" in the output value:","type":"text"}],"type":"paragraph"},{"code":["let firstBits: UInt8 = 0b00010100","let otherBits: UInt8 = 0b00000101","let outputBits = firstBits ^ otherBits  \/\/ equals 00010001"],"syntax":"swift","type":"codeListing"},{"anchor":"Bitwise-Left-and-Right-Shift-Operators","text":"Bitwise Left and Right Shift Operators","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"bitwise left shift operator","type":"text"}],"type":"emphasis"},{"type":"text","text":" ("},{"code":"<<","type":"codeVoice"},{"type":"text","text":") and "},{"inlineContent":[{"type":"text","text":"bitwise right shift operator"}],"type":"emphasis"},{"type":"text","text":" ("},{"code":">>","type":"codeVoice"},{"type":"text","text":") move all bits in a number to the left or the right by a certain number of places, according to the rules defined below."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Bitwise left and right shifts have the effect of multiplying or dividing an integer by a factor of two. Shifting an integer’s bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value."}],"type":"paragraph"},{"anchor":"Shifting-Behavior-for-Unsigned-Integers","text":"Shifting Behavior for Unsigned Integers","type":"heading","level":4},{"inlineContent":[{"text":"The bit-shifting behavior for unsigned integers is as follows:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Existing bits are moved to the left or right by the requested number of places."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Any bits that are moved beyond the bounds of the integer’s storage are discarded."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Zeros are inserted in the spaces left behind after the original bits are moved to the left or right.","type":"text"}]}]}],"type":"orderedList"},{"inlineContent":[{"text":"This approach is known as a ","type":"text"},{"inlineContent":[{"text":"logical shift","type":"text"}],"type":"emphasis"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The illustration below shows the results of ","type":"text"},{"code":"11111111 << 1","type":"codeVoice"},{"text":" (which is ","type":"text"},{"code":"11111111","type":"codeVoice"},{"text":" shifted to the left by ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" place), and ","type":"text"},{"code":"11111111 >> 1","type":"codeVoice"},{"text":" (which is ","type":"text"},{"code":"11111111","type":"codeVoice"},{"text":" shifted to the right by ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" place). Blue numbers are shifted, gray numbers are discarded, and orange zeros are inserted:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitshiftUnsigned"}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s how bit shifting looks in Swift code:","type":"text"}],"type":"paragraph"},{"code":["let shiftBits: UInt8 = 4   \/\/ 00000100 in binary","shiftBits << 1             \/\/ 00001000","shiftBits << 2             \/\/ 00010000","shiftBits << 5             \/\/ 10000000","shiftBits << 6             \/\/ 00000000","shiftBits >> 2             \/\/ 00000001"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"You can use bit shifting to encode and decode values within other data types:"}],"type":"paragraph"},{"code":["let pink: UInt32 = 0xCC6699","let redComponent = (pink & 0xFF0000) >> 16    \/\/ redComponent is 0xCC, or 204","let greenComponent = (pink & 0x00FF00) >> 8   \/\/ greenComponent is 0x66, or 102","let blueComponent = pink & 0x0000FF           \/\/ blueComponent is 0x99, or 153"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"This example uses a ","type":"text"},{"code":"UInt32","type":"codeVoice"},{"text":" constant called ","type":"text"},{"code":"pink","type":"codeVoice"},{"text":" to store a Cascading Style Sheets color value for the color pink. The CSS color value ","type":"text"},{"code":"#CC6699","type":"codeVoice"},{"text":" is written as ","type":"text"},{"code":"0xCC6699","type":"codeVoice"},{"text":" in Swift’s hexadecimal number representation. This color is then decomposed into its red (","type":"text"},{"code":"CC","type":"codeVoice"},{"text":"), green (","type":"text"},{"code":"66","type":"codeVoice"},{"text":"), and blue (","type":"text"},{"code":"99","type":"codeVoice"},{"text":") components by the bitwise AND operator (","type":"text"},{"code":"&","type":"codeVoice"},{"text":") and the bitwise right shift operator (","type":"text"},{"code":">>","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The red component is obtained by performing a bitwise AND between the numbers ","type":"text"},{"type":"codeVoice","code":"0xCC6699"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"0xFF0000"},{"text":". The zeros in ","type":"text"},{"type":"codeVoice","code":"0xFF0000"},{"text":" effectively “mask” the second and third bytes of ","type":"text"},{"type":"codeVoice","code":"0xCC6699"},{"text":", causing the ","type":"text"},{"type":"codeVoice","code":"6699"},{"text":" to be ignored and leaving ","type":"text"},{"type":"codeVoice","code":"0xCC0000"},{"text":" as the result.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This number is then shifted 16 places to the right ("},{"type":"codeVoice","code":">> 16"},{"type":"text","text":"). Each pair of characters in a hexadecimal number uses 8 bits, so a move 16 places to the right will convert "},{"type":"codeVoice","code":"0xCC0000"},{"type":"text","text":" into "},{"type":"codeVoice","code":"0x0000CC"},{"type":"text","text":". This is the same as "},{"type":"codeVoice","code":"0xCC"},{"type":"text","text":", which has a decimal value of "},{"type":"codeVoice","code":"204"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Similarly, the green component is obtained by performing a bitwise AND between the numbers "},{"code":"0xCC6699","type":"codeVoice"},{"type":"text","text":" and "},{"code":"0x00FF00","type":"codeVoice"},{"type":"text","text":", which gives an output value of "},{"code":"0x006600","type":"codeVoice"},{"type":"text","text":". This output value is then shifted eight places to the right, giving a value of "},{"code":"0x66","type":"codeVoice"},{"type":"text","text":", which has a decimal value of "},{"code":"102","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"Finally, the blue component is obtained by performing a bitwise AND between the numbers ","type":"text"},{"type":"codeVoice","code":"0xCC6699"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"0x0000FF"},{"text":", which gives an output value of ","type":"text"},{"type":"codeVoice","code":"0x000099"},{"text":". Because ","type":"text"},{"type":"codeVoice","code":"0x000099"},{"text":" already equals ","type":"text"},{"type":"codeVoice","code":"0x99"},{"text":", which has a decimal value of ","type":"text"},{"type":"codeVoice","code":"153"},{"text":", this value is used without shifting it to the right,","type":"text"}],"type":"paragraph"},{"anchor":"Shifting-Behavior-for-Signed-Integers","text":"Shifting Behavior for Signed Integers","type":"heading","level":4},{"inlineContent":[{"type":"text","text":"The shifting behavior is more complex for signed integers than for unsigned integers, because of the way signed integers are represented in binary. (The examples below are based on 8-bit signed integers for simplicity, but the same principles apply for signed integers of any size.)"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Signed integers use their first bit (known as the "},{"type":"emphasis","inlineContent":[{"text":"sign bit","type":"text"}]},{"type":"text","text":") to indicate whether the integer is positive or negative. A sign bit of "},{"type":"codeVoice","code":"0"},{"type":"text","text":" means positive, and a sign bit of "},{"type":"codeVoice","code":"1"},{"type":"text","text":" means negative."}],"type":"paragraph"},{"inlineContent":[{"text":"The remaining bits (known as the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"value bits"}]},{"text":") store the actual value. Positive numbers are stored in exactly the same way as for unsigned integers, counting upwards from ","type":"text"},{"type":"codeVoice","code":"0"},{"text":". Here’s how the bits inside an ","type":"text"},{"type":"codeVoice","code":"Int8"},{"text":" look for the number ","type":"text"},{"type":"codeVoice","code":"4"},{"text":":","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"bitshiftSignedFour","type":"image"}],"type":"paragraph"},{"inlineContent":[{"text":"The sign bit is ","type":"text"},{"code":"0","type":"codeVoice"},{"text":" (meaning “positive”), and the seven value bits are just the number ","type":"text"},{"code":"4","type":"codeVoice"},{"text":", written in binary notation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Negative numbers, however, are stored differently. They’re stored by subtracting their absolute value from "},{"code":"2","type":"codeVoice"},{"type":"text","text":" to the power of "},{"code":"n","type":"codeVoice"},{"type":"text","text":", where "},{"code":"n","type":"codeVoice"},{"type":"text","text":" is the number of value bits. An eight-bit number has seven value bits, so this means "},{"code":"2","type":"codeVoice"},{"type":"text","text":" to the power of "},{"code":"7","type":"codeVoice"},{"type":"text","text":", or "},{"code":"128","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s how the bits inside an ","type":"text"},{"type":"codeVoice","code":"Int8"},{"text":" look for the number ","type":"text"},{"type":"codeVoice","code":"-4"},{"text":":","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFour"}],"type":"paragraph"},{"inlineContent":[{"text":"This time, the sign bit is ","type":"text"},{"type":"codeVoice","code":"1"},{"text":" (meaning “negative”), and the seven value bits have a binary value of ","type":"text"},{"type":"codeVoice","code":"124"},{"text":" (which is ","type":"text"},{"type":"codeVoice","code":"128 - 4"},{"text":"):","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFourValue"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This encoding for negative numbers is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"two’s complement"}]},{"type":"text","text":" representation. It may seem an unusual way to represent negative numbers, but it has several advantages."}],"type":"paragraph"},{"inlineContent":[{"text":"First, you can add ","type":"text"},{"type":"codeVoice","code":"-1"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"-4"},{"text":", simply by performing a standard binary addition of all eight bits (including the sign bit), and discarding anything that doesn’t fit in the eight bits once you’re done:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitshiftSignedAddition"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Second, the two’s complement representation also lets you shift the bits of negative numbers to the left and right like positive numbers, and still end up doubling them for every shift you make to the left, or halving them for every shift you make to the right. To achieve this, an extra rule is used when signed integers are shifted to the right: When you shift signed integers to the right, apply the same rules as for unsigned integers, but fill any empty bits on the left with the "},{"inlineContent":[{"type":"text","text":"sign bit"}],"type":"emphasis"},{"type":"text","text":", rather than with a zero."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"bitshiftSigned"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This action ensures that signed integers have the same sign after they’re shifted to the right, and is known as an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"arithmetic shift"}]},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Because of the special way that positive and negative numbers are stored, shifting either of them to the right moves them closer to zero. Keeping the sign bit the same during this shift means that negative integers remain negative as their value moves closer to zero."}],"type":"paragraph"},{"anchor":"Overflow-Operators","text":"Overflow Operators","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"If you try to insert a number into an integer constant or variable that can’t hold that value, by default Swift reports an error rather than allowing an invalid value to be created. This behavior gives extra safety when you work with numbers that are too large or too small."}],"type":"paragraph"},{"inlineContent":[{"text":"For example, the ","type":"text"},{"type":"codeVoice","code":"Int16"},{"text":" integer type can hold any signed integer between ","type":"text"},{"type":"codeVoice","code":"-32768"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"32767"},{"text":". Trying to set an ","type":"text"},{"type":"codeVoice","code":"Int16"},{"text":" constant or variable to a number outside of this range causes an error:","type":"text"}],"type":"paragraph"},{"code":["var potentialOverflow = Int16.max","\/\/ potentialOverflow equals 32767, which is the maximum value an Int16 can hold","potentialOverflow += 1","\/\/ this causes an error"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Providing error handling when values get too large or too small gives you much more flexibility when coding for boundary value conditions.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, when you specifically want an overflow condition to truncate the number of available bits, you can opt in to this behavior rather than triggering an error. Swift provides three arithmetic "},{"type":"emphasis","inlineContent":[{"text":"overflow operators","type":"text"}]},{"type":"text","text":" that opt in to the overflow behavior for integer calculations. These operators all begin with an ampersand ("},{"type":"codeVoice","code":"&"},{"type":"text","text":"):"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Overflow addition (","type":"text"},{"code":"&+","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Overflow subtraction (","type":"text"},{"code":"&-","type":"codeVoice"},{"text":")","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overflow multiplication ("},{"type":"codeVoice","code":"&*"},{"type":"text","text":")"}]}]}],"type":"unorderedList"},{"anchor":"Value-Overflow","text":"Value Overflow","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Numbers can overflow in both the positive and negative direction."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s an example of what happens when an unsigned integer is allowed to overflow in the positive direction, using the overflow addition operator (","type":"text"},{"code":"&+","type":"codeVoice"},{"text":"):","type":"text"}],"type":"paragraph"},{"code":["var unsignedOverflow = UInt8.max","\/\/ unsignedOverflow equals 255, which is the maximum value a UInt8 can hold","unsignedOverflow = unsignedOverflow &+ 1","\/\/ unsignedOverflow is now equal to 0"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The variable ","type":"text"},{"code":"unsignedOverflow","type":"codeVoice"},{"text":" is initialized with the maximum value a ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":" can hold (","type":"text"},{"code":"255","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"11111111","type":"codeVoice"},{"text":" in binary). It’s then incremented by ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" using the overflow addition operator (","type":"text"},{"code":"&+","type":"codeVoice"},{"text":"). This pushes its binary representation just over the size that a ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":" can hold, causing it to overflow beyond its bounds, as shown in the diagram below. The value that remains within the bounds of the ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":" after the overflow addition is ","type":"text"},{"code":"00000000","type":"codeVoice"},{"text":", or zero.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"overflowAddition"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Something similar happens when an unsigned integer is allowed to overflow in the negative direction. Here’s an example using the overflow subtraction operator ("},{"code":"&-","type":"codeVoice"},{"type":"text","text":"):"}],"type":"paragraph"},{"code":["var unsignedOverflow = UInt8.min","\/\/ unsignedOverflow equals 0, which is the minimum value a UInt8 can hold","unsignedOverflow = unsignedOverflow &- 1","\/\/ unsignedOverflow is now equal to 255"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The minimum value that a "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" can hold is zero, or "},{"code":"00000000","type":"codeVoice"},{"type":"text","text":" in binary. If you subtract "},{"code":"1","type":"codeVoice"},{"type":"text","text":" from "},{"code":"00000000","type":"codeVoice"},{"type":"text","text":" using the overflow subtraction operator ("},{"code":"&-","type":"codeVoice"},{"type":"text","text":"), the number will overflow and wrap around to "},{"code":"11111111","type":"codeVoice"},{"type":"text","text":", or "},{"code":"255","type":"codeVoice"},{"type":"text","text":" in decimal."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"overflowUnsignedSubtraction"}],"type":"paragraph"},{"inlineContent":[{"text":"Overflow also occurs for signed integers. All addition and subtraction for signed integers is performed in bitwise fashion, with the sign bit included as part of the numbers being added or subtracted, as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"code":["var signedOverflow = Int8.min","\/\/ signedOverflow equals -128, which is the minimum value an Int8 can hold","signedOverflow = signedOverflow &- 1","\/\/ signedOverflow is now equal to 127"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The minimum value that an ","type":"text"},{"code":"Int8","type":"codeVoice"},{"text":" can hold is ","type":"text"},{"code":"-128","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"10000000","type":"codeVoice"},{"text":" in binary. Subtracting ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" from this binary number with the overflow operator gives a binary value of ","type":"text"},{"code":"01111111","type":"codeVoice"},{"text":", which toggles the sign bit and gives positive ","type":"text"},{"code":"127","type":"codeVoice"},{"text":", the maximum positive value that an ","type":"text"},{"code":"Int8","type":"codeVoice"},{"text":" can hold.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"overflowSignedSubtraction"}],"type":"paragraph"},{"inlineContent":[{"text":"For both signed and unsigned integers, overflow in the positive direction wraps around from the maximum valid integer value back to the minimum, and overflow in the negative direction wraps around from the minimum value to the maximum.","type":"text"}],"type":"paragraph"},{"anchor":"Precedence-and-Associativity","text":"Precedence and Associativity","type":"heading","level":2},{"inlineContent":[{"text":"Operator ","type":"text"},{"inlineContent":[{"type":"text","text":"precedence"}],"type":"emphasis"},{"text":" gives some operators higher priority than others; these operators are applied first.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Operator "},{"inlineContent":[{"type":"text","text":"associativity"}],"type":"emphasis"},{"type":"text","text":" defines how operators of the same precedence are grouped together—either grouped from the left, or grouped from the right. Think of it as meaning “they associate with the expression to their left,” or “they associate with the expression to their right.”"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It’s important to consider each operator’s precedence and associativity when working out the order in which a compound expression will be calculated. For example, operator precedence explains why the following expression equals "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["2 + 3 % 4 * 5","\/\/ this equals 17"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"If you read strictly from left to right, you might expect the expression to be calculated as follows:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"code":"2","type":"codeVoice"},{"type":"text","text":" plus "},{"code":"3","type":"codeVoice"},{"type":"text","text":" equals "},{"code":"5","type":"codeVoice"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"5"},{"type":"text","text":" remainder "},{"type":"codeVoice","code":"4"},{"type":"text","text":" equals "},{"type":"codeVoice","code":"1"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"1"},{"type":"text","text":" times "},{"type":"codeVoice","code":"5"},{"type":"text","text":" equals "},{"type":"codeVoice","code":"5"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"However, the actual answer is ","type":"text"},{"code":"17","type":"codeVoice"},{"text":", not ","type":"text"},{"code":"5","type":"codeVoice"},{"text":". Higher-precedence operators are evaluated before lower-precedence ones. In Swift, as in C, the remainder operator (","type":"text"},{"code":"%","type":"codeVoice"},{"text":") and the multiplication operator (","type":"text"},{"code":"*","type":"codeVoice"},{"text":") have a higher precedence than the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":"). As a result, they’re both evaluated before the addition is considered.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, remainder and multiplication have the "},{"type":"emphasis","inlineContent":[{"text":"same","type":"text"}]},{"type":"text","text":" precedence as each other. To work out the exact evaluation order to use, you also need to consider their associativity. Remainder and multiplication both associate with the expression to their left. Think of this as adding implicit parentheses around these parts of the expression, starting from their left:"}],"type":"paragraph"},{"code":["2 + ((3 % 4) * 5)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"code":"(3 % 4)","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"3","type":"codeVoice"},{"text":", so this is equivalent to:","type":"text"}],"type":"paragraph"},{"code":["2 + (3 * 5)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"codeVoice","code":"(3 * 5)"},{"type":"text","text":" is "},{"type":"codeVoice","code":"15"},{"type":"text","text":", so this is equivalent to:"}],"type":"paragraph"},{"code":["2 + 15"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This calculation yields the final answer of "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations]","type":"text"},{"text":".","type":"text"}],"type":"paragraph"},{"name":"Note","style":"note","content":[{"inlineContent":[{"text":"Swift’s operator precedences and associativity rules are simpler and more predictable than those found in C and Objective-C. However, this means that they aren’t exactly the same as in C-based languages. Be careful to ensure that operator interactions still behave in the way you intend when porting existing code to Swift.","type":"text"}],"type":"paragraph"}],"type":"aside"},{"anchor":"Operator-Methods","text":"Operator Methods","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Classes and structures can provide their own implementations of existing operators. This is known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"overloading"}]},{"type":"text","text":" the existing operators."}],"type":"paragraph"},{"inlineContent":[{"text":"The example below shows how to implement the arithmetic addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") for a custom structure. The arithmetic addition operator is a binary operator because it operates on two targets and it’s an infix operator because it appears between those two targets.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example defines a "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" structure for a two-dimensional position vector "},{"code":"(x, y)","type":"codeVoice"},{"type":"text","text":", followed by a definition of an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator method"}]},{"type":"text","text":" to add together instances of the "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" structure:"}],"type":"paragraph"},{"code":["struct Vector2D {","    var x = 0.0, y = 0.0","}","","extension Vector2D {","    static func + (left: Vector2D, right: Vector2D) -> Vector2D {","        return Vector2D(x: left.x + right.x, y: left.y + right.y)","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The operator method is defined as a type method on "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":", with a method name that matches the operator to be overloaded ("},{"code":"+","type":"codeVoice"},{"type":"text","text":"). Because addition isn’t part of the essential behavior for a vector, the type method is defined in an extension of "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" rather than in the main structure declaration of "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":". Because the arithmetic addition operator is a binary operator, this operator method takes two input parameters of type "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" and returns a single output value, also of type "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"In this implementation, the input parameters are named ","type":"text"},{"type":"codeVoice","code":"left"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"right"},{"text":" to represent the ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instances that will be on the left side and right side of the ","type":"text"},{"type":"codeVoice","code":"+"},{"text":" operator. The method returns a new ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instance, whose ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" properties are initialized with the sum of the ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" properties from the two ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instances that are added together.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The type method can be used as an infix operator between existing "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" instances:"}],"type":"paragraph"},{"code":["let vector = Vector2D(x: 3.0, y: 1.0)","let anotherVector = Vector2D(x: 2.0, y: 4.0)","let combinedVector = vector + anotherVector","\/\/ combinedVector is a Vector2D instance with values of (5.0, 5.0)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This example adds together the vectors "},{"code":"(3.0, 1.0)","type":"codeVoice"},{"type":"text","text":" and "},{"code":"(2.0, 4.0)","type":"codeVoice"},{"type":"text","text":" to make the vector "},{"code":"(5.0, 5.0)","type":"codeVoice"},{"type":"text","text":", as illustrated below."}],"type":"paragraph"},{"inlineContent":[{"identifier":"vectorAddition","type":"image"}],"type":"paragraph"},{"anchor":"Prefix-and-Postfix-Operators","text":"Prefix and Postfix Operators","type":"heading","level":3},{"inlineContent":[{"text":"The example shown above demonstrates a custom implementation of a binary infix operator. Classes and structures can also provide implementations of the standard ","type":"text"},{"inlineContent":[{"type":"text","text":"unary operators"}],"type":"emphasis"},{"text":". Unary operators operate on a single target. They’re ","type":"text"},{"inlineContent":[{"type":"text","text":"prefix"}],"type":"emphasis"},{"text":" if they precede their target (such as ","type":"text"},{"code":"-a","type":"codeVoice"},{"text":") and ","type":"text"},{"inlineContent":[{"text":"postfix","type":"text"}],"type":"emphasis"},{"text":" operators if they follow their target (such as ","type":"text"},{"code":"b!","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You implement a prefix or postfix unary operator by writing the ","type":"text"},{"type":"codeVoice","code":"prefix"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"postfix"},{"text":" modifier before the ","type":"text"},{"type":"codeVoice","code":"func"},{"text":" keyword when declaring the operator method:","type":"text"}],"type":"paragraph"},{"code":["extension Vector2D {","    static prefix func - (vector: Vector2D) -> Vector2D {","        return Vector2D(x: -vector.x, y: -vector.y)","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The example above implements the unary minus operator ("},{"type":"codeVoice","code":"-a"},{"type":"text","text":") for "},{"type":"codeVoice","code":"Vector2D"},{"text":" instances. The unary minus operator is a prefix operator, and so this method has to be qualified with the ","type":"text"},{"type":"codeVoice","code":"prefix"},{"text":" modifier.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"For simple numeric values, the unary minus operator converts positive numbers into their negative equivalent and vice versa. The corresponding implementation for ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instances performs this operation on both the ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" properties:","type":"text"}],"type":"paragraph"},{"code":["let positive = Vector2D(x: 3.0, y: 4.0)","let negative = -positive","\/\/ negative is a Vector2D instance with values of (-3.0, -4.0)","let alsoPositive = -negative","\/\/ alsoPositive is a Vector2D instance with values of (3.0, 4.0)"],"syntax":"swift","type":"codeListing"},{"anchor":"Compound-Assignment-Operators","text":"Compound Assignment Operators","type":"heading","level":3},{"inlineContent":[{"inlineContent":[{"text":"Compound assignment operators","type":"text"}],"type":"emphasis"},{"text":" combine assignment (","type":"text"},{"code":"=","type":"codeVoice"},{"text":") with another operation. For example, the addition assignment operator (","type":"text"},{"code":"+=","type":"codeVoice"},{"text":") combines addition and assignment into a single operation. You mark a compound assignment operator’s left input parameter type as ","type":"text"},{"code":"inout","type":"codeVoice"},{"text":", because the parameter’s value will be modified directly from within the operator method.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The example below implements an addition assignment operator method for ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"text":" instances:","type":"text"}],"type":"paragraph"},{"code":["extension Vector2D {","    static func += (left: inout Vector2D, right: Vector2D) {","        left = left + right","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Because an addition operator was defined earlier, you don’t need to reimplement the addition process here. Instead, the addition assignment operator method takes advantage of the existing addition operator method, and uses it to set the left value to be the left value plus the right value:"}],"type":"paragraph"},{"code":["var original = Vector2D(x: 1.0, y: 2.0)","let vectorToAdd = Vector2D(x: 3.0, y: 4.0)","original += vectorToAdd","\/\/ original now has values of (4.0, 6.0)"],"syntax":"swift","type":"codeListing"},{"name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It isn’t possible to overload the default assignment operator ("},{"code":"=","type":"codeVoice"},{"type":"text","text":"). Only the compound assignment operators can be overloaded. Similarly, the ternary conditional operator ("},{"code":"a ? b : c","type":"codeVoice"},{"type":"text","text":") can’t be overloaded."}]}],"type":"aside"},{"anchor":"Equivalence-Operators","text":"Equivalence Operators","type":"heading","level":3},{"inlineContent":[{"text":"By default, custom classes and structures don’t have an implementation of the ","type":"text"},{"inlineContent":[{"type":"text","text":"equivalence operators"}],"type":"emphasis"},{"text":", known as the ","type":"text"},{"inlineContent":[{"type":"text","text":"equal to"}],"type":"emphasis"},{"text":" operator (","type":"text"},{"code":"==","type":"codeVoice"},{"text":") and ","type":"text"},{"inlineContent":[{"text":"not equal to","type":"text"}],"type":"emphasis"},{"text":" operator (","type":"text"},{"code":"!=","type":"codeVoice"},{"text":"). You usually implement the ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" operator, and use the standard library’s default implementation of the ","type":"text"},{"code":"!=","type":"codeVoice"},{"text":" operator that negates the result of the ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" operator. There are two ways to implement the ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" operator: You can implement it yourself, or for many types, you can ask Swift to synthesize an implementation for you. In both cases, you add conformance to the standard library’s ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" protocol.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You provide an implementation of the ","type":"text"},{"type":"codeVoice","code":"=="},{"text":" operator in the same way as you implement other infix operators:","type":"text"}],"type":"paragraph"},{"code":["extension Vector2D: Equatable {","    static func == (left: Vector2D, right: Vector2D) -> Bool {","        return (left.x == right.x) && (left.y == right.y)","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The example above implements an "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator to check whether two "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" instances have equivalent values. In the context of "},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":", it makes sense to consider “equal” as meaning “both instances have the same "},{"code":"x","type":"codeVoice"},{"type":"text","text":" values and "},{"code":"y","type":"codeVoice"},{"type":"text","text":" values”, and so this is the logic used by the operator implementation."}],"type":"paragraph"},{"inlineContent":[{"text":"You can now use this operator to check whether two ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instances are equivalent:","type":"text"}],"type":"paragraph"},{"code":["let twoThree = Vector2D(x: 2.0, y: 3.0)","let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)","if twoThree == anotherTwoThree {","    print(\"These two vectors are equivalent.\")","}","\/\/ Prints \"These two vectors are equivalent.\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In many simple cases, you can ask Swift to provide synthesized implementations of the equivalence operators for you, as described in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Custom-Operators","type":"heading","text":"Custom Operators","level":2},{"inlineContent":[{"text":"You can declare and implement your own ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"custom operators","type":"text"}]},{"text":" in addition to the standard operators provided by Swift. For a list of characters that can be used to define custom operators, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/LexicalStructure#Operators","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"New operators are declared at a global level using the ","type":"text"},{"type":"codeVoice","code":"operator"},{"text":" keyword, and are marked with the ","type":"text"},{"type":"codeVoice","code":"prefix"},{"text":", ","type":"text"},{"type":"codeVoice","code":"infix"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"postfix"},{"text":" modifiers:","type":"text"}],"type":"paragraph"},{"code":["prefix operator +++"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The example above defines a new prefix operator called ","type":"text"},{"code":"+++","type":"codeVoice"},{"text":". This operator doesn’t have an existing meaning in Swift, and so it’s given its own custom meaning below in the specific context of working with ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"text":" instances. For the purposes of this example, ","type":"text"},{"code":"+++","type":"codeVoice"},{"text":" is treated as a new “prefix doubling” operator. It doubles the ","type":"text"},{"code":"x","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"y","type":"codeVoice"},{"text":" values of a ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"text":" instance, by adding the vector to itself with the addition assignment operator defined earlier. To implement the ","type":"text"},{"code":"+++","type":"codeVoice"},{"text":" operator, you add a type method called ","type":"text"},{"code":"+++","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"text":" as follows:","type":"text"}],"type":"paragraph"},{"code":["extension Vector2D {","    static prefix func +++ (vector: inout Vector2D) -> Vector2D {","        vector += vector","        return vector","    }","}","","var toBeDoubled = Vector2D(x: 1.0, y: 4.0)","let afterDoubling = +++toBeDoubled","\/\/ toBeDoubled now has values of (2.0, 8.0)","\/\/ afterDoubling also has values of (2.0, 8.0)"],"type":"codeListing","syntax":"swift"},{"anchor":"Precedence-for-Custom-Infix-Operators","type":"heading","text":"Precedence for Custom Infix Operators","level":3},{"inlineContent":[{"type":"text","text":"Custom infix operators each belong to a precedence group. A precedence group specifies an operator’s precedence relative to other infix operators, as well as the operator’s associativity. See "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Precedence-and-Associativity"},{"type":"text","text":" for an explanation of how these characteristics affect an infix operator’s interaction with other infix operators."}],"type":"paragraph"},{"inlineContent":[{"text":"A custom infix operator that isn’t explicitly placed into a precedence group is given a default precedence group with a precedence immediately higher than the precedence of the ternary conditional operator.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The following example defines a new custom infix operator called ","type":"text"},{"code":"+-","type":"codeVoice"},{"text":", which belongs to the precedence group ","type":"text"},{"code":"AdditionPrecedence","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["infix operator +-: AdditionPrecedence","extension Vector2D {","    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {","        return Vector2D(x: left.x + right.x, y: left.y - right.y)","    }","}","let firstVector = Vector2D(x: 1.0, y: 2.0)","let secondVector = Vector2D(x: 3.0, y: 4.0)","let plusMinusVector = firstVector +- secondVector","\/\/ plusMinusVector is a Vector2D instance with values of (4.0, -2.0)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This operator adds together the ","type":"text"},{"type":"codeVoice","code":"x"},{"text":" values of two vectors, and subtracts the ","type":"text"},{"type":"codeVoice","code":"y"},{"text":" value of the second vector from the first. Because it’s in essence an “additive” operator, it has been given the same precedence group as additive infix operators such as ","type":"text"},{"type":"codeVoice","code":"+"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"-"},{"text":". For information about the operators provided by the Swift standard library, including a complete list of the operator precedence groups and associativity settings, see ","type":"text"},{"overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"reference","isActive":true,"overridingTitle":"Operator Declarations"},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations]","type":"text"},{"text":". For more information about precedence groups and to see the syntax for defining your own operators and precedence groups, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Operator-Declaration","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"You don’t specify a precedence when defining a prefix or postfix operator. However, if you apply both a prefix and a postfix operator to the same operand, the postfix operator is applied first.","type":"text"}],"type":"paragraph"}],"name":"Note"},{"anchor":"Result-Builders","type":"heading","text":"Result Builders","level":2},{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"result builder"}],"type":"emphasis"},{"text":" is a type you define that adds syntax for creating nested data, like a list or tree, in a natural, declarative way. The code that uses the result builder can include ordinary Swift syntax, like ","type":"text"},{"code":"if","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"for","type":"codeVoice"},{"text":", to handle conditional or repeated pieces of data.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The code below defines a few types for drawing on a single line using stars and text.","type":"text"}],"type":"paragraph"},{"code":["protocol Drawable {","    func draw() -> String","}","struct Line: Drawable {","    var elements: [Drawable]","    func draw() -> String {","        return elements.map { $0.draw() }.joined(separator: \"\")","    }","}","struct Text: Drawable {","    var content: String","    init(_ content: String) { self.content = content }","    func draw() -> String { return content }","}","struct Space: Drawable {","    func draw() -> String { return \" \" }","}","struct Stars: Drawable {","    var length: Int","    func draw() -> String { return String(repeating: \"*\", count: length) }","}","struct AllCaps: Drawable {","    var content: Drawable","    func draw() -> String { return content.draw().uppercased() }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Drawable"},{"type":"text","text":" protocol defines the requirement for something that can be drawn, like a line or shape: The type must implement a "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method. The "},{"type":"codeVoice","code":"Line"},{"type":"text","text":" structure represents a single-line drawing, and it serves the top-level container for most drawings. To draw a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":", the structure calls "},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" on each of the line’s components, and then concatenates the resulting strings into a single string. The "},{"type":"codeVoice","code":"Text"},{"type":"text","text":" structure wraps a string to make it part of a drawing. The "},{"type":"codeVoice","code":"AllCaps"},{"type":"text","text":" structure wraps and modifies another drawing, converting any text in the drawing to uppercase."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It’s possible to make a drawing with these types by calling their initializers:"}],"type":"paragraph"},{"code":["let name: String? = \"Ravi Patel\"","let manualDrawing = Line(elements: [","    Stars(length: 3),","    Text(\"Hello\"),","    Space(),","    AllCaps(content: Text((name ?? \"World\") + \"!\")),","    Stars(length: 2),","    ])","print(manualDrawing.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This code works, but it’s a little awkward. The deeply nested parentheses after "},{"code":"AllCaps","type":"codeVoice"},{"type":"text","text":" are hard to read. The fallback logic to use “World” when "},{"code":"name","type":"codeVoice"},{"type":"text","text":" is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" has to be done inline using the "},{"code":"??","type":"codeVoice"},{"type":"text","text":" operator, which would be difficult with anything more complex. If you needed to include switches or "},{"code":"for","type":"codeVoice"},{"type":"text","text":" loops to build up part of the drawing, there’s no way to do that. A result builder lets you rewrite code like this so that it looks like normal Swift code."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To define a result builder, you write the "},{"type":"codeVoice","code":"@resultBuilder"},{"type":"text","text":" attribute on a type declaration. For example, this code defines a result builder called "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":", which lets you use a declarative syntax to describe a drawing:"}],"type":"paragraph"},{"code":["@resultBuilder","struct DrawingBuilder {","    static func buildBlock(_ components: Drawable...) -> Drawable {","        return Line(elements: components)","    }","    static func buildEither(first: Drawable) -> Drawable {","        return first","    }","    static func buildEither(second: Drawable) -> Drawable {","        return second","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"DrawingBuilder"},{"type":"text","text":" structure defines three methods that implement parts of the result builder syntax. The "},{"type":"codeVoice","code":"buildBlock(_:)"},{"type":"text","text":" method adds support for writing a series of lines in a block of code. It combines the components in that block into a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":". The "},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"type":"text","text":" methods add support for "},{"type":"codeVoice","code":"if"},{"type":"text","text":"-"},{"type":"codeVoice","code":"else"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"You can apply the ","type":"text"},{"code":"@DrawingBuilder","type":"codeVoice"},{"text":" attribute to a function’s parameter, which turns a closure passed to the function into the value that the result builder creates from that closure. For example:","type":"text"}],"type":"paragraph"},{"code":["func draw(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return content()","}","func caps(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return AllCaps(content: content())","}","","func makeGreeting(for name: String? = nil) -> Drawable {","    let greeting = draw {","        Stars(length: 3)","        Text(\"Hello\")","        Space()","        caps {","            if let name = name {","                Text(name + \"!\")","            } else {","                Text(\"World!\")","            }","        }","        Stars(length: 2)","    }","    return greeting","}","let genericGreeting = makeGreeting()","print(genericGreeting.draw())","\/\/ Prints \"***Hello WORLD!**\"","","let personalGreeting = makeGreeting(for: \"Ravi Patel\")","print(personalGreeting.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeGreeting(for:)"},{"text":" function takes a ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" parameter and uses it to draw a personalized greeting. The ","type":"text"},{"type":"codeVoice","code":"draw(_:)"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"caps(_:)"},{"text":" functions both take a single closure as their argument, which is marked with the ","type":"text"},{"type":"codeVoice","code":"@DrawingBuilder"},{"text":" attribute. When you call those functions, you use the special syntax that ","type":"text"},{"type":"codeVoice","code":"DrawingBuilder"},{"text":" defines. Swift transforms that declarative description of a drawing into a series of calls to the methods on ","type":"text"},{"type":"codeVoice","code":"DrawingBuilder"},{"text":" to build up the value that’s passed as the function argument. For example, Swift transforms the call to ","type":"text"},{"type":"codeVoice","code":"caps(_:)"},{"text":" in that example into code like the following:","type":"text"}],"type":"paragraph"},{"code":["let capsDrawing = caps {","    let partialDrawing: Drawable","    if let name = name {","        let text = Text(name + \"!\")","        partialDrawing = DrawingBuilder.buildEither(first: text)","    } else {","        let text = Text(\"World!\")","        partialDrawing = DrawingBuilder.buildEither(second: text)","    }","    return partialDrawing","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Swift transforms the ","type":"text"},{"code":"if","type":"codeVoice"},{"text":"-","type":"text"},{"code":"else","type":"codeVoice"},{"text":" block into calls to the ","type":"text"},{"code":"buildEither(first:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"buildEither(second:)","type":"codeVoice"},{"text":" methods. Although you don’t call these methods in your own code, showing the result of the transformation makes it easier to see how Swift transforms your code when you use the ","type":"text"},{"code":"DrawingBuilder","type":"codeVoice"},{"text":" syntax.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To add support for writing "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops in the special drawing syntax, add a "},{"type":"codeVoice","code":"buildArray(_:)"},{"type":"text","text":" method."}],"type":"paragraph"},{"code":["extension DrawingBuilder {","    static func buildArray(_ components: [Drawable]) -> Drawable {","        return Line(elements: components)","    }","}","let manyStars = draw {","    Text(\"Stars:\")","    for length in 1...3 {","        Space()","        Stars(length: length)","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In the code above, the "},{"code":"for","type":"codeVoice"},{"type":"text","text":" loop creates an array of drawings, and the "},{"code":"buildArray(_:)","type":"codeVoice"},{"type":"text","text":" method turns that array into a "},{"code":"Line","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For a complete list of how Swift transforms builder syntax into calls to the builder type’s methods, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Attributes#resultBuilder","isActive":true},{"type":"text","text":"."}],"type":"paragraph"}],"kind":"content"}],"variants":[{"paths":["\/documentation\/swift\/advancedoperators"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","role":"article","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","type":"topic"},"bitshiftUnsigned":{"alt":null,"identifier":"bitshiftUnsigned","variants":[{"url":"\/images\/bitshiftUnsigned@2x.png","traits":["2x","light"]}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"title":"Nested Types","url":"\/documentation\/swift\/nestedtypes","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"nested types","type":"text"}]},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Structures"}]},{"text":" and ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"classes","type":"text"}]},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","kind":"article","url":"\/documentation\/swift\/classesandstructures","title":"Structures and Classes"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators":{"url":"\/documentation\/swift\/advancedoperators#Bitwise-Left-and-Right-Shift-Operators","kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Bitwise-Left-and-Right-Shift-Operators","title":"Bitwise Left and Right Shift Operators","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","url":"\/documentation\/swift\/functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","role":"article","type":"topic"},"bitwiseAND":{"identifier":"bitwiseAND","alt":null,"type":"image","variants":[{"url":"\/images\/bitwiseAND@2x.png","traits":["2x","light"]}]},"bitwiseXOR":{"identifier":"bitwiseXOR","alt":null,"type":"image","variants":[{"url":"\/images\/bitwiseXOR@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/Declarations#Operator-Declaration":{"url":"\/documentation\/swift\/declarations#Operator-Declaration","title":"Operator Declaration","type":"topic","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Operator-Declaration","kind":"section"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","kind":"article","type":"topic","url":"\/documentation\/swift\/optionalchaining","role":"article","title":"Optional Chaining","abstract":[{"inlineContent":[{"text":"Optional chaining","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", the property, method, or subscript call returns "},{"code":"nil","type":"codeVoice"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}]},"doc://com.apple.Swift/documentation/Swift/Closures":{"url":"\/documentation\/swift\/closures","role":"article","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"text":" is called immediately before a class instance is deallocated. You write deinitializers with the ","type":"text"},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","kind":"article","url":"\/documentation\/swift\/deinitialization","title":"Deinitialization"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"title":"Automatic Reference Counting","url":"\/documentation\/swift\/automaticreferencecounting","abstract":[{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"title":"Initialization","url":"\/documentation\/swift\/initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","role":"article","type":"topic"},"bitshiftSignedMinusFour":{"identifier":"bitshiftSignedMinusFour","alt":null,"type":"image","variants":[{"url":"\/images\/bitshiftSignedMinusFour@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/Extensions":{"role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","kind":"article","url":"\/documentation\/swift\/extensions","title":"Extensions"},"doc://com.apple.Swift/documentation/Swift/LexicalStructure#Operators":{"title":"Operators","abstract":[],"kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/LexicalStructure#Operators","type":"topic","url":"\/documentation\/swift\/lexicalstructure#Operators"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","url":"\/documentation\/swift\/accesscontrol","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Access control"}]},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"title":"Opaque Types","role":"article","kind":"article","url":"\/documentation\/swift\/opaquetypes","type":"topic","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"role":"article","abstract":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","kind":"article","url":"\/documentation\/swift\/enumerations","title":"Enumerations"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"title":"Control Flow","url":"\/documentation\/swift\/controlflow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"continue"},{"text":" to transfer the flow of execution to another point in your code.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"url":"\/documentation\/swift\/stringsandcharacters","role":"article","title":"Strings and Characters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"text":" type. The contents of a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"type":"codeVoice","code":"Character"},{"text":" values.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"topic"},"overflowUnsignedSubtraction":{"identifier":"overflowUnsignedSubtraction","alt":null,"type":"image","variants":[{"url":"\/images\/overflowUnsignedSubtraction@2x.png","traits":["2x","light"]}]},"bitshiftSignedAddition":{"identifier":"bitshiftSignedAddition","alt":null,"type":"image","variants":[{"url":"\/images\/bitshiftSignedAddition@2x.png","traits":["2x","light"]}]},"bitwiseOR":{"identifier":"bitwiseOR","alt":null,"type":"image","variants":[{"url":"\/images\/bitwiseOR@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation":{"type":"topic","kind":"section","abstract":[],"title":"Adopting a Protocol Using a Synthesized Implementation","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation","url":"\/documentation\/swift\/protocols#Adopting-a-Protocol-Using-a-Synthesized-Implementation"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"title":"Subscripts","url":"\/documentation\/swift\/subscripts","abstract":[{"text":"Classes, structures, and enumerations can define ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" instance as "},{"code":"someArray[index]","type":"codeVoice"},{"type":"text","text":" and elements in a "},{"code":"Dictionary","type":"codeVoice"},{"text":" instance as ","type":"text"},{"type":"codeVoice","code":"someDictionary[key]"},{"text":".","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Generics":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"url":"\/documentation\/swift\/generics","role":"article","title":"Generics","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","type":"topic","kind":"article"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"title":"Memory Safety","url":"\/documentation\/swift\/memorysafety","abstract":[{"text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors.","type":"text"}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","role":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"url":"\/documentation\/swift\/errorhandling","role":"article","title":"Error Handling","abstract":[{"inlineContent":[{"type":"text","text":"Error handling"}],"type":"emphasis"},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators#Precedence-and-Associativity":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Precedence-and-Associativity","url":"\/documentation\/swift\/advancedoperators#Precedence-and-Associativity","title":"Precedence and Associativity","abstract":[],"type":"topic","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"role":"article","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"text":"adopted","type":"text"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"inlineContent":[{"text":"conform","type":"text"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","url":"\/documentation\/swift\/protocols","title":"Protocols"},"overflowAddition":{"variants":[{"url":"\/images\/overflowAddition@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"overflowAddition","type":"image"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","abstract":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") adds two numbers, as in ","type":"text"},{"code":"let i = 1 + 2","type":"codeVoice"},{"text":", and the logical AND operator (","type":"text"},{"code":"&&","type":"codeVoice"},{"text":") combines two Boolean values, as in ","type":"text"},{"code":"if enteredDoorCode && passedRetinaScan","type":"codeVoice"},{"text":".","type":"text"}],"kind":"article","url":"\/documentation\/swift\/basicoperators","title":"Basic Operators","type":"topic","role":"article"},"doc://com.apple.Swift/documentation/Swift":{"title":"Swift","url":"\/documentation\/swift","abstract":[],"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","role":"collection","type":"topic"},"overflowSignedSubtraction":{"variants":[{"url":"\/images\/overflowSignedSubtraction@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"overflowSignedSubtraction","type":"image"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","role":"article","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","type":"topic"},"bitshiftSigned":{"variants":[{"url":"\/images\/bitshiftSigned@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"bitshiftSigned","type":"image"},"vectorAddition":{"variants":[{"url":"\/images\/vectorAddition@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"vectorAddition","type":"image"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","role":"article","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","type":"topic"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"url":"\/documentation\/swift\/typecasting","role":"article","title":"Type Casting","abstract":[{"inlineContent":[{"type":"text","text":"Type casting"}],"type":"emphasis"},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"url":"\/documentation\/swift\/collectiontypes","role":"article","title":"Collection Types","abstract":[{"type":"text","text":"Swift provides three primary "},{"type":"emphasis","inlineContent":[{"type":"text","text":"collection types"}]},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"text":"inherit","type":"text"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"text":"subclass","type":"text"}],"type":"emphasis"},{"text":", and the class it inherits from is known as its ","type":"text"},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/inheritance","title":"Inheritance","type":"topic","role":"article"},"bitshiftSignedFour":{"variants":[{"url":"\/images\/bitshiftSignedFour@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"bitshiftSignedFour","type":"image"},"doc://com.apple.Swift/documentation/Swift/Attributes#resultBuilder":{"abstract":[],"type":"topic","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Attributes#resultBuilder","title":"resultBuilder","url":"\/documentation\/swift\/attributes#resultBuilder"},"bitwiseNOT":{"variants":[{"url":"\/images\/bitwiseNOT@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"bitwiseNOT","type":"image"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","url":"\/documentation\/swift\/concurrency","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"type":"text","text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","role":"article","type":"topic"},"bitshiftSignedMinusFourValue":{"variants":[{"url":"\/images\/bitshiftSignedMinusFourValue@2x.png","traits":["2x","light"]}],"alt":null,"identifier":"bitshiftSignedMinusFourValue","type":"image"},"https://developer.apple.com/documentation/swift/operator_declarations":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","title":"Operator Declarations","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","titleInlineContent":[{"type":"text","text":"Operator Declarations"}],"type":"link"}}}