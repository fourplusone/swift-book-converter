{"seeAlsoSections":[{"generated":true,"title":"Language Guide","identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner."}],"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","type":"heading","anchor":"overview"},{"inlineContent":[{"type":"text","text":"Generics are one of the most powerful features of Swift, and much of the Swift standard library is built with generic code. In fact, you’ve been using generics throughout the "},{"inlineContent":[{"text":"Language Guide","type":"text"}],"type":"emphasis"},{"type":"text","text":", even if you didn’t realize it. For example, Swift’s "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" types are both generic collections. You can create an array that holds "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values, or an array that holds "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values, or indeed an array for any other type that can be created in Swift. Similarly, you can create a dictionary to store values of any specified type, and there are no limitations on what that type can be."}],"type":"paragraph"},{"level":2,"text":"The Problem That Generics Solve","type":"heading","anchor":"The-Problem-That-Generics-Solve"},{"inlineContent":[{"type":"text","text":"Here’s a standard, nongeneric function called "},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"type":"text","text":", which swaps two "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values:"}],"type":"paragraph"},{"code":["func swapTwoInts(_ a: inout Int, _ b: inout Int) {","    let temporaryA = a","    a = b","    b = temporaryA","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This function makes use of in-out parameters to swap the values of ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" and ","type":"text"},{"code":"b","type":"codeVoice"},{"text":", as described in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#In-Out-Parameters","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function swaps the original value of ","type":"text"},{"code":"b","type":"codeVoice"},{"text":" into ","type":"text"},{"code":"a","type":"codeVoice"},{"text":", and the original value of ","type":"text"},{"code":"a","type":"codeVoice"},{"text":" into ","type":"text"},{"code":"b","type":"codeVoice"},{"text":". You can call this function to swap the values in two ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" variables:"}],"type":"paragraph"},{"code":["var someInt = 3","var anotherInt = 107","swapTwoInts(&someInt, &anotherInt)","print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")","\/\/ Prints \"someInt is now 107, and anotherInt is now 3\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function is useful, but it can only be used with ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" values. If you want to swap two ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" values, or two ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" values, you have to write more functions, such as the ","type":"text"},{"code":"swapTwoStrings(_:_:)","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"swapTwoDoubles(_:_:)","type":"codeVoice"},{"text":" functions shown below:","type":"text"}],"type":"paragraph"},{"code":["func swapTwoStrings(_ a: inout String, _ b: inout String) {","    let temporaryA = a","    a = b","    b = temporaryA","}","","func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {","    let temporaryA = a","    a = b","    b = temporaryA","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"You may have noticed that the bodies of the ","type":"text"},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"text":", ","type":"text"},{"type":"codeVoice","code":"swapTwoStrings(_:_:)"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"swapTwoDoubles(_:_:)"},{"text":" functions are identical. The only difference is the type of the values that they accept (","type":"text"},{"type":"codeVoice","code":"Int"},{"text":", ","type":"text"},{"type":"codeVoice","code":"String"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Double"},{"text":").","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"It’s more useful, and considerably more flexible, to write a single function that swaps two values of ","type":"text"},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"text":" type. Generic code enables you to write such a function. (A generic version of these functions is defined below.)","type":"text"}],"type":"paragraph"},{"name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"In all three functions, the types of "},{"code":"a","type":"codeVoice"},{"type":"text","text":" and "},{"code":"b","type":"codeVoice"},{"type":"text","text":" must be the same. If "},{"code":"a","type":"codeVoice"},{"type":"text","text":" and "},{"code":"b","type":"codeVoice"},{"type":"text","text":" aren’t of the same type, it isn’t possible to swap their values. Swift is a type-safe language, and doesn’t allow (for example) a variable of type "},{"code":"String","type":"codeVoice"},{"type":"text","text":" and a variable of type "},{"code":"Double","type":"codeVoice"},{"type":"text","text":" to swap values with each other. Attempting to do so results in a compile-time error."}],"type":"paragraph"}],"type":"aside"},{"level":2,"text":"Generic Functions","type":"heading","anchor":"Generic-Functions"},{"inlineContent":[{"inlineContent":[{"text":"Generic functions","type":"text"}],"type":"emphasis"},{"text":" can work with any type. Here’s a generic version of the ","type":"text"},{"code":"swapTwoInts(_:_:)","type":"codeVoice"},{"text":" function from above, called ","type":"text"},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["func swapTwoValues<T>(_ a: inout T, _ b: inout T) {","    let temporaryA = a","    a = b","    b = temporaryA","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The body of the ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"text":" function is identical to the body of the ","type":"text"},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"text":" function. However, the first line of ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"text":" is slightly different from ","type":"text"},{"type":"codeVoice","code":"swapTwoInts(_:_:)"},{"text":". Here’s how the first lines compare:","type":"text"}],"type":"paragraph"},{"code":["func swapTwoInts(_ a: inout Int, _ b: inout Int)","func swapTwoValues<T>(_ a: inout T, _ b: inout T)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The generic version of the function uses a "},{"type":"emphasis","inlineContent":[{"text":"placeholder","type":"text"}]},{"type":"text","text":" type name (called "},{"type":"codeVoice","code":"T"},{"type":"text","text":", in this case) instead of an "},{"type":"emphasis","inlineContent":[{"text":"actual","type":"text"}]},{"type":"text","text":" type name (such as "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Double"},{"type":"text","text":"). The placeholder type name doesn’t say anything about what "},{"type":"codeVoice","code":"T"},{"type":"text","text":" must be, but it "},{"type":"emphasis","inlineContent":[{"text":"does","type":"text"}]},{"type":"text","text":" say that both "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" must be of the same type "},{"type":"codeVoice","code":"T"},{"type":"text","text":", whatever "},{"type":"codeVoice","code":"T"},{"type":"text","text":" represents. The actual type to use in place of "},{"type":"codeVoice","code":"T"},{"type":"text","text":" is determined each time the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function is called."}],"type":"paragraph"},{"inlineContent":[{"text":"The other difference between a generic function and a nongeneric function is that the generic function’s name (","type":"text"},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":") is followed by the placeholder type name (","type":"text"},{"code":"T","type":"codeVoice"},{"text":") inside angle brackets (","type":"text"},{"code":"<T>","type":"codeVoice"},{"text":"). The brackets tell Swift that ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" is a placeholder type name within the ","type":"text"},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" function definition. Because ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" is a placeholder, Swift doesn’t look for an actual type called ","type":"text"},{"code":"T","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"text":" function can now be called in the same way as ","type":"text"},{"type":"codeVoice","code":"swapTwoInts"},{"text":", except that it can be passed two values of ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"text":" type, as long as both of those values are of the same type as each other. Each time ","type":"text"},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"text":" is called, the type to use for ","type":"text"},{"type":"codeVoice","code":"T"},{"text":" is inferred from the types of values passed to the function.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In the two examples below, ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" is inferred to be ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" respectively:","type":"text"}],"type":"paragraph"},{"code":["var someInt = 3","var anotherInt = 107","swapTwoValues(&someInt, &anotherInt)","\/\/ someInt is now 107, and anotherInt is now 3","","var someString = \"hello\"","var anotherString = \"world\"","swapTwoValues(&someString, &anotherString)","\/\/ someString is now \"world\", and anotherString is now \"hello\""],"type":"codeListing","syntax":"swift"},{"name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function defined above is inspired by a generic function called "},{"type":"codeVoice","code":"swap"},{"type":"text","text":", which is part of the Swift standard library, and is automatically made available for you to use in your apps. If you need the behavior of the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function in your own code, you can use Swift’s existing "},{"type":"codeVoice","code":"swap(_:_:)"},{"type":"text","text":" function rather than providing your own implementation."}]}],"type":"aside"},{"level":2,"text":"Type Parameters","type":"heading","anchor":"Type-Parameters"},{"inlineContent":[{"type":"text","text":"In the "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"type":"text","text":" example above, the placeholder type "},{"code":"T","type":"codeVoice"},{"type":"text","text":" is an example of a "},{"type":"emphasis","inlineContent":[{"text":"type parameter","type":"text"}]},{"type":"text","text":". Type parameters specify and name a placeholder type, and are written immediately after the function’s name, between a pair of matching angle brackets (such as "},{"code":"<T>","type":"codeVoice"},{"type":"text","text":")."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Once you specify a type parameter, you can use it to define the type of a function’s parameters (such as the "},{"type":"codeVoice","code":"a"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b"},{"type":"text","text":" parameters of the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" function), or as the function’s return type, or as a type annotation within the body of the function. In each case, the type parameter is replaced with an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"actual"}]},{"type":"text","text":" type whenever the function is called. (In the "},{"type":"codeVoice","code":"swapTwoValues(_:_:)"},{"type":"text","text":" example above, "},{"type":"codeVoice","code":"T"},{"type":"text","text":" was replaced with "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" the first time the function was called, and was replaced with "},{"type":"codeVoice","code":"String"},{"type":"text","text":" the second time it was called.)"}],"type":"paragraph"},{"inlineContent":[{"text":"You can provide more than one type parameter by writing multiple type parameter names within the angle brackets, separated by commas.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Naming Type Parameters","type":"heading","anchor":"Naming-Type-Parameters"},{"inlineContent":[{"text":"In most cases, type parameters have descriptive names, such as ","type":"text"},{"code":"Key","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Value","type":"codeVoice"},{"text":" in ","type":"text"},{"code":"Dictionary<Key, Value>","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Element","type":"codeVoice"},{"text":" in ","type":"text"},{"code":"Array<Element>","type":"codeVoice"},{"text":", which tells the reader about the relationship between the type parameter and the generic type or function it’s used in. However, when there isn’t a meaningful relationship between them, it’s traditional to name them using single letters such as ","type":"text"},{"code":"T","type":"codeVoice"},{"type":"text","text":", "},{"code":"U","type":"codeVoice"},{"type":"text","text":", and "},{"code":"V","type":"codeVoice"},{"type":"text","text":", such as "},{"code":"T","type":"codeVoice"},{"type":"text","text":" in the "},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"type":"text","text":" function above."}],"type":"paragraph"},{"name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"Always give type parameters upper camel case names (such as "},{"code":"T","type":"codeVoice"},{"type":"text","text":" and "},{"code":"MyTypeParameter","type":"codeVoice"},{"type":"text","text":") to indicate that they’re a placeholder for a "},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]},{"type":"text","text":", not a value."}],"type":"paragraph"}],"type":"aside"},{"level":2,"text":"Generic Types","type":"heading","anchor":"Generic-Types"},{"inlineContent":[{"type":"text","text":"In addition to generic functions, Swift enables you to define your own "},{"inlineContent":[{"text":"generic types","type":"text"}],"type":"emphasis"},{"type":"text","text":". These are custom classes, structures, and enumerations that can work with "},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"type":"text","text":" type, in a similar way to "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This section shows you how to write a generic collection type called "},{"code":"Stack","type":"codeVoice"},{"type":"text","text":". A stack is an ordered set of values, similar to an array, but with a more restricted set of operations than Swift’s "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" type. An array allows new items to be inserted and removed at any location in the array. A stack, however, allows new items to be appended only to the end of the collection (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pushing"}]},{"type":"text","text":" a new value on to the stack). Similarly, a stack allows items to be removed only from the end of the collection (known as "},{"type":"emphasis","inlineContent":[{"text":"popping","type":"text"}]},{"type":"text","text":" a value off the stack)."}],"type":"paragraph"},{"name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"The concept of a stack is used by the "},{"code":"UINavigationController","type":"codeVoice"},{"type":"text","text":" class to model the view controllers in its navigation hierarchy. You call the "},{"code":"UINavigationController","type":"codeVoice"},{"type":"text","text":" class "},{"code":"pushViewController(_:animated:)","type":"codeVoice"},{"type":"text","text":" method to add (or push) a view controller on to the navigation stack, and its "},{"code":"popViewControllerAnimated(_:)","type":"codeVoice"},{"type":"text","text":" method to remove (or pop) a view controller from the navigation stack. A stack is a useful collection model whenever you need a strict “last in, first out” approach to managing a collection."}],"type":"paragraph"}],"type":"aside"},{"inlineContent":[{"type":"text","text":"The illustration below shows the push and pop behavior for a stack:"}],"type":"paragraph"},{"inlineContent":[{"identifier":"stackPushPop","type":"image"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"There are currently three values on the stack.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"A fourth value is pushed onto the top of the stack."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The stack now holds four values, with the most recent one at the top."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The top item in the stack is popped."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"After popping a value, the stack once again holds three values."}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"text":"Here’s how to write a nongeneric version of a stack, in this case for a stack of ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" values:","type":"text"}],"type":"paragraph"},{"code":["struct IntStack {","    var items: [Int] = []","    mutating func push(_ item: Int) {","        items.append(item)","    }","    mutating func pop() -> Int {","        return items.removeLast()","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This structure uses an ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" property called ","type":"text"},{"type":"codeVoice","code":"items"},{"text":" to store the values in the stack. ","type":"text"},{"type":"codeVoice","code":"Stack"},{"text":" provides two methods, ","type":"text"},{"type":"codeVoice","code":"push"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"pop"},{"text":", to push and pop values on and off the stack. These methods are marked as ","type":"text"},{"type":"codeVoice","code":"mutating"},{"text":", because they need to modify (or ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"mutate","type":"text"}]},{"text":") the structure’s ","type":"text"},{"type":"codeVoice","code":"items"},{"text":" array.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"text":" type shown above can only be used with ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" values, however. It would be much more useful to define a ","type":"text"},{"inlineContent":[{"type":"text","text":"generic"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Stack"},{"text":" structure, that can manage a stack of ","type":"text"},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"text":" type of value.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s a generic version of the same code:"}],"type":"paragraph"},{"code":["struct Stack<Element> {","    var items: [Element] = []","    mutating func push(_ item: Element) {","        items.append(item)","    }","    mutating func pop() -> Element {","        return items.removeLast()","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Note how the generic version of "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" is essentially the same as the nongeneric version, but with a type parameter called "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" instead of an actual type of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":". This type parameter is written within a pair of angle brackets ("},{"type":"codeVoice","code":"<Element>"},{"type":"text","text":") immediately after the structure’s name."}],"type":"paragraph"},{"inlineContent":[{"code":"Element","type":"codeVoice"},{"type":"text","text":" defines a placeholder name for a type to be provided later. This future type can be referred to as "},{"code":"Element","type":"codeVoice"},{"type":"text","text":" anywhere within the structure’s definition. In this case, "},{"code":"Element","type":"codeVoice"},{"type":"text","text":" is used as a placeholder in three places:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"To create a property called "},{"type":"codeVoice","code":"items"},{"type":"text","text":", which is initialized with an empty array of values of type "},{"type":"codeVoice","code":"Element"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"To specify that the ","type":"text"},{"type":"codeVoice","code":"push(_:)"},{"text":" method has a single parameter called ","type":"text"},{"type":"codeVoice","code":"item"},{"text":", which must be of type ","type":"text"},{"type":"codeVoice","code":"Element"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"To specify that the value returned by the ","type":"text"},{"type":"codeVoice","code":"pop()"},{"text":" method will be a value of type ","type":"text"},{"type":"codeVoice","code":"Element"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Because it’s a generic type, ","type":"text"},{"type":"codeVoice","code":"Stack"},{"text":" can be used to create a stack of ","type":"text"},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"text":" valid type in Swift, in a similar manner to ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Dictionary"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You create a new "},{"code":"Stack","type":"codeVoice"},{"type":"text","text":" instance by writing the type to be stored in the stack within angle brackets. For example, to create a new stack of strings, you write "},{"code":"Stack<String>()","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["var stackOfStrings = Stack<String>()","stackOfStrings.push(\"uno\")","stackOfStrings.push(\"dos\")","stackOfStrings.push(\"tres\")","stackOfStrings.push(\"cuatro\")","\/\/ the stack now contains 4 strings"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Here’s how ","type":"text"},{"code":"stackOfStrings","type":"codeVoice"},{"text":" looks after pushing these four values on to the stack:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"stackPushedFourStrings","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Popping a value from the stack removes and returns the top value, "},{"type":"codeVoice","code":"\"cuatro\""},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let fromTheTop = stackOfStrings.pop()","\/\/ fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Here’s how the stack looks after popping its top value:","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"stackPoppedOneString"}],"type":"paragraph"},{"level":2,"text":"Extending a Generic Type","type":"heading","anchor":"Extending-a-Generic-Type"},{"inlineContent":[{"type":"text","text":"When you extend a generic type, you don’t provide a type parameter list as part of the extension’s definition. Instead, the type parameter list from the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"original"}]},{"type":"text","text":" type definition is available within the body of the extension, and the original type parameter names are used to refer to the type parameters from the original definition."}],"type":"paragraph"},{"inlineContent":[{"text":"The following example extends the generic ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" type to add a read-only computed property called ","type":"text"},{"code":"topItem","type":"codeVoice"},{"text":", which returns the top item on the stack without popping it from the stack:","type":"text"}],"type":"paragraph"},{"code":["extension Stack {","    var topItem: Element? {","        return items.isEmpty ? nil : items[items.count - 1]","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"topItem","type":"codeVoice"},{"text":" property returns an optional value of type ","type":"text"},{"code":"Element","type":"codeVoice"},{"text":". If the stack is empty, ","type":"text"},{"code":"topItem","type":"codeVoice"},{"text":" returns ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":"; if the stack isn’t empty, ","type":"text"},{"code":"topItem","type":"codeVoice"},{"text":" returns the final item in the ","type":"text"},{"code":"items","type":"codeVoice"},{"text":" array.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that this extension doesn’t define a type parameter list. Instead, the ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" type’s existing type parameter name, ","type":"text"},{"code":"Element","type":"codeVoice"},{"text":", is used within the extension to indicate the optional type of the ","type":"text"},{"code":"topItem","type":"codeVoice"},{"text":" computed property.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"topItem"},{"type":"text","text":" computed property can now be used with any "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" instance to access and query its top item without removing it."}],"type":"paragraph"},{"code":["if let topItem = stackOfStrings.topItem {","    print(\"The top item on the stack is \\(topItem).\")","}","\/\/ Prints \"The top item on the stack is tres.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Extensions of a generic type can also include requirements that instances of the extended type must satisfy in order to gain the new functionality, as discussed in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Extensions-with-a-Generic-Where-Clause","isActive":true,"type":"reference"},{"text":" below.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Type Constraints","type":"heading","anchor":"Type-Constraints"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"swapTwoValues(_:_:)","type":"codeVoice"},{"text":" function and the ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" type can work with any type. However, it’s sometimes useful to enforce certain ","type":"text"},{"inlineContent":[{"type":"text","text":"type constraints"}],"type":"emphasis"},{"text":" on the types that can be used with generic functions and generic types. Type constraints specify that a type parameter must inherit from a specific class, or conform to a particular protocol or protocol composition.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For example, Swift’s "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" type places a limitation on the types that can be used as keys for a dictionary. As described in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes#Dictionaries","isActive":true,"type":"reference"},{"type":"text","text":", the type of a dictionary’s keys must be "},{"inlineContent":[{"type":"text","text":"hashable"}],"type":"emphasis"},{"type":"text","text":". That is, it must provide a way to make itself uniquely representable. "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" needs its keys to be hashable so that it can check whether it already contains a value for a particular key. Without this requirement, "},{"code":"Dictionary","type":"codeVoice"},{"type":"text","text":" couldn’t tell whether it should insert or replace a value for a particular key, nor would it be able to find a value for a given key that’s already in the dictionary."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This requirement is enforced by a type constraint on the key type for "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":", which specifies that the key type must conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol, a special protocol defined in the Swift standard library. All of Swift’s basic types (such as "},{"type":"codeVoice","code":"String"},{"type":"text","text":", "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"type":"codeVoice","code":"Double"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":") are hashable by default. For information about making your own custom types conform to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol, see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490"},{"type":"text","text":" [https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490]"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"You can define your own type constraints when creating custom generic types, and these constraints provide much of the power of generic programming. Abstract concepts like ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":" characterize types in terms of their conceptual characteristics, rather than their concrete type.","type":"text"}],"type":"paragraph"},{"level":3,"text":"Type Constraint Syntax","type":"heading","anchor":"Type-Constraint-Syntax"},{"inlineContent":[{"text":"You write type constraints by placing a single class or protocol constraint after a type parameter’s name, separated by a colon, as part of the type parameter list. The basic syntax for type constraints on a generic function is shown below (although the syntax is the same for generic types):","type":"text"}],"type":"paragraph"},{"code":["func someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {","    \/\/ function body goes here","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The hypothetical function above has two type parameters. The first type parameter, ","type":"text"},{"code":"T","type":"codeVoice"},{"text":", has a type constraint that requires ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" to be a subclass of ","type":"text"},{"code":"SomeClass","type":"codeVoice"},{"text":". The second type parameter, ","type":"text"},{"code":"U","type":"codeVoice"},{"text":", has a type constraint that requires ","type":"text"},{"code":"U","type":"codeVoice"},{"text":" to conform to the protocol ","type":"text"},{"code":"SomeProtocol","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"level":3,"text":"Type Constraints in Action","type":"heading","anchor":"Type-Constraints-in-Action"},{"inlineContent":[{"type":"text","text":"Here’s a nongeneric function called "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":", which is given a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" value to find and an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values within which to find it. The "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":" function returns an optional "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value, which will be the index of the first matching string in the array if it’s found, or "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" if the string can’t be found:"}],"type":"paragraph"},{"code":["func findIndex(ofString valueToFind: String, in array: [String]) -> Int? {","    for (index, value) in array.enumerated() {","        if value == valueToFind {","            return index","        }","    }","    return nil","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":" function can be used to find a string value in an array of strings:"}],"type":"paragraph"},{"code":["let strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"]","if let foundIndex = findIndex(ofString: \"llama\", in: strings) {","    print(\"The index of llama is \\(foundIndex)\")","}","\/\/ Prints \"The index of llama is 2\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The principle of finding the index of a value in an array isn’t useful only for strings, however. You can write the same functionality as a generic function by replacing any mention of strings with values of some type ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" instead.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s how you might expect a generic version of "},{"type":"codeVoice","code":"findIndex(ofString:in:)"},{"type":"text","text":", called "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":", to be written. Note that the return type of this function is still "},{"type":"codeVoice","code":"Int?"},{"type":"text","text":", because the function returns an optional index number, not an optional value from the array. Be warned, though—this function doesn’t compile, for reasons explained after the example:"}],"type":"paragraph"},{"code":["func findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {","    for (index, value) in array.enumerated() {","        if value == valueToFind {","            return index","        }","    }","    return nil","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This function doesn’t compile as written above. The problem lies with the equality check, “"},{"type":"codeVoice","code":"if value == valueToFind"},{"type":"text","text":"”. Not every type in Swift can be compared with the equal to operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":"). If you create your own class or structure to represent a complex data model, for example, then the meaning of “equal to” for that class or structure isn’t something that Swift can guess for you. Because of this, it isn’t possible to guarantee that this code will work for "},{"type":"emphasis","inlineContent":[{"text":"every","type":"text"}]},{"type":"text","text":" possible type "},{"type":"codeVoice","code":"T"},{"type":"text","text":", and an appropriate error is reported when you try to compile the code."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"All is not lost, however. The Swift standard library defines a protocol called "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", which requires any conforming type to implement the equal to operator ("},{"type":"codeVoice","code":"=="},{"type":"text","text":") and the not equal to operator ("},{"type":"codeVoice","code":"!="},{"type":"text","text":") to compare any two values of that type. All of Swift’s standard types automatically support the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"inlineContent":[{"text":"Any type that’s ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" can be used safely with the ","type":"text"},{"code":"findIndex(of:in:)","type":"codeVoice"},{"text":" function, because it’s guaranteed to support the equal to operator. To express this fact, you write a type constraint of ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" as part of the type parameter’s definition when you define the function:","type":"text"}],"type":"paragraph"},{"code":["func findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {","    for (index, value) in array.enumerated() {","        if value == valueToFind {","            return index","        }","    }","    return nil","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The single type parameter for "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":" is written as "},{"type":"codeVoice","code":"T: Equatable"},{"type":"text","text":", which means “any type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" that conforms to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol.”"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"findIndex(of:in:)"},{"type":"text","text":" function now compiles successfully and can be used with any type that’s "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":", such as "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" or "},{"type":"codeVoice","code":"String"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])","\/\/ doubleIndex is an optional Int with no value, because 9.3 isn't in the array","let stringIndex = findIndex(of: \"Andrea\", in: [\"Mike\", \"Malcolm\", \"Andrea\"])","\/\/ stringIndex is an optional Int containing a value of 2"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Associated Types","type":"heading","anchor":"Associated-Types"},{"inlineContent":[{"text":"When defining a protocol, it’s sometimes useful to declare one or more associated types as part of the protocol’s definition. An ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"associated type"}]},{"text":" gives a placeholder name to a type that’s used as part of the protocol. The actual type to use for that associated type isn’t specified until the protocol is adopted. Associated types are specified with the ","type":"text"},{"code":"associatedtype","type":"codeVoice"},{"text":" keyword.","type":"text"}],"type":"paragraph"},{"level":3,"text":"Associated Types in Action","type":"heading","anchor":"Associated-Types-in-Action"},{"inlineContent":[{"type":"text","text":"Here’s an example of a protocol called "},{"type":"codeVoice","code":"Container"},{"type":"text","text":", which declares an associated type called "},{"type":"codeVoice","code":"Item"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["protocol Container {","    associatedtype Item","    mutating func append(_ item: Item)","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol defines three required capabilities that any container must provide:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It must be possible to add a new item to the container with an "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"It must be possible to access a count of the items in the container through a "},{"type":"codeVoice","code":"count"},{"type":"text","text":" property that returns an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It must be possible to retrieve each item in the container with a subscript that takes an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" index value."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"This protocol doesn’t specify how the items in the container should be stored or what type they’re allowed to be. The protocol only specifies the three bits of functionality that any type must provide in order to be considered a "},{"code":"Container","type":"codeVoice"},{"type":"text","text":". A conforming type can provide additional functionality, as long as it satisfies these three requirements."}],"type":"paragraph"},{"inlineContent":[{"text":"Any type that conforms to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol must be able to specify the type of values it stores. Specifically, it must ensure that only items of the right type are added to the container, and it must be clear about the type of the items returned by its subscript.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To define these requirements, the "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol needs a way to refer to the type of the elements that a container will hold, without knowing what that type is for a specific container. The "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol needs to specify that any value passed to the "},{"code":"append(_:)","type":"codeVoice"},{"type":"text","text":" method must have the same type as the container’s element type, and that the value returned by the container’s subscript will be of the same type as the container’s element type."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"To achieve this, the "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" protocol declares an associated type called "},{"code":"Item","type":"codeVoice"},{"type":"text","text":", written as "},{"code":"associatedtype Item","type":"codeVoice"},{"type":"text","text":". The protocol doesn’t define what "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" is—that information is left for any conforming type to provide. Nonetheless, the "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" alias provides a way to refer to the type of the items in a "},{"code":"Container","type":"codeVoice"},{"type":"text","text":", and to define a type for use with the "},{"code":"append(_:)","type":"codeVoice"},{"type":"text","text":" method and subscript, to ensure that the expected behavior of any "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" is enforced."}],"type":"paragraph"},{"inlineContent":[{"text":"Here’s a version of the nongeneric ","type":"text"},{"type":"codeVoice","code":"IntStack"},{"text":" type from ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Generic-Types"},{"text":" above, adapted to conform to the ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"code":["struct IntStack: Container {","    \/\/ original IntStack implementation","    var items: [Int] = []","    mutating func push(_ item: Int) {","        items.append(item)","    }","    mutating func pop() -> Int {","        return items.removeLast()","    }","    \/\/ conformance to the Container protocol","    typealias Item = Int","    mutating func append(_ item: Int) {","        self.push(item)","    }","    var count: Int {","        return items.count","    }","    subscript(i: Int) -> Int {","        return items[i]","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type implements all three of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol’s requirements, and in each case wraps part of the "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" type’s existing functionality to satisfy these requirements."}],"type":"paragraph"},{"inlineContent":[{"text":"Moreover, ","type":"text"},{"code":"IntStack","type":"codeVoice"},{"text":" specifies that for this implementation of ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":", the appropriate ","type":"text"},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to use is a type of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":". The definition of "},{"type":"codeVoice","code":"typealias Item = Int"},{"type":"text","text":" turns the abstract type of "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" into a concrete type of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" for this implementation of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Thanks to Swift’s type inference, you don’t actually need to declare a concrete "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" as part of the definition of "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":". Because "},{"type":"codeVoice","code":"IntStack"},{"type":"text","text":" conforms to all of the requirements of the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol, Swift can infer the appropriate "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" to use, simply by looking at the type of the "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method’s "},{"type":"codeVoice","code":"item"},{"type":"text","text":" parameter and the return type of the subscript. Indeed, if you delete the "},{"type":"codeVoice","code":"typealias Item = Int"},{"type":"text","text":" line from the code above, everything still works, because it’s clear what type should be used for "},{"type":"codeVoice","code":"Item"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"You can also make the generic ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" type conform to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol:","type":"text"}],"type":"paragraph"},{"code":["struct Stack<Element>: Container {","    \/\/ original Stack<Element> implementation","    var items: [Element] = []","    mutating func push(_ item: Element) {","        items.append(item)","    }","    mutating func pop() -> Element {","        return items.removeLast()","    }","    \/\/ conformance to the Container protocol","    mutating func append(_ item: Element) {","        self.push(item)","    }","    var count: Int {","        return items.count","    }","    subscript(i: Int) -> Element {","        return items[i]","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This time, the type parameter "},{"code":"Element","type":"codeVoice"},{"type":"text","text":" is used as the type of the "},{"code":"append(_:)","type":"codeVoice"},{"type":"text","text":" method’s "},{"code":"item","type":"codeVoice"},{"type":"text","text":" parameter and the return type of the subscript. Swift can therefore infer that "},{"code":"Element","type":"codeVoice"},{"type":"text","text":" is the appropriate type to use as the "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" for this particular container."}],"type":"paragraph"},{"level":3,"text":"Extending an Existing Type to Specify an Associated Type","type":"heading","anchor":"Extending-an-Existing-Type-to-Specify-an-Associated-Type"},{"inlineContent":[{"type":"text","text":"You can extend an existing type to add conformance to a protocol, as described in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Adding-Protocol-Conformance-with-an-Extension","isActive":true},{"type":"text","text":". This includes a protocol with an associated type."}],"type":"paragraph"},{"inlineContent":[{"text":"Swift’s ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" type already provides an ","type":"text"},{"code":"append(_:)","type":"codeVoice"},{"text":" method, a ","type":"text"},{"code":"count","type":"codeVoice"},{"text":" property, and a subscript with an ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" index to retrieve its elements. These three capabilities match the requirements of the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol. This means that you can extend ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" to conform to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol simply by declaring that ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" adopts the protocol. You do this with an empty extension, as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Declaring-Protocol-Adoption-with-an-Extension","isActive":true},{"text":":","type":"text"}],"type":"paragraph"},{"code":["extension Array: Container {}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Array’s existing "},{"type":"codeVoice","code":"append(_:)"},{"type":"text","text":" method and subscript enable Swift to infer the appropriate type to use for "},{"type":"codeVoice","code":"Item"},{"type":"text","text":", just as for the generic "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" type above. After defining this extension, you can use any "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" as a "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."}],"type":"paragraph"},{"level":3,"text":"Adding Constraints to an Associated Type","type":"heading","anchor":"Adding-Constraints-to-an-Associated-Type"},{"inlineContent":[{"text":"You can add type constraints to an associated type in a protocol to require that conforming types satisfy those constraints. For example, the following code defines a version of ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" that requires the items in the container to be equatable.","type":"text"}],"type":"paragraph"},{"code":["protocol Container {","    associatedtype Item: Equatable","    mutating func append(_ item: Item)","    var count: Int { get }","    subscript(i: Int) -> Item { get }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"To conform to this version of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":", the container’s "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type has to conform to the "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"level":3,"text":"Using a Protocol in Its Associated Type’s Constraints","type":"heading","anchor":"Using-a-Protocol-in-Its-Associated-Types-Constraints"},{"inlineContent":[{"type":"text","text":"A protocol can appear as part of its own requirements. For example, here’s a protocol that refines the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol, adding the requirement of a "},{"type":"codeVoice","code":"suffix(_:)"},{"type":"text","text":" method. The "},{"type":"codeVoice","code":"suffix(_:)"},{"type":"text","text":" method returns a given number of elements from the end of the container, storing them in an instance of the "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" type."}],"type":"paragraph"},{"code":["protocol SuffixableContainer: Container {","    associatedtype Suffix: SuffixableContainer where Suffix.Item == Item","    func suffix(_ size: Int) -> Suffix","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In this protocol, "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" is an associated type, like the "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type in the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" example above. "},{"type":"codeVoice","code":"Suffix"},{"type":"text","text":" has two constraints: It must conform to the "},{"type":"codeVoice","code":"SuffixableContainer"},{"type":"text","text":" protocol (the protocol currently being defined), and its "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type must be the same as the container’s "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type. The constraint on "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" is a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause, which is discussed in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Associated-Types-with-a-Generic-Where-Clause","isActive":true},{"type":"text","text":" below."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s an extension of the "},{"code":"Stack","type":"codeVoice"},{"type":"text","text":" type from "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Generic-Types","isActive":true,"type":"reference"},{"type":"text","text":" above that adds conformance to the "},{"code":"SuffixableContainer","type":"codeVoice"},{"type":"text","text":" protocol:"}],"type":"paragraph"},{"code":["extension Stack: SuffixableContainer {","    func suffix(_ size: Int) -> Stack {","        var result = Stack()","        for index in (count-size)..<count {","            result.append(self[index])","        }","        return result","    }","    \/\/ Inferred that Suffix is Stack.","}","var stackOfInts = Stack<Int>()","stackOfInts.append(10)","stackOfInts.append(20)","stackOfInts.append(30)","let suffix = stackOfInts.suffix(2)","\/\/ suffix contains 20 and 30"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"In the example above, the ","type":"text"},{"code":"Suffix","type":"codeVoice"},{"text":" associated type for ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" is also ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":", so the suffix operation on ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" returns another ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":". Alternatively, a type that conforms to ","type":"text"},{"code":"SuffixableContainer","type":"codeVoice"},{"text":" can have a ","type":"text"},{"code":"Suffix","type":"codeVoice"},{"text":" type that’s different from itself—meaning the suffix operation can return a different type. For example, here’s an extension to the nongeneric ","type":"text"},{"code":"IntStack","type":"codeVoice"},{"text":" type that adds ","type":"text"},{"code":"SuffixableContainer","type":"codeVoice"},{"text":" conformance, using ","type":"text"},{"code":"Stack<Int>","type":"codeVoice"},{"text":" as its suffix type instead of ","type":"text"},{"code":"IntStack","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"code":["extension IntStack: SuffixableContainer {","    func suffix(_ size: Int) -> Stack<Int> {","        var result = Stack<Int>()","        for index in (count-size)..<count {","            result.append(self[index])","        }","        return result","    }","    \/\/ Inferred that Suffix is Stack<Int>.","}"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Generic Where Clauses","type":"heading","anchor":"Generic-Where-Clauses"},{"inlineContent":[{"text":"Type constraints, as described in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Type-Constraints","type":"reference","isActive":true},{"text":", enable you to define requirements on the type parameters associated with a generic function, subscript, or type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It can also be useful to define requirements for associated types. You do this by defining a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"generic where clause"}]},{"type":"text","text":". A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause enables you to require that an associated type must conform to a certain protocol, or that certain type parameters and associated types must be the same. A generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause starts with the "},{"type":"codeVoice","code":"where"},{"type":"text","text":" keyword, followed by constraints for associated types or equality relationships between types and associated types. You write a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause right before the opening curly brace of a type or function’s body."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example below defines a generic function called "},{"type":"codeVoice","code":"allItemsMatch"},{"type":"text","text":", which checks to see if two "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" instances contain the same items in the same order. The function returns a Boolean value of "},{"type":"codeVoice","code":"true"},{"type":"text","text":" if all items match and a value of "},{"type":"codeVoice","code":"false"},{"type":"text","text":" if they don’t."}],"type":"paragraph"},{"inlineContent":[{"text":"The two containers to be checked don’t have to be the same type of container (although they can be), but they do have to hold the same type of items. This requirement is expressed through a combination of type constraints and a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause:","type":"text"}],"type":"paragraph"},{"code":["func allItemsMatch<C1: Container, C2: Container>","    (_ someContainer: C1, _ anotherContainer: C2) -> Bool","    where C1.Item == C2.Item, C1.Item: Equatable {","","        \/\/ Check that both containers contain the same number of items.","        if someContainer.count != anotherContainer.count {","            return false","        }","","        \/\/ Check each pair of items to see if they're equivalent.","        for i in 0..<someContainer.count {","            if someContainer[i] != anotherContainer[i] {","                return false","            }","        }","","        \/\/ All items match, so return true.","        return true","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This function takes two arguments called ","type":"text"},{"code":"someContainer","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"anotherContainer","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"someContainer","type":"codeVoice"},{"text":" argument is of type ","type":"text"},{"code":"C1","type":"codeVoice"},{"text":", and the ","type":"text"},{"code":"anotherContainer","type":"codeVoice"},{"text":" argument is of type ","type":"text"},{"code":"C2","type":"codeVoice"},{"text":". Both ","type":"text"},{"code":"C1","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"C2","type":"codeVoice"},{"text":" are type parameters for two container types to be determined when the function is called.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following requirements are placed on the function’s two type parameters:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"C1"},{"type":"text","text":" must conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol (written as "},{"type":"codeVoice","code":"C1: Container"},{"type":"text","text":")."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"C2"},{"type":"text","text":" must also conform to the "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" protocol (written as "},{"type":"codeVoice","code":"C2: Container"},{"type":"text","text":")."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"C1","type":"codeVoice"},{"text":" must be the same as the ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"C2","type":"codeVoice"},{"text":" (written as ","type":"text"},{"code":"C1.Item == C2.Item","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"C1","type":"codeVoice"},{"text":" must conform to the ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" protocol (written as ","type":"text"},{"code":"C1.Item: Equatable","type":"codeVoice"},{"text":").","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"The first and second requirements are defined in the function’s type parameter list, and the third and fourth requirements are defined in the function’s generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"These requirements mean:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" is a container of type "},{"type":"codeVoice","code":"C1"},{"type":"text","text":"."}]}]},{"content":[{"inlineContent":[{"code":"anotherContainer","type":"codeVoice"},{"text":" is a container of type ","type":"text"},{"code":"C2","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"someContainer"},{"type":"text","text":" and "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" contain the same type of items."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The items in "},{"code":"someContainer","type":"codeVoice"},{"type":"text","text":" can be checked with the not equal operator ("},{"code":"!=","type":"codeVoice"},{"type":"text","text":") to see if they’re different from each other."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"The third and fourth requirements combine to mean that the items in "},{"type":"codeVoice","code":"anotherContainer"},{"type":"text","text":" can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"also"}]},{"type":"text","text":" be checked with the "},{"code":"!=","type":"codeVoice"},{"type":"text","text":" operator, because they’re exactly the same type as the items in "},{"code":"someContainer","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"These requirements enable the ","type":"text"},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"text":" function to compare the two containers, even if they’re of a different container type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"text":" function starts by checking that both containers contain the same number of items. If they contain a different number of items, there’s no way that they can match, and the function returns ","type":"text"},{"code":"false","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"After making this check, the function iterates over all of the items in ","type":"text"},{"type":"codeVoice","code":"someContainer"},{"text":" with a ","type":"text"},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"text":" loop and the half-open range operator (","type":"text"},{"type":"codeVoice","code":"..<"},{"text":"). For each item, the function checks whether the item from ","type":"text"},{"type":"codeVoice","code":"someContainer"},{"text":" isn’t equal to the corresponding item in ","type":"text"},{"type":"codeVoice","code":"anotherContainer"},{"text":". If the two items aren’t equal, then the two containers don’t match, and the function returns ","type":"text"},{"type":"codeVoice","code":"false"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If the loop finishes without finding a mismatch, the two containers match, and the function returns ","type":"text"},{"type":"codeVoice","code":"true"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s how the "},{"type":"codeVoice","code":"allItemsMatch(_:_:)"},{"type":"text","text":" function looks in action:"}],"type":"paragraph"},{"code":["var stackOfStrings = Stack<String>()","stackOfStrings.push(\"uno\")","stackOfStrings.push(\"dos\")","stackOfStrings.push(\"tres\")","","var arrayOfStrings = [\"uno\", \"dos\", \"tres\"]","","if allItemsMatch(stackOfStrings, arrayOfStrings) {","    print(\"All items match.\")","} else {","    print(\"Not all items match.\")","}","\/\/ Prints \"All items match.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The example above creates a ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" instance to store ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" values, and pushes three strings onto the stack. The example also creates an ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" instance initialized with an array literal containing the same three strings as the stack. Even though the stack and the array are of a different type, they both conform to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol, and both contain the same type of values. You can therefore call the ","type":"text"},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"text":" function with these two containers as its arguments. In the example above, the ","type":"text"},{"code":"allItemsMatch(_:_:)","type":"codeVoice"},{"text":" function correctly reports that all of the items in the two containers match.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Extensions with a Generic Where Clause","type":"heading","anchor":"Extensions-with-a-Generic-Where-Clause"},{"inlineContent":[{"text":"You can also use a generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause as part of an extension. The example below extends the generic ","type":"text"},{"code":"Stack","type":"codeVoice"},{"text":" structure from the previous examples to add an ","type":"text"},{"code":"isTop(_:)","type":"codeVoice"},{"text":" method.","type":"text"}],"type":"paragraph"},{"code":["extension Stack where Element: Equatable {","    func isTop(_ item: Element) -> Bool {","        guard let topItem = items.last else {","            return false","        }","        return topItem == item","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This new "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method first checks that the stack isn’t empty, and then compares the given item against the stack’s topmost item. If you tried to do this without a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause, you would have a problem: The implementation of "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" uses the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator, but the definition of "},{"type":"codeVoice","code":"Stack"},{"type":"text","text":" doesn’t require its items to be equatable, so using the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator results in a compile-time error. Using a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause lets you add a new requirement to the extension, so that the extension adds the "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method only when the items in the stack are equatable."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s how the "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method looks in action:"}],"type":"paragraph"},{"code":["if stackOfStrings.isTop(\"tres\") {","    print(\"Top element is tres.\")","} else {","    print(\"Top element is something else.\")","}","\/\/ Prints \"Top element is tres.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If you try to call the "},{"type":"codeVoice","code":"isTop(_:)"},{"type":"text","text":" method on a stack whose elements aren’t equatable, you’ll get a compile-time error."}],"type":"paragraph"},{"code":["struct NotEquatable { }","var notEquatableStack = Stack<NotEquatable>()","let notEquatableValue = NotEquatable()","notEquatableStack.push(notEquatableValue)","notEquatableStack.isTop(notEquatableValue)  \/\/ Error"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"You can use a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause with extensions to a protocol. The example below extends the ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" protocol from the previous examples to add a ","type":"text"},{"type":"codeVoice","code":"startsWith(_:)"},{"text":" method.","type":"text"}],"type":"paragraph"},{"code":["extension Container where Item: Equatable {","    func startsWith(_ item: Item) -> Bool {","        return count >= 1 && self[0] == item","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"startsWith(_:)","type":"codeVoice"},{"text":" method first makes sure that the container has at least one item, and then it checks whether the first item in the container matches the given item. This new ","type":"text"},{"code":"startsWith(_:)","type":"codeVoice"},{"text":" method can be used with any type that conforms to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol, including the stacks and arrays used above, as long as the container’s items are equatable.","type":"text"}],"type":"paragraph"},{"code":["if [9, 9, 9].startsWith(42) {","    print(\"Starts with 42.\")","} else {","    print(\"Starts with something else.\")","}","\/\/ Prints \"Starts with something else.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause in the example above requires ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" to conform to a protocol, but you can also write a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clauses that require ","type":"text"},{"type":"codeVoice","code":"Item"},{"text":" to be a specific type. For example:","type":"text"}],"type":"paragraph"},{"code":["extension Container where Item == Double {","    func average() -> Double {","        var sum = 0.0","        for index in 0..<count {","            sum += self[index]","        }","        return sum \/ Double(count)","    }","}","print([1260.0, 1200.0, 98.6, 37.0].average())","\/\/ Prints \"648.9\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This example adds an ","type":"text"},{"code":"average()","type":"codeVoice"},{"text":" method to containers whose ","type":"text"},{"code":"Item","type":"codeVoice"},{"text":" type is ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":". It iterates over the items in the container to add them up, and divides by the container’s count to compute the average. It explicitly converts the count from ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" to be able to do floating-point division.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can include multiple requirements in a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause that’s part of an extension, just like you can for a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause that you write elsewhere. Separate each requirement in the list with a comma."}],"type":"paragraph"},{"level":2,"text":"Contextual Where Clauses","type":"heading","anchor":"Contextual-Where-Clauses"},{"inlineContent":[{"text":"You can write a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause as part of a declaration that doesn’t have its own generic type constraints, when you’re already working in the context of generic types. For example, you can write a generic ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clause on a subscript of a generic type or on a method in an extension to a generic type. The ","type":"text"},{"type":"codeVoice","code":"Container"},{"text":" structure is generic, and the ","type":"text"},{"type":"codeVoice","code":"where"},{"text":" clauses in the example below specify what type constraints have to be satisfied to make these new methods available on a container.","type":"text"}],"type":"paragraph"},{"code":["extension Container {","    func average() -> Double where Item == Int {","        var sum = 0.0","        for index in 0..<count {","            sum += Double(self[index])","        }","        return sum \/ Double(count)","    }","    func endsWith(_ item: Item) -> Bool where Item: Equatable {","        return count >= 1 && self[count-1] == item","    }","}","let numbers = [1260, 1200, 98, 37]","print(numbers.average())","\/\/ Prints \"648.75\"","print(numbers.endsWith(37))","\/\/ Prints \"true\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This example adds an "},{"type":"codeVoice","code":"average()"},{"type":"text","text":" method to "},{"type":"codeVoice","code":"Container"},{"type":"text","text":" when the items are integers, and it adds an "},{"type":"codeVoice","code":"endsWith(_:)"},{"type":"text","text":" method when the items are equatable. Both functions include a generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause that adds type constraints to the generic "},{"type":"codeVoice","code":"Item"},{"type":"text","text":" type parameter from the original declaration of "},{"type":"codeVoice","code":"Container"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"If you want to write this code without using contextual ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clauses, you write two extensions, one for each generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause. The example above and the example below have the same behavior.","type":"text"}],"type":"paragraph"},{"code":["extension Container where Item == Int {","    func average() -> Double {","        var sum = 0.0","        for index in 0..<count {","            sum += Double(self[index])","        }","        return sum \/ Double(count)","    }","}","extension Container where Item: Equatable {","    func endsWith(_ item: Item) -> Bool {","        return count >= 1 && self[count-1] == item","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"In the version of this example that uses contextual ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clauses, the implementation of ","type":"text"},{"code":"average()","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"endsWith(_:)","type":"codeVoice"},{"text":" are both in the same extension because each method’s generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause states the requirements that need to be satisfied to make that method available. Moving those requirements to the extensions’ generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clauses makes the methods available in the same situations, but requires one extension per requirement.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Associated Types with a Generic Where Clause","type":"heading","anchor":"Associated-Types-with-a-Generic-Where-Clause"},{"inlineContent":[{"type":"text","text":"You can include a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause on an associated type. For example, suppose you want to make a version of "},{"code":"Container","type":"codeVoice"},{"type":"text","text":" that includes an iterator, like what the "},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" protocol uses in the standard library. Here’s how you write that:"}],"type":"paragraph"},{"code":["protocol Container {","    associatedtype Item","    mutating func append(_ item: Item)","    var count: Int { get }","    subscript(i: Int) -> Item { get }","","    associatedtype Iterator: IteratorProtocol where Iterator.Element == Item","    func makeIterator() -> Iterator","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The generic ","type":"text"},{"code":"where","type":"codeVoice"},{"text":" clause on ","type":"text"},{"code":"Iterator","type":"codeVoice"},{"text":" requires that the iterator must traverse over elements of the same item type as the container’s items, regardless of the iterator’s type. The ","type":"text"},{"code":"makeIterator()","type":"codeVoice"},{"text":" function provides access to a container’s iterator.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For a protocol that inherits from another protocol, you add a constraint to an inherited associated type by including the generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause in the protocol declaration. For example, the following code declares a "},{"code":"ComparableContainer","type":"codeVoice"},{"type":"text","text":" protocol that requires "},{"code":"Item","type":"codeVoice"},{"type":"text","text":" to conform to "},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["protocol ComparableContainer: Container where Item: Comparable { }"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Generic Subscripts","type":"heading","anchor":"Generic-Subscripts"},{"inlineContent":[{"type":"text","text":"Subscripts can be generic, and they can include generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clauses. You write the placeholder type name inside angle brackets after "},{"code":"subscript","type":"codeVoice"},{"type":"text","text":", and you write a generic "},{"code":"where","type":"codeVoice"},{"type":"text","text":" clause right before the opening curly brace of the subscript’s body. For example:"}],"type":"paragraph"},{"code":["extension Container {","    subscript<Indices: Sequence>(indices: Indices) -> [Item]","        where Indices.Iterator.Element == Int {","            var result: [Item] = []","            for index in indices {","                result.append(self[index])","            }","            return result","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This extension to the ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":" protocol adds a subscript that takes a sequence of indices and returns an array containing the items at each given index. This generic subscript is constrained as follows:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"The generic parameter ","type":"text"},{"type":"codeVoice","code":"Indices"},{"text":" in angle brackets has to be a type that conforms to the ","type":"text"},{"type":"codeVoice","code":"Sequence"},{"text":" protocol from the standard library.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"The subscript takes a single parameter, ","type":"text"},{"type":"codeVoice","code":"indices"},{"text":", which is an instance of that ","type":"text"},{"type":"codeVoice","code":"Indices"},{"text":" type.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The generic "},{"type":"codeVoice","code":"where"},{"type":"text","text":" clause requires that the iterator for the sequence must traverse over elements of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":". This ensures that the indices in the sequence are the same type as the indices used for a container."}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Taken together, these constraints mean that the value passed for the "},{"type":"codeVoice","code":"indices"},{"type":"text","text":" parameter is a sequence of integers."}],"type":"paragraph"}]}],"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"metadata":{"role":"article","modules":[{"name":"Swift"}],"title":"Generics","roleHeading":"Article"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics"},"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swift\/generics"]}],"references":{"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"title":"Error Handling","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","url":"\/documentation\/swift\/errorhandling"},"stackPoppedOneString":{"type":"image","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/stackPoppedOneString@2x.png"}],"identifier":"stackPoppedOneString"},"https://developer.apple.com/documentation/swift/hashable#2849490":{"url":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490","title":"Conforming to the Hashable Protocol","type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/hashable#2849490","titleInlineContent":[{"type":"text","text":"Conforming to the Hashable Protocol"}]},"doc://com.apple.Swift/documentation/Swift/Protocols#Adding-Protocol-Conformance-with-an-Extension":{"url":"\/documentation\/swift\/protocols#Adding-Protocol-Conformance-with-an-Extension","title":"Adding Protocol Conformance with an Extension","abstract":[],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Adding-Protocol-Conformance-with-an-Extension","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Functions":{"role":"article","type":"topic","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"kind":"article","url":"\/documentation\/swift\/functions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","role":"article","url":"\/documentation\/swift\/advancedoperators","abstract":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.","type":"text"}],"title":"Advanced Operators","kind":"article"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","role":"article","abstract":[{"inlineContent":[{"text":"Type casting","type":"text"}],"type":"emphasis"},{"text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.","type":"text"}],"title":"Type Casting","url":"\/documentation\/swift\/typecasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"url":"\/documentation\/swift\/initialization","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","type":"topic","title":"Initialization","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}]},"doc://com.apple.Swift/documentation/Swift/Functions#In-Out-Parameters":{"kind":"section","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#In-Out-Parameters","abstract":[],"title":"In-Out Parameters","url":"\/documentation\/swift\/functions#In-Out-Parameters"},"doc://com.apple.Swift/documentation/Swift/Closures":{"role":"article","type":"topic","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures"},"doc://com.apple.Swift/documentation/Swift/Generics#Type-Constraints":{"type":"topic","title":"Type Constraints","abstract":[],"kind":"section","url":"\/documentation\/swift\/generics#Type-Constraints","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Type-Constraints"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","abstract":[{"inlineContent":[{"text":"Access control","type":"text"}],"type":"emphasis"},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/accesscontrol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},"stackPushedFourStrings":{"type":"image","alt":null,"variants":[{"url":"\/images\/stackPushedFourStrings@2x.png","traits":["2x","light"]}],"identifier":"stackPushedFourStrings"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"type":"topic","role":"article","kind":"article","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"inlineContent":[{"type":"text","text":"Asynchronous code"}],"type":"emphasis"},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"inlineContent":[{"type":"text","text":"Parallel code"}],"type":"emphasis"},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"title":"Concurrency","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"url":"\/documentation\/swift\/automaticreferencecounting","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"Automatic Reference Counting","type":"text"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Generics#Associated-Types-with-a-Generic-Where-Clause":{"url":"\/documentation\/swift\/generics#Associated-Types-with-a-Generic-Where-Clause","title":"Associated Types with a Generic Where Clause","abstract":[],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Associated-Types-with-a-Generic-Where-Clause","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","kind":"article","role":"article"},"stackPushPop":{"type":"image","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/stackPushPop@2x.png"}],"identifier":"stackPushPop"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"url":"\/documentation\/swift\/protocols","title":"Protocols","abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"protocol","type":"text"}],"type":"emphasis"},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"type":"text","text":"adopted"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"conform","type":"text"}]},{"text":" to that protocol.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"role":"article","type":"topic","title":"Control Flow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"kind":"article","url":"\/documentation\/swift\/controlflow","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","title":"Subscripts","url":"\/documentation\/swift\/subscripts","role":"article","kind":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"title":"Swift","url":"\/documentation\/swift","role":"collection"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"url":"\/documentation\/swift\/opaquetypes","title":"Opaque Types","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword. Deinitializers are only available on class types.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes#Dictionaries":{"kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes#Dictionaries","url":"\/documentation\/swift\/collectiontypes#Dictionaries","abstract":[],"type":"topic","title":"Dictionaries"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","role":"article","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","title":"Memory Safety","type":"topic","url":"\/documentation\/swift\/memorysafety"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"abstract":[{"type":"text","text":"An "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"type":"codeVoice","code":"+"},{"text":") adds two numbers, as in ","type":"text"},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"type":"topic","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","url":"\/documentation\/swift\/basicoperators","kind":"article","title":"Basic Operators"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"kind":"article","role":"article","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"text":"inherit","type":"text"}]},{"type":"text","text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":", and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"text":"superclass","type":"text"}]},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","type":"topic","url":"\/documentation\/swift\/inheritance"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"title":"Optional Chaining","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"kind":"article","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","title":"Extensions","type":"topic","url":"\/documentation\/swift\/extensions"},"doc://com.apple.Swift/documentation/Swift/Generics#Extensions-with-a-Generic-Where-Clause":{"type":"topic","title":"Extensions with a Generic Where Clause","abstract":[],"kind":"section","url":"\/documentation\/swift\/generics#Extensions-with-a-Generic-Where-Clause","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Extensions-with-a-Generic-Where-Clause"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"role":"article","type":"topic","title":"Nested Types","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"inlineContent":[{"text":"nested types","type":"text"}],"type":"emphasis"},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/nestedtypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","abstract":[{"inlineContent":[{"text":"Structures","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.","type":"text"}],"title":"Structures and Classes","url":"\/documentation\/swift\/classesandstructures","role":"article"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"title":"Enumerations","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Protocols#Declaring-Protocol-Adoption-with-an-Extension":{"title":"Declaring Protocol Adoption with an Extension","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols#Declaring-Protocol-Adoption-with-an-Extension","abstract":[],"url":"\/documentation\/swift\/protocols#Declaring-Protocol-Adoption-with-an-Extension","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Generics#Generic-Types":{"title":"Generic Types","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics#Generic-Types","abstract":[],"url":"\/documentation\/swift\/generics#Generic-Types","type":"topic"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","title":"Collection Types","abstract":[{"text":"Swift provides three primary ","type":"text"},{"inlineContent":[{"text":"collection types","type":"text"}],"type":"emphasis"},{"text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/collectiontypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"title":"Strings and Characters","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" is a series of characters, such as "},{"code":"\"hello, world\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"albatross\"","type":"codeVoice"},{"text":". Swift strings are represented by the ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type. The contents of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values.","type":"text"}],"type":"topic","kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","role":"article","url":"\/documentation\/swift\/stringsandcharacters"}}}