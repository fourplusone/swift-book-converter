{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting"},"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, in a few cases ARC requires more information about the relationships between parts of your code in order to manage memory for you. This chapter describes those situations and shows how you enable ARC to manage all of your app’s memory. Using ARC in Swift is very similar to the approach described in "},{"identifier":"https:\/\/developer.apple.com\/library\/content\/releasenotes\/ObjectiveC\/RN-TransitioningToARC\/Introduction\/Introduction.html","isActive":true,"type":"reference"},{"text":" [https:\/\/developer.apple.com\/library\/content\/releasenotes\/ObjectiveC\/RN-TransitioningToARC\/Introduction\/Introduction.html]","type":"text"},{"text":" for using ARC with Objective-C.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reference counting applies only to instances of classes. Structures and enumerations are value types, not reference types, and aren’t stored and passed by reference."}]},{"type":"heading","level":2,"text":"How ARC Works","anchor":"How-ARC-Works"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Every time you create a new instance of a class, ARC allocates a chunk of memory to store information about that instance. This memory holds information about the type of the instance, together with the values of any stored properties associated with that instance."}]},{"type":"paragraph","inlineContent":[{"text":"Additionally, when an instance is no longer needed, ARC frees up the memory used by that instance so that the memory can be used for other purposes instead. This ensures that class instances don’t take up space in memory when they’re no longer needed.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"However, if ARC were to deallocate an instance that was still in use, it would no longer be possible to access that instance’s properties, or call that instance’s methods. Indeed, if you tried to access the instance, your app would most likely crash.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To make sure that instances don’t disappear while they’re still needed, ARC tracks how many properties, constants, and variables are currently referring to each class instance. ARC will not deallocate an instance as long as at least one active reference to that instance still exists."}]},{"type":"paragraph","inlineContent":[{"text":"To make this possible, whenever you assign a class instance to a property, constant, or variable, that property, constant, or variable makes a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"strong reference","type":"text"}]},{"text":" to the instance. The reference is called a “strong” reference because it keeps a firm hold on that instance, and doesn’t allow it to be deallocated for as long as that strong reference remains.","type":"text"}]},{"type":"heading","level":2,"text":"ARC in Action","anchor":"ARC-in-Action"},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of how Automatic Reference Counting works. This example starts with a simple class called ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":", which defines a stored constant property called ","type":"text"},{"code":"name","type":"codeVoice"},{"text":":","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class Person {","    let name: String","    init(name: String) {","        self.name = name","        print(\"\\(name) is being initialized\")","    }","    deinit {","        print(\"\\(name) is being deinitialized\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" class has an initializer that sets the instance’s "},{"type":"codeVoice","code":"name"},{"type":"text","text":" property and prints a message to indicate that initialization is underway. The "},{"type":"codeVoice","code":"Person"},{"text":" class also has a deinitializer that prints a message when an instance of the class is deallocated.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The next code snippet defines three variables of type ","type":"text"},{"code":"Person?","type":"codeVoice"},{"text":", which are used to set up multiple references to a new ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance in subsequent code snippets. Because these variables are of an optional type (","type":"text"},{"code":"Person?","type":"codeVoice"},{"text":", not ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":"), they’re automatically initialized with a value of ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", and don’t currently reference a ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["var reference1: Person?","var reference2: Person?","var reference3: Person?"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now create a new "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance and assign it to one of these three variables:"}]},{"syntax":"swift","type":"codeListing","code":["reference1 = Person(name: \"John Appleseed\")","\/\/ Prints \"John Appleseed is being initialized\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the message "},{"code":"\"John Appleseed is being initialized\"","type":"codeVoice"},{"type":"text","text":" is printed at the point that you call the "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" class’s initializer. This confirms that initialization has taken place."}]},{"type":"paragraph","inlineContent":[{"text":"Because the new ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance has been assigned to the ","type":"text"},{"code":"reference1","type":"codeVoice"},{"text":" variable, there’s now a strong reference from ","type":"text"},{"code":"reference1","type":"codeVoice"},{"text":" to the new ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance. Because there’s at least one strong reference, ARC makes sure that this ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" is kept in memory and isn’t deallocated.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you assign the same "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" instance to two more variables, two more strong references to that instance are established:"}]},{"syntax":"swift","type":"codeListing","code":["reference2 = reference1","reference3 = reference1"]},{"type":"paragraph","inlineContent":[{"text":"There are now ","type":"text"},{"inlineContent":[{"text":"three","type":"text"}],"type":"emphasis"},{"text":" strong references to this single ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If you break two of these strong references (including the original reference) by assigning ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" to two of the variables, a single strong reference remains, and the ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance isn’t deallocated:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["reference1 = nil","reference2 = nil"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"ARC doesn’t deallocate the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance until the third and final strong reference is broken, at which point it’s clear that you are no longer using the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance:"}]},{"syntax":"swift","type":"codeListing","code":["reference3 = nil","\/\/ Prints \"John Appleseed is being deinitialized\""]},{"type":"heading","level":2,"text":"Strong Reference Cycles Between Class Instances","anchor":"Strong-Reference-Cycles-Between-Class-Instances"},{"type":"paragraph","inlineContent":[{"text":"In the examples above, ARC is able to track the number of references to the new ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance you create and to deallocate that ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance when it’s no longer needed.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, it’s possible to write code in which an instance of a class "},{"type":"emphasis","inlineContent":[{"type":"text","text":"never"}]},{"type":"text","text":" gets to a point where it has zero strong references. This can happen if two class instances hold a strong reference to each other, such that each instance keeps the other alive. This is known as a "},{"type":"emphasis","inlineContent":[{"text":"strong reference cycle","type":"text"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You resolve strong reference cycles by defining some of the relationships between classes as weak or unowned references instead of as strong references. This process is described in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-Between-Class-Instances"},{"type":"text","text":". However, before you learn how to resolve a strong reference cycle, it’s useful to understand how such a cycle is caused."}]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of how a strong reference cycle can be created by accident. This example defines two classes called ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Apartment","type":"codeVoice"},{"text":", which model a block of apartments and its residents:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class Person {","    let name: String","    init(name: String) { self.name = name }","    var apartment: Apartment?","    deinit { print(\"\\(name) is being deinitialized\") }","}","","class Apartment {","    let unit: String","    init(unit: String) { self.unit = unit }","    var tenant: Person?","    deinit { print(\"Apartment \\(unit) is being deinitialized\") }","}"]},{"type":"paragraph","inlineContent":[{"text":"Every ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance has a ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" property of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" and an optional ","type":"text"},{"code":"apartment","type":"codeVoice"},{"text":" property that’s initially ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". The ","type":"text"},{"code":"apartment","type":"codeVoice"},{"text":" property is optional, because a person may not always have an apartment.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Similarly, every ","type":"text"},{"type":"codeVoice","code":"Apartment"},{"text":" instance has a ","type":"text"},{"type":"codeVoice","code":"unit"},{"text":" property of type ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" and has an optional ","type":"text"},{"type":"codeVoice","code":"tenant"},{"text":" property that’s initially ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":". The tenant property is optional because an apartment may not always have a tenant.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Both of these classes also define a deinitializer, which prints the fact that an instance of that class is being deinitialized. This enables you to see whether instances of ","type":"text"},{"type":"codeVoice","code":"Person"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Apartment"},{"text":" are being deallocated as expected.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This next code snippet defines two variables of optional type called "},{"type":"codeVoice","code":"john"},{"type":"text","text":" and "},{"type":"codeVoice","code":"unit4A"},{"type":"text","text":", which will be set to a specific "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance below. Both of these variables have an initial value of "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", by virtue of being optional:"}]},{"syntax":"swift","type":"codeListing","code":["var john: Person?","var unit4A: Apartment?"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now create a specific "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" instance and "},{"code":"Apartment","type":"codeVoice"},{"type":"text","text":" instance and assign these new instances to the "},{"code":"john","type":"codeVoice"},{"type":"text","text":" and "},{"code":"unit4A","type":"codeVoice"},{"type":"text","text":" variables:"}]},{"syntax":"swift","type":"codeListing","code":["john = Person(name: \"John Appleseed\")","unit4A = Apartment(unit: \"4A\")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the strong references look after creating and assigning these two instances. The "},{"type":"codeVoice","code":"john"},{"type":"text","text":" variable now has a strong reference to the new "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance, and the "},{"type":"codeVoice","code":"unit4A"},{"type":"text","text":" variable has a strong reference to the new "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" instance:"}]},{"type":"paragraph","inlineContent":[{"identifier":"referenceCycle01","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now link the two instances together so that the person has an apartment, and the apartment has a tenant. Note that an exclamation point ("},{"type":"codeVoice","code":"!"},{"type":"text","text":") is used to unwrap and access the instances stored inside the "},{"type":"codeVoice","code":"john"},{"type":"text","text":" and "},{"type":"codeVoice","code":"unit4A"},{"type":"text","text":" optional variables, so that the properties of those instances can be set:"}]},{"syntax":"swift","type":"codeListing","code":["john!.apartment = unit4A","unit4A!.tenant = john"]},{"type":"paragraph","inlineContent":[{"text":"Here’s how the strong references look after you link the two instances together:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"referenceCycle02","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Unfortunately, linking these two instances creates a strong reference cycle between them. The ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance now has a strong reference to the ","type":"text"},{"code":"Apartment","type":"codeVoice"},{"text":" instance, and the ","type":"text"},{"code":"Apartment","type":"codeVoice"},{"text":" instance has a strong reference to the ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance. Therefore, when you break the strong references held by the ","type":"text"},{"code":"john","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"unit4A","type":"codeVoice"},{"text":" variables, the reference counts don’t drop to zero, and the instances aren’t deallocated by ARC:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["john = nil","unit4A = nil"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that neither deinitializer was called when you set these two variables to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". The strong reference cycle prevents the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" instances from ever being deallocated, causing a memory leak in your app."}]},{"type":"paragraph","inlineContent":[{"text":"Here’s how the strong references look after you set the ","type":"text"},{"type":"codeVoice","code":"john"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"unit4A"},{"text":" variables to ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":":","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"referenceCycle03"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The strong references between the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" instance and the "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" instance remain and can’t be broken."}]},{"type":"heading","level":2,"text":"Resolving Strong Reference Cycles Between Class Instances","anchor":"Resolving-Strong-Reference-Cycles-Between-Class-Instances"},{"type":"paragraph","inlineContent":[{"text":"Swift provides two ways to resolve strong reference cycles when you work with properties of class type: weak references and unowned references.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Weak and unowned references enable one instance in a reference cycle to refer to the other instance ","type":"text"},{"inlineContent":[{"type":"text","text":"without"}],"type":"emphasis"},{"text":" keeping a strong hold on it. The instances can then refer to each other without creating a strong reference cycle.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Use a weak reference when the other instance has a shorter lifetime—that is, when the other instance can be deallocated first. In the ","type":"text"},{"code":"Apartment","type":"codeVoice"},{"text":" example above, it’s appropriate for an apartment to be able to have no tenant at some point in its lifetime, and so a weak reference is an appropriate way to break the reference cycle in this case. In contrast, use an unowned reference when the other instance has the same lifetime or a longer lifetime.","type":"text"}]},{"type":"heading","level":3,"text":"Weak References","anchor":"Weak-References"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"weak reference","type":"text"}]},{"type":"text","text":" is a reference that doesn’t keep a strong hold on the instance it refers to, and so doesn’t stop ARC from disposing of the referenced instance. This behavior prevents the reference from becoming part of a strong reference cycle. You indicate a weak reference by placing the "},{"type":"codeVoice","code":"weak"},{"type":"text","text":" keyword before a property or variable declaration."}]},{"type":"paragraph","inlineContent":[{"text":"Because a weak reference doesn’t keep a strong hold on the instance it refers to, it’s possible for that instance to be deallocated while the weak reference is still referring to it. Therefore, ARC automatically sets a weak reference to ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" when the instance that it refers to is deallocated. And, because weak references need to allow their value to be changed to ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" at runtime, they’re always declared as variables, rather than constants, of an optional type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can check for the existence of a value in the weak reference, just like any other optional value, and you will never end up with a reference to an invalid instance that no longer exists.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Property observers aren’t called when ARC sets a weak reference to ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":".","type":"text"}]}],"type":"aside","name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below is identical to the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" example from above, with one important difference. This time around, the "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" type’s "},{"type":"codeVoice","code":"tenant"},{"type":"text","text":" property is declared as a weak reference:"}]},{"syntax":"swift","type":"codeListing","code":["class Person {","    let name: String","    init(name: String) { self.name = name }","    var apartment: Apartment?","    deinit { print(\"\\(name) is being deinitialized\") }","}","","class Apartment {","    let unit: String","    init(unit: String) { self.unit = unit }","    weak var tenant: Person?","    deinit { print(\"Apartment \\(unit) is being deinitialized\") }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The strong references from the two variables ("},{"type":"codeVoice","code":"john"},{"type":"text","text":" and "},{"type":"codeVoice","code":"unit4A"},{"type":"text","text":") and the links between the two instances are created as before:"}]},{"syntax":"swift","type":"codeListing","code":["var john: Person?","var unit4A: Apartment?","","john = Person(name: \"John Appleseed\")","unit4A = Apartment(unit: \"4A\")","","john!.apartment = unit4A","unit4A!.tenant = john"]},{"type":"paragraph","inlineContent":[{"text":"Here’s how the references look now that you’ve linked the two instances together:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"weakReference01","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" instance still has a strong reference to the "},{"code":"Apartment","type":"codeVoice"},{"type":"text","text":" instance, but the "},{"code":"Apartment","type":"codeVoice"},{"type":"text","text":" instance now has a "},{"inlineContent":[{"type":"text","text":"weak"}],"type":"emphasis"},{"type":"text","text":" reference to the "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" instance. This means that when you break the strong reference held by the "},{"code":"john","type":"codeVoice"},{"type":"text","text":" variable by setting it to "},{"code":"nil","type":"codeVoice"},{"type":"text","text":", there are no more strong references to the "},{"code":"Person","type":"codeVoice"},{"type":"text","text":" instance:"}]},{"syntax":"swift","type":"codeListing","code":["john = nil","\/\/ Prints \"John Appleseed is being deinitialized\""]},{"type":"paragraph","inlineContent":[{"text":"Because there are no more strong references to the ","type":"text"},{"code":"Person","type":"codeVoice"},{"text":" instance, it’s deallocated and the ","type":"text"},{"code":"tenant","type":"codeVoice"},{"text":" property is set to ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"weakReference02","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The only remaining strong reference to the "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" instance is from the "},{"type":"codeVoice","code":"unit4A"},{"type":"text","text":" variable. If you break "},{"type":"emphasis","inlineContent":[{"type":"text","text":"that"}]},{"type":"text","text":" strong reference, there are no more strong references to the "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" instance:"}]},{"syntax":"swift","type":"codeListing","code":["unit4A = nil","\/\/ Prints \"Apartment 4A is being deinitialized\""]},{"type":"paragraph","inlineContent":[{"text":"Because there are no more strong references to the ","type":"text"},{"code":"Apartment","type":"codeVoice"},{"text":" instance, it too is deallocated:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"weakReference03","type":"image"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In systems that use garbage collection, weak pointers are sometimes used to implement a simple caching mechanism because objects with no strong references are deallocated only when memory pressure triggers garbage collection. However, with ARC, values are deallocated as soon as their last strong reference is removed, making weak references unsuitable for such a purpose."}]}],"type":"aside","name":"Note","style":"note"},{"type":"heading","level":3,"text":"Unowned References","anchor":"Unowned-References"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Like a weak reference, an "},{"type":"emphasis","inlineContent":[{"type":"text","text":"unowned reference"}]},{"type":"text","text":" doesn’t keep a strong hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is used when the other instance has the same lifetime or a longer lifetime. You indicate an unowned reference by placing the "},{"code":"unowned","type":"codeVoice"},{"type":"text","text":" keyword before a property or variable declaration."}]},{"type":"paragraph","inlineContent":[{"text":"Unlike a weak reference, an unowned reference is expected to always have a value. As a result, marking a value as unowned doesn’t make it optional, and ARC never sets an unowned reference’s value to ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}]},{"content":[{"inlineContent":[{"type":"text","text":"Use an unowned reference only when you are sure that the reference "},{"type":"emphasis","inlineContent":[{"text":"always","type":"text"}]},{"type":"text","text":" refers to an instance that hasn’t been deallocated."}],"type":"paragraph"},{"inlineContent":[{"text":"If you try to access the value of an unowned reference after that instance has been deallocated, you’ll get a runtime error.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Important","style":"important"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example defines two classes, "},{"type":"codeVoice","code":"Customer"},{"type":"text","text":" and "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":", which model a bank customer and a possible credit card for that customer. These two classes each store an instance of the other class as a property. This relationship has the potential to create a strong reference cycle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The relationship between "},{"type":"codeVoice","code":"Customer"},{"type":"text","text":" and "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":" is slightly different from the relationship between "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" seen in the weak reference example above. In this data model, a customer may or may not have a credit card, but a credit card will "},{"inlineContent":[{"text":"always","type":"text"}],"type":"emphasis"},{"type":"text","text":" be associated with a customer. A "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":" instance never outlives the "},{"type":"codeVoice","code":"Customer"},{"type":"text","text":" that it refers to. To represent this, the "},{"type":"codeVoice","code":"Customer"},{"type":"text","text":" class has an optional "},{"type":"codeVoice","code":"card"},{"type":"text","text":" property, but the "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":" class has an unowned (and non-optional) "},{"type":"codeVoice","code":"customer"},{"type":"text","text":" property."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, a new "},{"code":"CreditCard","type":"codeVoice"},{"type":"text","text":" instance can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"only"}]},{"type":"text","text":" be created by passing a "},{"code":"number","type":"codeVoice"},{"type":"text","text":" value and a "},{"code":"customer","type":"codeVoice"},{"type":"text","text":" instance to a custom "},{"code":"CreditCard","type":"codeVoice"},{"type":"text","text":" initializer. This ensures that a "},{"code":"CreditCard","type":"codeVoice"},{"type":"text","text":" instance always has a "},{"code":"customer","type":"codeVoice"},{"type":"text","text":" instance associated with it when the "},{"code":"CreditCard","type":"codeVoice"},{"type":"text","text":" instance is created."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because a credit card will always have a customer, you define its "},{"code":"customer","type":"codeVoice"},{"type":"text","text":" property as an unowned reference, to avoid a strong reference cycle:"}]},{"syntax":"swift","type":"codeListing","code":["class Customer {","    let name: String","    var card: CreditCard?","    init(name: String) {","        self.name = name","    }","    deinit { print(\"\\(name) is being deinitialized\") }","}","","class CreditCard {","    let number: UInt64","    unowned let customer: Customer","    init(number: UInt64, customer: Customer) {","        self.number = number","        self.customer = customer","    }","    deinit { print(\"Card #\\(number) is being deinitialized\") }","}"]},{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"number"},{"type":"text","text":" property of the "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":" class is defined with a type of "},{"type":"codeVoice","code":"UInt64"},{"type":"text","text":" rather than "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", to ensure that the "},{"type":"codeVoice","code":"number"},{"type":"text","text":" property’s capacity is large enough to store a 16-digit card number on both 32-bit and 64-bit systems."}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This next code snippet defines an optional "},{"code":"Customer","type":"codeVoice"},{"type":"text","text":" variable called "},{"code":"john","type":"codeVoice"},{"type":"text","text":", which will be used to store a reference to a specific customer. This variable has an initial value of nil, by virtue of being optional:"}]},{"syntax":"swift","type":"codeListing","code":["var john: Customer?"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now create a "},{"code":"Customer","type":"codeVoice"},{"type":"text","text":" instance, and use it to initialize and assign a new "},{"code":"CreditCard","type":"codeVoice"},{"type":"text","text":" instance as that customer’s "},{"code":"card","type":"codeVoice"},{"type":"text","text":" property:"}]},{"syntax":"swift","type":"codeListing","code":["john = Customer(name: \"John Appleseed\")","john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how the references look, now that you’ve linked the two instances:"}]},{"type":"paragraph","inlineContent":[{"identifier":"unownedReference01","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Customer"},{"text":" instance now has a strong reference to the ","type":"text"},{"type":"codeVoice","code":"CreditCard"},{"text":" instance, and the ","type":"text"},{"type":"codeVoice","code":"CreditCard"},{"text":" instance has an unowned reference to the ","type":"text"},{"type":"codeVoice","code":"Customer"},{"text":" instance.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Because of the unowned ","type":"text"},{"code":"customer","type":"codeVoice"},{"text":" reference, when you break the strong reference held by the ","type":"text"},{"code":"john","type":"codeVoice"},{"text":" variable, there are no more strong references to the ","type":"text"},{"code":"Customer","type":"codeVoice"},{"text":" instance:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"unownedReference02","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Because there are no more strong references to the ","type":"text"},{"type":"codeVoice","code":"Customer"},{"text":" instance, it’s deallocated. After this happens, there are no more strong references to the ","type":"text"},{"type":"codeVoice","code":"CreditCard"},{"text":" instance, and it too is deallocated:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["john = nil","\/\/ Prints \"John Appleseed is being deinitialized\"","\/\/ Prints \"Card #1234567890123456 is being deinitialized\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The final code snippet above shows that the deinitializers for the "},{"type":"codeVoice","code":"Customer"},{"type":"text","text":" instance and "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":" instance both print their “deinitialized” messages after the "},{"type":"codeVoice","code":"john"},{"type":"text","text":" variable is set to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The examples above show how to use ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"safe","type":"text"}]},{"text":" unowned references. Swift also provides ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"unsafe","type":"text"}]},{"text":" unowned references for cases where you need to disable runtime safety checks—for example, for performance reasons. As with all unsafe operations, you take on the responsibility for checking that code for safety.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You indicate an unsafe unowned reference by writing "},{"type":"codeVoice","code":"unowned(unsafe)"},{"type":"text","text":". If you try to access an unsafe unowned reference after the instance that it refers to is deallocated, your program will try to access the memory location where the instance used to be, which is an unsafe operation."}]}],"type":"aside","name":"Note","style":"note"},{"type":"heading","level":3,"text":"Unowned Optional References","anchor":"Unowned-Optional-References"},{"type":"paragraph","inlineContent":[{"text":"You can mark an optional reference to a class as unowned. In terms of the ARC ownership model, an unowned optional reference and a weak reference can both be used in the same contexts. The difference is that when you use an unowned optional reference, you’re responsible for making sure it always refers to a valid object or is set to ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example that keeps track of the courses offered by a particular department at a school:"}]},{"syntax":"swift","type":"codeListing","code":["class Department {","    var name: String","    var courses: [Course]","    init(name: String) {","        self.name = name","        self.courses = []","    }","}","","class Course {","    var name: String","    unowned var department: Department","    unowned var nextCourse: Course?","    init(name: String, in department: Department) {","        self.name = name","        self.department = department","        self.nextCourse = nil","    }","}"]},{"type":"paragraph","inlineContent":[{"code":"Department","type":"codeVoice"},{"type":"text","text":" maintains a strong reference to each course that the department offers. In the ARC ownership model, a department owns its courses. "},{"code":"Course","type":"codeVoice"},{"type":"text","text":" has two unowned references, one to the department and one to the next course a student should take; a course doesn’t own either of these objects. Every course is part of some department so the "},{"code":"department","type":"codeVoice"},{"type":"text","text":" property isn’t an optional. However, because some courses don’t have a recommended follow-on course, the "},{"code":"nextCourse","type":"codeVoice"},{"type":"text","text":" property is an optional."}]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of using these classes:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let department = Department(name: \"Horticulture\")","","let intro = Course(name: \"Survey of Plants\", in: department)","let intermediate = Course(name: \"Growing Common Herbs\", in: department)","let advanced = Course(name: \"Caring for Tropical Plants\", in: department)","","intro.nextCourse = intermediate","intermediate.nextCourse = advanced","department.courses = [intro, intermediate, advanced]"]},{"type":"paragraph","inlineContent":[{"text":"The code above creates a department and its three courses. The intro and intermediate courses both have a suggested next course stored in their ","type":"text"},{"code":"nextCourse","type":"codeVoice"},{"text":" property, which maintains an unowned optional reference to the course a student should take after completing this one.","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"unownedOptionalReference","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"An unowned optional reference doesn’t keep a strong hold on the instance of the class that it wraps, and so it doesn’t prevent ARC from deallocating the instance. It behaves the same as an unowned reference does under ARC, except that an unowned optional reference can be ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Like non-optional unowned references, you’re responsible for ensuring that ","type":"text"},{"code":"nextCourse","type":"codeVoice"},{"text":" always refers to a course that hasn’t been deallocated. In this case, for example, when you delete a course from ","type":"text"},{"code":"department.courses","type":"codeVoice"},{"text":" you also need to remove any references to it that other courses might have.","type":"text"}]},{"content":[{"inlineContent":[{"type":"text","text":"The underlying type of an optional value is "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":", which is an enumeration in the Swift standard library. However, optionals are an exception to the rule that value types can’t be marked with "},{"type":"codeVoice","code":"unowned"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The optional that wraps the class doesn’t use reference counting, so you don’t need to maintain a strong reference to the optional.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"},{"type":"heading","level":3,"text":"Unowned References and Implicitly Unwrapped Optional Properties","anchor":"Unowned-References-and-Implicitly-Unwrapped-Optional-Properties"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The examples for weak and unowned references above cover two of the more common scenarios in which it’s necessary to break a strong reference cycle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Apartment"},{"type":"text","text":" example shows a situation where two properties, both of which are allowed to be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", have the potential to cause a strong reference cycle. This scenario is best resolved with a weak reference."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"Customer"},{"type":"text","text":" and "},{"type":"codeVoice","code":"CreditCard"},{"type":"text","text":" example shows a situation where one property that’s allowed to be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" and another property that can’t be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" have the potential to cause a strong reference cycle. This scenario is best resolved with an unowned reference."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, there’s a third scenario, in which "},{"type":"emphasis","inlineContent":[{"text":"both","type":"text"}]},{"type":"text","text":" properties should always have a value, and neither property should ever be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" once initialization is complete. In this scenario, it’s useful to combine an unowned property on one class with an implicitly unwrapped optional property on the other class."}]},{"type":"paragraph","inlineContent":[{"text":"This enables both properties to be accessed directly (without optional unwrapping) once initialization is complete, while still avoiding a reference cycle. This section shows you how to set up such a relationship.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The example below defines two classes, ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"City","type":"codeVoice"},{"text":", each of which stores an instance of the other class as a property. In this data model, every country must always have a capital city, and every city must always belong to a country. To represent this, the ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" class has a ","type":"text"},{"code":"capitalCity","type":"codeVoice"},{"text":" property, and the ","type":"text"},{"code":"City","type":"codeVoice"},{"type":"text","text":" class has a "},{"code":"country","type":"codeVoice"},{"type":"text","text":" property:"}]},{"syntax":"swift","type":"codeListing","code":["class Country {","    let name: String","    var capitalCity: City!","    init(name: String, capitalName: String) {","        self.name = name","        self.capitalCity = City(name: capitalName, country: self)","    }","}","","class City {","    let name: String","    unowned let country: Country","    init(name: String, country: Country) {","        self.name = name","        self.country = country","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"To set up the interdependency between the two classes, the initializer for ","type":"text"},{"type":"codeVoice","code":"City"},{"text":" takes a ","type":"text"},{"type":"codeVoice","code":"Country"},{"text":" instance, and stores this instance in its ","type":"text"},{"type":"codeVoice","code":"country"},{"text":" property.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The initializer for ","type":"text"},{"code":"City","type":"codeVoice"},{"text":" is called from within the initializer for ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":". However, the initializer for ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" can’t pass ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" to the ","type":"text"},{"code":"City","type":"codeVoice"},{"text":" initializer until a new ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" instance is fully initialized, as described in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Two-Phase-Initialization","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"To cope with this requirement, you declare the ","type":"text"},{"code":"capitalCity","type":"codeVoice"},{"text":" property of ","type":"text"},{"code":"Country","type":"codeVoice"},{"text":" as an implicitly unwrapped optional property, indicated by the exclamation point at the end of its type annotation (","type":"text"},{"code":"City!","type":"codeVoice"},{"text":"). This means that the ","type":"text"},{"code":"capitalCity","type":"codeVoice"},{"text":" property has a default value of ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", like any other optional, but can be accessed without the need to unwrap its value as described in ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Implicitly-Unwrapped-Optionals"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because "},{"type":"codeVoice","code":"capitalCity"},{"type":"text","text":" has a default "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" value, a new "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" instance is considered fully initialized as soon as the "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" instance sets its "},{"type":"codeVoice","code":"name"},{"type":"text","text":" property within its initializer. This means that the "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" initializer can start to reference and pass around the implicit "},{"type":"codeVoice","code":"self"},{"type":"text","text":" property as soon as the "},{"type":"codeVoice","code":"name"},{"type":"text","text":" property is set. The "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" initializer can therefore pass "},{"type":"codeVoice","code":"self"},{"type":"text","text":" as one of the parameters for the "},{"type":"codeVoice","code":"City"},{"type":"text","text":" initializer when the "},{"type":"codeVoice","code":"Country"},{"type":"text","text":" initializer is setting its own "},{"type":"codeVoice","code":"capitalCity"},{"type":"text","text":" property."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of this means that you can create the "},{"code":"Country","type":"codeVoice"},{"type":"text","text":" and "},{"code":"City","type":"codeVoice"},{"type":"text","text":" instances in a single statement, without creating a strong reference cycle, and the "},{"code":"capitalCity","type":"codeVoice"},{"type":"text","text":" property can be accessed directly, without needing to use an exclamation point to unwrap its optional value:"}]},{"syntax":"swift","type":"codeListing","code":["var country = Country(name: \"Canada\", capitalName: \"Ottawa\")","print(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")","\/\/ Prints \"Canada's capital city is called Ottawa\""]},{"type":"paragraph","inlineContent":[{"text":"In the example above, the use of an implicitly unwrapped optional means that all of the two-phase class initializer requirements are satisfied. The ","type":"text"},{"type":"codeVoice","code":"capitalCity"},{"text":" property can be used and accessed like a non-optional value once initialization is complete, while still avoiding a strong reference cycle.","type":"text"}]},{"type":"heading","level":2,"text":"Strong Reference Cycles for Closures","anchor":"Strong-Reference-Cycles-for-Closures"},{"type":"paragraph","inlineContent":[{"text":"You saw above how a strong reference cycle can be created when two class instance properties hold a strong reference to each other. You also saw how to use weak and unowned references to break these strong reference cycles.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A strong reference cycle can also occur if you assign a closure to a property of a class instance, and the body of that closure captures the instance. This capture might occur because the closure’s body accesses a property of the instance, such as "},{"type":"codeVoice","code":"self.someProperty"},{"type":"text","text":", or because the closure calls a method on the instance, such as "},{"type":"codeVoice","code":"self.someMethod()"},{"type":"text","text":". In either case, these accesses cause the closure to “capture” "},{"type":"codeVoice","code":"self"},{"type":"text","text":", creating a strong reference cycle."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This strong reference cycle occurs because closures, like classes, are "},{"type":"emphasis","inlineContent":[{"text":"reference types","type":"text"}]},{"type":"text","text":". When you assign a closure to a property, you are assigning a "},{"type":"emphasis","inlineContent":[{"text":"reference","type":"text"}]},{"type":"text","text":" to that closure. In essence, it’s the same problem as above—two strong references are keeping each other alive. However, rather than two class instances, this time it’s a class instance and a closure that are keeping each other alive."}]},{"type":"paragraph","inlineContent":[{"text":"Swift provides an elegant solution to this problem, known as a ","type":"text"},{"inlineContent":[{"text":"closure capture list","type":"text"}],"type":"emphasis"},{"text":". However, before you learn how to break a strong reference cycle with a closure capture list, it’s useful to understand how such a cycle can be caused.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The example below shows how you can create a strong reference cycle when using a closure that references ","type":"text"},{"code":"self","type":"codeVoice"},{"text":". This example defines a class called ","type":"text"},{"code":"HTMLElement","type":"codeVoice"},{"text":", which provides a simple model for an individual element within an HTML document:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["class HTMLElement {","","    let name: String","    let text: String?","","    lazy var asHTML: () -> String = {","        if let text = self.text {","            return \"<\\(self.name)>\\(text)<\/\\(self.name)>\"","        } else {","            return \"<\\(self.name) \/>\"","        }","    }","","    init(name: String, text: String? = nil) {","        self.name = name","        self.text = text","    }","","    deinit {","        print(\"\\(name) is being deinitialized\")","    }","","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"HTMLElement","type":"codeVoice"},{"type":"text","text":" class defines a "},{"code":"name","type":"codeVoice"},{"type":"text","text":" property, which indicates the name of the element, such as "},{"code":"\"h1\"","type":"codeVoice"},{"type":"text","text":" for a heading element, "},{"code":"\"p\"","type":"codeVoice"},{"type":"text","text":" for a paragraph element, or "},{"code":"\"br\"","type":"codeVoice"},{"type":"text","text":" for a line break element. "},{"code":"HTMLElement","type":"codeVoice"},{"type":"text","text":" also defines an optional "},{"code":"text","type":"codeVoice"},{"type":"text","text":" property, which you can set to a string that represents the text to be rendered within that HTML element."}]},{"type":"paragraph","inlineContent":[{"text":"In addition to these two simple properties, the ","type":"text"},{"type":"codeVoice","code":"HTMLElement"},{"text":" class defines a lazy property called ","type":"text"},{"type":"codeVoice","code":"asHTML"},{"text":". This property references a closure that combines ","type":"text"},{"type":"codeVoice","code":"name"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"text"},{"text":" into an HTML string fragment. The ","type":"text"},{"type":"codeVoice","code":"asHTML"},{"text":" property is of type ","type":"text"},{"type":"codeVoice","code":"() -> String"},{"text":", or “a function that takes no parameters, and returns a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" value”.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"By default, the ","type":"text"},{"code":"asHTML","type":"codeVoice"},{"text":" property is assigned a closure that returns a string representation of an HTML tag. This tag contains the optional ","type":"text"},{"code":"text","type":"codeVoice"},{"text":" value if it exists, or no text content if ","type":"text"},{"code":"text","type":"codeVoice"},{"text":" doesn’t exist. For a paragraph element, the closure would return ","type":"text"},{"code":"\"<p>some text<\/p>\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"<p \/>\"","type":"codeVoice"},{"text":", depending on whether the ","type":"text"},{"code":"text","type":"codeVoice"},{"text":" property equals ","type":"text"},{"code":"\"some text\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"asHTML"},{"type":"text","text":" property is named and used somewhat like an instance method. However, because "},{"type":"codeVoice","code":"asHTML"},{"type":"text","text":" is a closure property rather than an instance method, you can replace the default value of the "},{"type":"codeVoice","code":"asHTML"},{"type":"text","text":" property with a custom closure, if you want to change the HTML rendering for a particular HTML element."}]},{"type":"paragraph","inlineContent":[{"text":"For example, the ","type":"text"},{"type":"codeVoice","code":"asHTML"},{"text":" property could be set to a closure that defaults to some text if the ","type":"text"},{"type":"codeVoice","code":"text"},{"text":" property is ","type":"text"},{"type":"codeVoice","code":"nil"},{"text":", in order to prevent the representation from returning an empty HTML tag:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let heading = HTMLElement(name: \"h1\")","let defaultText = \"some default text\"","heading.asHTML = {","    return \"<\\(heading.name)>\\(heading.text ?? defaultText)<\/\\(heading.name)>\"","}","print(heading.asHTML())","\/\/ Prints \"<h1>some default text<\/h1>\""]},{"content":[{"inlineContent":[{"text":"The ","type":"text"},{"code":"asHTML","type":"codeVoice"},{"text":" property is declared as a lazy property, because it’s only needed if and when the element actually needs to be rendered as a string value for some HTML output target. The fact that ","type":"text"},{"code":"asHTML","type":"codeVoice"},{"text":" is a lazy property means that you can refer to ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" within the default closure, because the lazy property will not be accessed until after initialization has been completed and ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" is known to exist.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" class provides a single initializer, which takes a "},{"type":"codeVoice","code":"name"},{"type":"text","text":" argument and (if desired) a "},{"type":"codeVoice","code":"text"},{"type":"text","text":" argument to initialize a new element. The class also defines a deinitializer, which prints a message to show when an "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" instance is deallocated."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you use the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" class to create and print a new instance:"}]},{"syntax":"swift","type":"codeListing","code":["var paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")","print(paragraph!.asHTML())","\/\/ Prints \"<p>hello, world<\/p>\""]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"paragraph","type":"codeVoice"},{"type":"text","text":" variable above is defined as an "},{"inlineContent":[{"text":"optional","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"code":"HTMLElement","type":"codeVoice"},{"type":"text","text":", so that it can be set to "},{"code":"nil","type":"codeVoice"},{"type":"text","text":" below to demonstrate the presence of a strong reference cycle."}]}],"type":"aside","name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"text":"Unfortunately, the ","type":"text"},{"code":"HTMLElement","type":"codeVoice"},{"text":" class, as written above, creates a strong reference cycle between an ","type":"text"},{"code":"HTMLElement","type":"codeVoice"},{"text":" instance and the closure used for its default ","type":"text"},{"code":"asHTML","type":"codeVoice"},{"text":" value. Here’s how the cycle looks:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"closureReferenceCycle01","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"The instance’s ","type":"text"},{"type":"codeVoice","code":"asHTML"},{"text":" property holds a strong reference to its closure. However, because the closure refers to ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" within its body (as a way to reference ","type":"text"},{"type":"codeVoice","code":"self.name"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"self.text"},{"text":"), the closure ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"captures","type":"text"}]},{"text":" self, which means that it holds a strong reference back to the ","type":"text"},{"type":"codeVoice","code":"HTMLElement"},{"text":" instance. A strong reference cycle is created between the two. (For more information about capturing values in a closure, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Capturing-Values","type":"reference","isActive":true},{"text":".)","type":"text"}]},{"content":[{"inlineContent":[{"text":"Even though the closure refers to ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" multiple times, it only captures one strong reference to the ","type":"text"},{"code":"HTMLElement","type":"codeVoice"},{"text":" instance.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you set the "},{"type":"codeVoice","code":"paragraph"},{"type":"text","text":" variable to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" and break its strong reference to the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" instance, neither the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" instance nor its closure are deallocated, because of the strong reference cycle:"}]},{"syntax":"swift","type":"codeListing","code":["paragraph = nil"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the message in the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" deinitializer isn’t printed, which shows that the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" instance isn’t deallocated."}]},{"type":"heading","level":2,"text":"Resolving Strong Reference Cycles for Closures","anchor":"Resolving-Strong-Reference-Cycles-for-Closures"},{"type":"paragraph","inlineContent":[{"text":"You resolve a strong reference cycle between a closure and a class instance by defining a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture list","type":"text"}]},{"text":" as part of the closure’s definition. A capture list defines the rules to use when capturing one or more reference types within the closure’s body. As with strong reference cycles between two class instances, you declare each captured reference to be a weak or unowned reference rather than a strong reference. The appropriate choice of weak or unowned depends on the relationships between the different parts of your code.","type":"text"}]},{"content":[{"inlineContent":[{"text":"Swift requires you to write ","type":"text"},{"type":"codeVoice","code":"self.someProperty"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"self.someMethod()"},{"text":" (rather than just ","type":"text"},{"type":"codeVoice","code":"someProperty"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"someMethod()"},{"text":") whenever you refer to a member of ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" within a closure. This helps you remember that it’s possible to capture ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" by accident.","type":"text"}],"type":"paragraph"}],"type":"aside","name":"Note","style":"note"},{"type":"heading","level":3,"text":"Defining a Capture List","anchor":"Defining-a-Capture-List"},{"type":"paragraph","inlineContent":[{"text":"Each item in a capture list is a pairing of the ","type":"text"},{"code":"weak","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"unowned","type":"codeVoice"},{"text":" keyword with a reference to a class instance (such as ","type":"text"},{"code":"self","type":"codeVoice"},{"text":") or a variable initialized with some value (such as ","type":"text"},{"code":"delegate = self.delegate","type":"codeVoice"},{"text":"). These pairings are written within a pair of square braces, separated by commas.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Place the capture list before a closure’s parameter list and return type if they’re provided:"}]},{"syntax":"swift","type":"codeListing","code":["lazy var someClosure = {","    [unowned self, weak delegate = self.delegate]","    (index: Int, stringToProcess: String) -> String in","    \/\/ closure body goes here","}"]},{"type":"paragraph","inlineContent":[{"text":"If a closure doesn’t specify a parameter list or return type because they can be inferred from context, place the capture list at the very start of the closure, followed by the ","type":"text"},{"type":"codeVoice","code":"in"},{"text":" keyword:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["lazy var someClosure = {","    [unowned self, weak delegate = self.delegate] in","    \/\/ closure body goes here","}"]},{"type":"heading","level":3,"text":"Weak and Unowned References","anchor":"Weak-and-Unowned-References"},{"type":"paragraph","inlineContent":[{"text":"Define a capture in a closure as an unowned reference when the closure and the instance it captures will always refer to each other, and will always be deallocated at the same time.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conversely, define a capture as a weak reference when the captured reference may become "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" at some point in the future. Weak references are always of an optional type, and automatically become "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" when the instance they reference is deallocated. This enables you to check for their existence within the closure’s body."}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If the captured reference will never become "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", it should always be captured as an unowned reference, rather than a weak reference."}]}],"type":"aside","name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An unowned reference is the appropriate capture method to use to resolve the strong reference cycle in the "},{"code":"HTMLElement","type":"codeVoice"},{"type":"text","text":" example from "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures","isActive":true,"type":"reference"},{"type":"text","text":" above. Here’s how you write the "},{"code":"HTMLElement","type":"codeVoice"},{"type":"text","text":" class to avoid the cycle:"}]},{"syntax":"swift","type":"codeListing","code":["class HTMLElement {","","    let name: String","    let text: String?","","    lazy var asHTML: () -> String = {","        [unowned self] in","        if let text = self.text {","            return \"<\\(self.name)>\\(text)<\/\\(self.name)>\"","        } else {","            return \"<\\(self.name) \/>\"","        }","    }","","    init(name: String, text: String? = nil) {","        self.name = name","        self.text = text","    }","","    deinit {","        print(\"\\(name) is being deinitialized\")","    }","","}"]},{"type":"paragraph","inlineContent":[{"text":"This implementation of ","type":"text"},{"type":"codeVoice","code":"HTMLElement"},{"text":" is identical to the previous implementation, apart from the addition of a capture list within the ","type":"text"},{"type":"codeVoice","code":"asHTML"},{"text":" closure. In this case, the capture list is ","type":"text"},{"type":"codeVoice","code":"[unowned self]"},{"text":", which means “capture self as an unowned reference rather than a strong reference”.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can create and print an "},{"code":"HTMLElement","type":"codeVoice"},{"type":"text","text":" instance as before:"}]},{"syntax":"swift","type":"codeListing","code":["var paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")","print(paragraph!.asHTML())","\/\/ Prints \"<p>hello, world<\/p>\""]},{"type":"paragraph","inlineContent":[{"text":"Here’s how the references look with the capture list in place:","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"closureReferenceCycle02"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This time, the capture of "},{"type":"codeVoice","code":"self"},{"type":"text","text":" by the closure is an unowned reference, and doesn’t keep a strong hold on the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" instance it has captured. If you set the strong reference from the "},{"type":"codeVoice","code":"paragraph"},{"type":"text","text":" variable to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the "},{"type":"codeVoice","code":"HTMLElement"},{"type":"text","text":" instance is deallocated, as can be seen from the printing of its deinitializer message in the example below:"}]},{"syntax":"swift","type":"codeListing","code":["paragraph = nil","\/\/ Prints \"p is being deinitialized\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information about capture lists, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions","isActive":true},{"type":"text","text":"."}]}]}],"kind":"article","sections":[],"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"generated":true}],"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"variants":[{"paths":["\/documentation\/swift\/automaticreferencecounting"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"Automatic Reference Counting","type":"text"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"metadata":{"role":"article","title":"Automatic Reference Counting","modules":[{"name":"Swift"}],"roleHeading":"Article"},"references":{"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"url":"\/documentation\/swift\/opaquetypes","title":"Opaque Types","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"kind":"article","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","title":"Extensions","type":"topic","url":"\/documentation\/swift\/extensions"},"referenceCycle02":{"identifier":"referenceCycle02","alt":null,"variants":[{"url":"\/images\/referenceCycle02@2x.png","traits":["2x","light"]}],"type":"image"},"unownedOptionalReference":{"identifier":"unownedOptionalReference","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/unownedOptionalReference@2x.png"}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/Functions":{"role":"article","type":"topic","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"kind":"article","url":"\/documentation\/swift\/functions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","kind":"article","role":"article"},"unownedReference01":{"identifier":"unownedReference01","alt":null,"variants":[{"url":"\/images\/unownedReference01@2x.png","traits":["2x","light"]}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","title":"Subscripts","url":"\/documentation\/swift\/subscripts","role":"article","kind":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","role":"article","url":"\/documentation\/swift\/advancedoperators","abstract":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.","type":"text"}],"title":"Advanced Operators","kind":"article"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","role":"article","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","title":"Memory Safety","type":"topic","url":"\/documentation\/swift\/memorysafety"},"weakReference02":{"identifier":"weakReference02","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/weakReference02@2x.png"}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/Closures#Capturing-Values":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Capturing-Values","url":"\/documentation\/swift\/closures#Capturing-Values","abstract":[],"kind":"section","type":"topic","title":"Capturing Values"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"kind":"article","role":"article","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"text":"inherit","type":"text"}]},{"type":"text","text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":", and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"text":"superclass","type":"text"}]},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","type":"topic","url":"\/documentation\/swift\/inheritance"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"url":"\/documentation\/swift\/initialization","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","type":"topic","title":"Initialization","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}]},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"title":"Strings and Characters","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" is a series of characters, such as "},{"code":"\"hello, world\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"albatross\"","type":"codeVoice"},{"text":". Swift strings are represented by the ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type. The contents of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values.","type":"text"}],"type":"topic","kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","role":"article","url":"\/documentation\/swift\/stringsandcharacters"},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"title":"Enumerations","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"type":"topic","role":"article","kind":"article","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"inlineContent":[{"type":"text","text":"Asynchronous code"}],"type":"emphasis"},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"inlineContent":[{"type":"text","text":"Parallel code"}],"type":"emphasis"},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"title":"Concurrency","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-Between-Class-Instances":{"title":"Resolving Strong Reference Cycles Between Class Instances","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Resolving-Strong-Reference-Cycles-Between-Class-Instances","url":"\/documentation\/swift\/automaticreferencecounting#Resolving-Strong-Reference-Cycles-Between-Class-Instances","type":"topic","abstract":[],"kind":"section"},"doc://com.apple.Swift/documentation/Swift/Expressions":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Expressions","abstract":[{"text":"In Swift, there are four kinds of expressions: prefix expressions, infix expressions, primary expressions, and postfix expressions. Evaluating an expression returns a value, causes a side effect, or both.","type":"text"}],"title":"Expressions","url":"\/documentation\/swift\/expressions","role":"article"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword. Deinitializers are only available on class types.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization"},"doc://com.apple.Swift/documentation/Swift/Closures":{"role":"article","type":"topic","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures"},"doc://com.apple.Swift/documentation/Swift/Generics":{"role":"article","type":"topic","title":"Generics","kind":"article","abstract":[{"inlineContent":[{"type":"text","text":"Generic code"}],"type":"emphasis"},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","url":"\/documentation\/swift\/generics"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"title":"Error Handling","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","url":"\/documentation\/swift\/errorhandling"},"referenceCycle03":{"type":"image","alt":null,"identifier":"referenceCycle03","variants":[{"url":"\/images\/referenceCycle03@2x.png","traits":["2x","light"]}]},"weakReference03":{"type":"image","alt":null,"identifier":"weakReference03","variants":[{"traits":["2x","light"],"url":"\/images\/weakReference03@2x.png"}]},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"role":"article","type":"topic","title":"Control Flow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"kind":"article","url":"\/documentation\/swift\/controlflow","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"url":"\/documentation\/swift\/protocols","title":"Protocols","abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"protocol","type":"text"}],"type":"emphasis"},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"type":"text","text":"adopted"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"conform","type":"text"}]},{"text":" to that protocol.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","abstract":[{"inlineContent":[{"text":"Structures","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.","type":"text"}],"title":"Structures and Classes","url":"\/documentation\/swift\/classesandstructures","role":"article"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","abstract":[{"inlineContent":[{"text":"Access control","type":"text"}],"type":"emphasis"},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/accesscontrol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},"referenceCycle01":{"identifier":"referenceCycle01","alt":null,"type":"image","variants":[{"url":"\/images\/referenceCycle01@2x.png","traits":["2x","light"]}]},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"role":"article","type":"topic","title":"Nested Types","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"inlineContent":[{"text":"nested types","type":"text"}],"type":"emphasis"},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/nestedtypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes"},"https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html":{"title":"Transitioning to ARC Release Notes","identifier":"https:\/\/developer.apple.com\/library\/content\/releasenotes\/ObjectiveC\/RN-TransitioningToARC\/Introduction\/Introduction.html","url":"https:\/\/developer.apple.com\/library\/content\/releasenotes\/ObjectiveC\/RN-TransitioningToARC\/Introduction\/Introduction.html","type":"link","titleInlineContent":[{"type":"text","text":"Transitioning to ARC Release Notes"}]},"doc://com.apple.Swift/documentation/Swift/Initialization#Two-Phase-Initialization":{"title":"Two-Phase Initialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization#Two-Phase-Initialization","url":"\/documentation\/swift\/initialization#Two-Phase-Initialization","type":"topic","abstract":[],"kind":"section"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"abstract":[{"type":"text","text":"An "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"type":"codeVoice","code":"+"},{"text":") adds two numbers, as in ","type":"text"},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"type":"topic","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","url":"\/documentation\/swift\/basicoperators","kind":"article","title":"Basic Operators"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","title":"Collection Types","abstract":[{"text":"Swift provides three primary ","type":"text"},{"inlineContent":[{"text":"collection types","type":"text"}],"type":"emphasis"},{"text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/collectiontypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures":{"type":"topic","title":"Strong Reference Cycles for Closures","kind":"section","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures","url":"\/documentation\/swift\/automaticreferencecounting#Strong-Reference-Cycles-for-Closures"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"title":"Swift","url":"\/documentation\/swift","role":"collection"},"doc://com.apple.Swift/documentation/Swift/TheBasics#Implicitly-Unwrapped-Optionals":{"kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics#Implicitly-Unwrapped-Optionals","url":"\/documentation\/swift\/thebasics#Implicitly-Unwrapped-Optionals","abstract":[],"type":"topic","title":"Implicitly Unwrapped Optionals"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"title":"Optional Chaining","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic"},"weakReference01":{"identifier":"weakReference01","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/weakReference01@2x.png"}],"type":"image"},"closureReferenceCycle02":{"identifier":"closureReferenceCycle02","alt":null,"variants":[{"url":"\/images\/closureReferenceCycle02@2x.png","traits":["2x","light"]}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","kind":"article","role":"article"},"unownedReference02":{"identifier":"unownedReference02","alt":null,"variants":[{"traits":["2x","light"],"url":"\/images\/unownedReference02@2x.png"}],"type":"image"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","role":"article","abstract":[{"inlineContent":[{"text":"Type casting","type":"text"}],"type":"emphasis"},{"text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.","type":"text"}],"title":"Type Casting","url":"\/documentation\/swift\/typecasting","type":"topic"},"closureReferenceCycle01":{"identifier":"closureReferenceCycle01","alt":null,"variants":[{"url":"\/images\/closureReferenceCycle01@2x.png","traits":["2x","light"]}],"type":"image"}}}