{"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"metadata":{"modules":[{"name":"Swift"}],"roleHeading":"Article","role":"article","title":"Enumerations"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations"},"seeAlsoSections":[{"title":"Language Guide","identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"generated":true}],"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Overview","anchor":"overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you are familiar with C, you will know that C enumerations assign related names to a set of integer values. Enumerations in Swift are much more flexible, and don’t have to provide a value for each case of the enumeration. If a value (known as a "},{"type":"emphasis","inlineContent":[{"text":"raw","type":"text"}]},{"type":"text","text":" value) is provided for each enumeration case, the value can be a string, a character, or a value of any integer or floating-point type."}]},{"type":"paragraph","inlineContent":[{"text":"Alternatively, enumeration cases can specify associated values of ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"any","type":"text"}]},{"type":"text","text":" type to be stored along with each different case value, much as unions or variants do in other languages. You can define a common set of related cases as part of one enumeration, each of which has a different set of values of appropriate types associated with it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Enumerations in Swift are first-class types in their own right. They adopt many features traditionally supported only by classes, such as computed properties to provide additional information about the enumeration’s current value, and instance methods to provide functionality related to the values the enumeration represents. Enumerations can also define initializers to provide an initial case value; can be extended to expand their functionality beyond their original implementation; and can conform to protocols to provide standard functionality."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more about these capabilities, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions"},{"type":"text","text":", and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols"},{"type":"text","text":"."}]},{"type":"heading","level":2,"text":"Enumeration Syntax","anchor":"Enumeration-Syntax"},{"type":"paragraph","inlineContent":[{"text":"You introduce enumerations with the ","type":"text"},{"code":"enum","type":"codeVoice"},{"text":" keyword and place their entire definition within a pair of braces:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum SomeEnumeration {","    \/\/ enumeration definition goes here","}"]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example for the four main points of a compass:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum CompassPoint {","    case north","    case south","    case east","    case west","}"]},{"type":"paragraph","inlineContent":[{"text":"The values defined in an enumeration (such as ","type":"text"},{"code":"north","type":"codeVoice"},{"text":", ","type":"text"},{"code":"south","type":"codeVoice"},{"text":", ","type":"text"},{"code":"east","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"west","type":"codeVoice"},{"text":") are its ","type":"text"},{"inlineContent":[{"type":"text","text":"enumeration cases"}],"type":"emphasis"},{"text":". You use the ","type":"text"},{"code":"case","type":"codeVoice"},{"text":" keyword to introduce new enumeration cases.","type":"text"}]},{"type":"aside","style":"note","content":[{"inlineContent":[{"type":"text","text":"Swift enumeration cases don’t have an integer value set by default, unlike languages like C and Objective-C. In the "},{"code":"CompassPoint","type":"codeVoice"},{"type":"text","text":" example above, "},{"code":"north","type":"codeVoice"},{"type":"text","text":", "},{"code":"south","type":"codeVoice"},{"type":"text","text":", "},{"code":"east","type":"codeVoice"},{"type":"text","text":" and "},{"code":"west","type":"codeVoice"},{"type":"text","text":" don’t implicitly equal "},{"code":"0","type":"codeVoice"},{"type":"text","text":", "},{"code":"1","type":"codeVoice"},{"type":"text","text":", "},{"code":"2","type":"codeVoice"},{"type":"text","text":" and "},{"code":"3","type":"codeVoice"},{"type":"text","text":". Instead, the different enumeration cases are values in their own right, with an explicitly defined type of "},{"code":"CompassPoint","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}],"name":"Note"},{"type":"paragraph","inlineContent":[{"text":"Multiple cases can appear on a single line, separated by commas:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum Planet {","    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each enumeration definition defines a new type. Like other types in Swift, their names (such as "},{"type":"codeVoice","code":"CompassPoint"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Planet"},{"type":"text","text":") start with a capital letter. Give enumeration types singular rather than plural names, so that they read as self-evident:"}]},{"type":"codeListing","syntax":"swift","code":["var directionToHead = CompassPoint.west"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The type of "},{"type":"codeVoice","code":"directionToHead"},{"type":"text","text":" is inferred when it’s initialized with one of the possible values of "},{"type":"codeVoice","code":"CompassPoint"},{"type":"text","text":". Once "},{"type":"codeVoice","code":"directionToHead"},{"type":"text","text":" is declared as a "},{"type":"codeVoice","code":"CompassPoint"},{"type":"text","text":", you can set it to a different "},{"type":"codeVoice","code":"CompassPoint"},{"type":"text","text":" value using a shorter dot syntax:"}]},{"type":"codeListing","syntax":"swift","code":["directionToHead = .east"]},{"type":"paragraph","inlineContent":[{"text":"The type of ","type":"text"},{"code":"directionToHead","type":"codeVoice"},{"text":" is already known, and so you can drop the type when setting its value. This makes for highly readable code when working with explicitly typed enumeration values.","type":"text"}]},{"type":"heading","level":2,"text":"Matching Enumeration Values with a Switch Statement","anchor":"Matching-Enumeration-Values-with-a-Switch-Statement"},{"type":"paragraph","inlineContent":[{"text":"You can match individual enumeration values with a ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" statement:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["directionToHead = .south","switch directionToHead {","case .north:","    print(\"Lots of planets have a north\")","case .south:","    print(\"Watch out for penguins\")","case .east:","    print(\"Where the sun rises\")","case .west:","    print(\"Where the skies are blue\")","}","\/\/ Prints \"Watch out for penguins\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can read this code as:"}]},{"type":"paragraph","inlineContent":[{"text":"“Consider the value of ","type":"text"},{"code":"directionToHead","type":"codeVoice"},{"text":". In the case where it equals ","type":"text"},{"code":".north","type":"codeVoice"},{"text":", print ","type":"text"},{"code":"\"Lots of planets have a north\"","type":"codeVoice"},{"text":". In the case where it equals ","type":"text"},{"code":".south","type":"codeVoice"},{"text":", print ","type":"text"},{"code":"\"Watch out for penguins\"","type":"codeVoice"},{"text":".”","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"…and so on.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As described in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","isActive":true,"type":"reference"},{"type":"text","text":", a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement must be exhaustive when considering an enumeration’s cases. If the "},{"code":"case","type":"codeVoice"},{"type":"text","text":" for "},{"code":".west","type":"codeVoice"},{"type":"text","text":" is omitted, this code doesn’t compile, because it doesn’t consider the complete list of "},{"code":"CompassPoint","type":"codeVoice"},{"type":"text","text":" cases. Requiring exhaustiveness ensures that enumeration cases aren’t accidentally omitted."}]},{"type":"paragraph","inlineContent":[{"text":"When it isn’t appropriate to provide a ","type":"text"},{"code":"case","type":"codeVoice"},{"text":" for every enumeration case, you can provide a ","type":"text"},{"code":"default","type":"codeVoice"},{"text":" case to cover any cases that aren’t addressed explicitly:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let somePlanet = Planet.earth","switch somePlanet {","case .earth:","    print(\"Mostly harmless\")","default:","    print(\"Not a safe place for humans\")","}","\/\/ Prints \"Mostly harmless\""]},{"type":"heading","level":2,"text":"Iterating over Enumeration Cases","anchor":"Iterating-over-Enumeration-Cases"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For some enumerations, it’s useful to have a collection of all of that enumeration’s cases. You enable this by writing "},{"code":": CaseIterable","type":"codeVoice"},{"type":"text","text":" after the enumeration’s name. Swift exposes a collection of all the cases as an "},{"code":"allCases","type":"codeVoice"},{"type":"text","text":" property of the enumeration type. Here’s an example:"}]},{"type":"codeListing","syntax":"swift","code":["enum Beverage: CaseIterable {","    case coffee, tea, juice","}","let numberOfChoices = Beverage.allCases.count","print(\"\\(numberOfChoices) beverages available\")","\/\/ Prints \"3 beverages available\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, you write "},{"type":"codeVoice","code":"Beverage.allCases"},{"type":"text","text":" to access a collection that contains all of the cases of the "},{"type":"codeVoice","code":"Beverage"},{"type":"text","text":" enumeration. You can use "},{"type":"codeVoice","code":"allCases"},{"type":"text","text":" like any other collection—the collection’s elements are instances of the enumeration type, so in this case they’re "},{"type":"codeVoice","code":"Beverage"},{"type":"text","text":" values. The example above counts how many cases there are, and the example below uses a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" loop to iterate over all the cases."}]},{"type":"codeListing","syntax":"swift","code":["for beverage in Beverage.allCases {","    print(beverage)","}","\/\/ coffee","\/\/ tea","\/\/ juice"]},{"type":"paragraph","inlineContent":[{"text":"The syntax used in the examples above marks the enumeration as conforming to the ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/caseiterable","type":"reference","isActive":true},{"text":" [https:\/\/developer.apple.com\/documentation\/swift\/caseiterable]","type":"text"},{"text":" protocol. For information about protocols, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","type":"reference","isActive":true},{"text":".","type":"text"}]},{"type":"heading","level":2,"text":"Associated Values","anchor":"Associated-Values"},{"type":"paragraph","inlineContent":[{"text":"The examples in the previous section show how the cases of an enumeration are a defined (and typed) value in their own right. You can set a constant or variable to ","type":"text"},{"code":"Planet.earth","type":"codeVoice"},{"text":", and check for this value later. However, it’s sometimes useful to be able to store values of other types alongside these case values. This additional information is called an ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"associated value"}]},{"text":", and it varies each time you use that case as a value in your code.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can define Swift enumerations to store associated values of any given type, and the value types can be different for each case of the enumeration if needed. Enumerations similar to these are known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"discriminated unions"}]},{"type":"text","text":", "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tagged unions"}]},{"type":"text","text":", or "},{"type":"emphasis","inlineContent":[{"type":"text","text":"variants"}]},{"type":"text","text":" in other programming languages."}]},{"type":"paragraph","inlineContent":[{"text":"For example, suppose an inventory tracking system needs to track products by two different types of barcode. Some products are labeled with 1D barcodes in UPC format, which uses the numbers ","type":"text"},{"type":"codeVoice","code":"0"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"9"},{"text":". Each barcode has a number system digit, followed by five manufacturer code digits and five product code digits. These are followed by a check digit to verify that the code has been scanned correctly:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"barcode_UPC","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"Other products are labeled with 2D barcodes in QR code format, which can use any ISO 8859-1 character and can encode a string up to 2,953 characters long:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"barcode_QR","type":"image"}]},{"type":"paragraph","inlineContent":[{"text":"It’s convenient for an inventory tracking system to store UPC barcodes as a tuple of four integers, and QR code barcodes as a string of any length.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, an enumeration to define product barcodes of either type might look like this:"}]},{"type":"codeListing","syntax":"swift","code":["enum Barcode {","    case upc(Int, Int, Int, Int)","    case qrCode(String)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can be read as:"}]},{"type":"paragraph","inlineContent":[{"text":"“Define an enumeration type called ","type":"text"},{"code":"Barcode","type":"codeVoice"},{"text":", which can take either a value of ","type":"text"},{"code":"upc","type":"codeVoice"},{"text":" with an associated value of type (","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":"), or a value of ","type":"text"},{"code":"qrCode","type":"codeVoice"},{"text":" with an associated value of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":".”","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This definition doesn’t provide any actual "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" or "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values—it just defines the "},{"inlineContent":[{"text":"type","type":"text"}],"type":"emphasis"},{"type":"text","text":" of associated values that "},{"code":"Barcode","type":"codeVoice"},{"type":"text","text":" constants and variables can store when they’re equal to "},{"code":"Barcode.upc","type":"codeVoice"},{"type":"text","text":" or "},{"code":"Barcode.qrCode","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"You can then create new barcodes using either type:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var productBarcode = Barcode.upc(8, 85909, 51226, 3)"]},{"type":"paragraph","inlineContent":[{"text":"This example creates a new variable called ","type":"text"},{"type":"codeVoice","code":"productBarcode"},{"text":" and assigns it a value of ","type":"text"},{"type":"codeVoice","code":"Barcode.upc"},{"text":" with an associated tuple value of ","type":"text"},{"type":"codeVoice","code":"(8, 85909, 51226, 3)"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can assign the same product a different type of barcode:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["productBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")"]},{"type":"paragraph","inlineContent":[{"text":"At this point, the original ","type":"text"},{"code":"Barcode.upc","type":"codeVoice"},{"text":" and its integer values are replaced by the new ","type":"text"},{"code":"Barcode.qrCode","type":"codeVoice"},{"text":" and its string value. Constants and variables of type ","type":"text"},{"code":"Barcode","type":"codeVoice"},{"text":" can store either a ","type":"text"},{"code":".upc","type":"codeVoice"},{"text":" or a ","type":"text"},{"code":".qrCode","type":"codeVoice"},{"text":" (together with their associated values), but they can store only one of them at any given time.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can check the different barcode types using a switch statement, similar to the example in "},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations#Matching-Enumeration-Values-with-a-Switch-Statement","type":"reference","isActive":true},{"type":"text","text":". This time, however, the associated values are extracted as part of the switch statement. You extract each associated value as a constant (with the "},{"type":"codeVoice","code":"let"},{"type":"text","text":" prefix) or a variable (with the "},{"type":"codeVoice","code":"var"},{"type":"text","text":" prefix) for use within the "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" case’s body:"}]},{"type":"codeListing","syntax":"swift","code":["switch productBarcode {","case .upc(let numberSystem, let manufacturer, let product, let check):","    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")","case .qrCode(let productCode):","    print(\"QR code: \\(productCode).\")","}","\/\/ Prints \"QR code: ABCDEFGHIJKLMNOP.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If all of the associated values for an enumeration case are extracted as constants, or if all are extracted as variables, you can place a single "},{"type":"codeVoice","code":"var"},{"type":"text","text":" or "},{"type":"codeVoice","code":"let"},{"type":"text","text":" annotation before the case name, for brevity:"}]},{"type":"codeListing","syntax":"swift","code":["switch productBarcode {","case let .upc(numberSystem, manufacturer, product, check):","    print(\"UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")","case let .qrCode(productCode):","    print(\"QR code: \\(productCode).\")","}","\/\/ Prints \"QR code: ABCDEFGHIJKLMNOP.\""]},{"type":"heading","level":2,"text":"Raw Values","anchor":"Raw-Values"},{"type":"paragraph","inlineContent":[{"text":"The barcode example in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations#Associated-Values"},{"text":" shows how cases of an enumeration can declare that they store associated values of different types. As an alternative to associated values, enumeration cases can come prepopulated with default values (called ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"raw values","type":"text"}]},{"text":"), which are all of the same type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example that stores raw ASCII values alongside named enumeration cases:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum ASCIIControlCharacter: Character {","    case tab = \"\\t\"","    case lineFeed = \"\\n\"","    case carriageReturn = \"\\r\"","}"]},{"type":"paragraph","inlineContent":[{"text":"Here, the raw values for an enumeration called ","type":"text"},{"code":"ASCIIControlCharacter","type":"codeVoice"},{"text":" are defined to be of type ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":", and are set to some of the more common ASCII control characters. ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values are described in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","type":"reference","isActive":true},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Raw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration."}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Raw values are ","type":"text"},{"inlineContent":[{"text":"not","type":"text"}],"type":"emphasis"},{"text":" the same as associated values. Raw values are set to prepopulated values when you first define the enumeration in your code, like the three ASCII codes above. The raw value for a particular enumeration case is always the same. Associated values are set when you create a new constant or variable based on one of the enumeration’s cases, and can be different each time you do so.","type":"text"}]}],"name":"Note"},{"type":"heading","level":3,"text":"Implicitly Assigned Raw Values","anchor":"Implicitly-Assigned-Raw-Values"},{"type":"paragraph","inlineContent":[{"text":"When you’re working with enumerations that store integer or string raw values, you don’t have to explicitly assign a raw value for each case. When you don’t, Swift automatically assigns the values for you.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For example, when integers are used for raw values, the implicit value for each case is one more than the previous case. If the first case doesn’t have a value set, its value is ","type":"text"},{"code":"0","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The enumeration below is a refinement of the earlier "},{"type":"codeVoice","code":"Planet"},{"type":"text","text":" enumeration, with integer raw values to represent each planet’s order from the sun:"}]},{"type":"codeListing","syntax":"swift","code":["enum Planet: Int {","    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, "},{"type":"codeVoice","code":"Planet.mercury"},{"type":"text","text":" has an explicit raw value of "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"type":"codeVoice","code":"Planet.venus"},{"type":"text","text":" has an implicit raw value of "},{"type":"codeVoice","code":"2"},{"type":"text","text":", and so on."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When strings are used for raw values, the implicit value for each case is the text of that case’s name."}]},{"type":"paragraph","inlineContent":[{"text":"The enumeration below is a refinement of the earlier ","type":"text"},{"type":"codeVoice","code":"CompassPoint"},{"text":" enumeration, with string raw values to represent each direction’s name:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["enum CompassPoint: String {","    case north, south, east, west","}"]},{"type":"paragraph","inlineContent":[{"text":"In the example above, ","type":"text"},{"type":"codeVoice","code":"CompassPoint.south"},{"text":" has an implicit raw value of ","type":"text"},{"type":"codeVoice","code":"\"south\""},{"text":", and so on.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You access the raw value of an enumeration case with its ","type":"text"},{"code":"rawValue","type":"codeVoice"},{"text":" property:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let earthsOrder = Planet.earth.rawValue","\/\/ earthsOrder is 3","","let sunsetDirection = CompassPoint.west.rawValue","\/\/ sunsetDirection is \"west\""]},{"type":"heading","level":3,"text":"Initializing from a Raw Value","anchor":"Initializing-from-a-Raw-Value"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you define an enumeration with a raw-value type, the enumeration automatically receives an initializer that takes a value of the raw value’s type (as a parameter called "},{"type":"codeVoice","code":"rawValue"},{"type":"text","text":") and returns either an enumeration case or "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". You can use this initializer to try to create a new instance of the enumeration."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example identifies Uranus from its raw value of "},{"code":"7","type":"codeVoice"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let possiblePlanet = Planet(rawValue: 7)","\/\/ possiblePlanet is of type Planet? and equals Planet.uranus"]},{"type":"paragraph","inlineContent":[{"text":"Not all possible ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" values will find a matching planet, however. Because of this, the raw value initializer always returns an ","type":"text"},{"inlineContent":[{"type":"text","text":"optional"}],"type":"emphasis"},{"text":" enumeration case. In the example above, ","type":"text"},{"type":"codeVoice","code":"possiblePlanet"},{"text":" is of type ","type":"text"},{"type":"codeVoice","code":"Planet?"},{"text":", or “optional ","type":"text"},{"type":"codeVoice","code":"Planet"},{"text":".”","type":"text"}]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"The raw value initializer is a failable initializer, because not every raw value will return an enumeration case. For more information, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Failable-Initializers","isActive":true,"type":"reference"},{"text":".","type":"text"}]}],"name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you try to find a planet with a position of "},{"type":"codeVoice","code":"11"},{"type":"text","text":", the optional "},{"type":"codeVoice","code":"Planet"},{"type":"text","text":" value returned by the raw value initializer will be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let positionToFind = 11","if let somePlanet = Planet(rawValue: positionToFind) {","    switch somePlanet {","    case .earth:","        print(\"Mostly harmless\")","    default:","        print(\"Not a safe place for humans\")","    }","} else {","    print(\"There isn't a planet at position \\(positionToFind)\")","}","\/\/ Prints \"There isn't a planet at position 11\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example uses optional binding to try to access a planet with a raw value of "},{"code":"11","type":"codeVoice"},{"type":"text","text":". The statement "},{"code":"if let somePlanet = Planet(rawValue: 11)","type":"codeVoice"},{"type":"text","text":" creates an optional "},{"code":"Planet","type":"codeVoice"},{"type":"text","text":", and sets "},{"code":"somePlanet","type":"codeVoice"},{"type":"text","text":" to the value of that optional "},{"code":"Planet","type":"codeVoice"},{"type":"text","text":" if it can be retrieved. In this case, it isn’t possible to retrieve a planet with a position of "},{"code":"11","type":"codeVoice"},{"type":"text","text":", and so the "},{"code":"else","type":"codeVoice"},{"type":"text","text":" branch is executed instead."}]},{"type":"heading","level":2,"text":"Recursive Enumerations","anchor":"Recursive-Enumerations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"recursive enumeration"}]},{"type":"text","text":" is an enumeration that has another instance of the enumeration as the associated value for one or more of the enumeration cases. You indicate that an enumeration case is recursive by writing "},{"type":"codeVoice","code":"indirect"},{"type":"text","text":" before it, which tells the compiler to insert the necessary layer of indirection."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, here is an enumeration that stores simple arithmetic expressions:"}]},{"type":"codeListing","syntax":"swift","code":["enum ArithmeticExpression {","    case number(Int)","    indirect case addition(ArithmeticExpression, ArithmeticExpression)","    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also write "},{"code":"indirect","type":"codeVoice"},{"type":"text","text":" before the beginning of the enumeration to enable indirection for all of the enumeration’s cases that have an associated value:"}]},{"type":"codeListing","syntax":"swift","code":["indirect enum ArithmeticExpression {","    case number(Int)","    case addition(ArithmeticExpression, ArithmeticExpression)","    case multiplication(ArithmeticExpression, ArithmeticExpression)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This enumeration can store three kinds of arithmetic expressions: a plain number, the addition of two expressions, and the multiplication of two expressions. The "},{"type":"codeVoice","code":"addition"},{"type":"text","text":" and "},{"type":"codeVoice","code":"multiplication"},{"type":"text","text":" cases have associated values that are also arithmetic expressions—these associated values make it possible to nest expressions. For example, the expression "},{"type":"codeVoice","code":"(5 + 4) * 2"},{"type":"text","text":" has a number on the right-hand side of the multiplication and another expression on the left-hand side of the multiplication. Because the data is nested, the enumeration used to store the data also needs to support nesting—this means the enumeration needs to be recursive. The code below shows the "},{"type":"codeVoice","code":"ArithmeticExpression"},{"type":"text","text":" recursive enumeration being created for "},{"type":"codeVoice","code":"(5 + 4) * 2"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let five = ArithmeticExpression.number(5)","let four = ArithmeticExpression.number(4)","let sum = ArithmeticExpression.addition(five, four)","let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))"]},{"type":"paragraph","inlineContent":[{"text":"A recursive function is a straightforward way to work with data that has a recursive structure. For example, here’s a function that evaluates an arithmetic expression:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func evaluate(_ expression: ArithmeticExpression) -> Int {","    switch expression {","    case let .number(value):","        return value","    case let .addition(left, right):","        return evaluate(left) + evaluate(right)","    case let .multiplication(left, right):","        return evaluate(left) * evaluate(right)","    }","}","","print(evaluate(product))","\/\/ Prints \"18\""]},{"type":"paragraph","inlineContent":[{"text":"This function evaluates a plain number by simply returning the associated value. It evaluates an addition or multiplication by evaluating the expression on the left-hand side, evaluating the expression on the right-hand side, and then adding them or multiplying them.","type":"text"}]}]}],"sections":[],"variants":[{"paths":["\/documentation\/swift\/enumerations"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"text":"enumeration","type":"text"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"kind":"article","references":{"barcode_QR":{"variants":[{"url":"\/images\/barcode_QR@2x.png","traits":["2x","light"]}],"alt":null,"type":"image","identifier":"barcode_QR"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"kind":"article","role":"article","abstract":[{"type":"text","text":"A class can "},{"type":"emphasis","inlineContent":[{"text":"inherit","type":"text"}]},{"type":"text","text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subclass"}]},{"type":"text","text":", and the class it inherits from is known as its "},{"type":"emphasis","inlineContent":[{"text":"superclass","type":"text"}]},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","type":"topic","url":"\/documentation\/swift\/inheritance"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"abstract":[{"type":"text","text":"An "},{"inlineContent":[{"text":"operator","type":"text"}],"type":"emphasis"},{"text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator (","type":"text"},{"type":"codeVoice","code":"+"},{"text":") adds two numbers, as in ","type":"text"},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"type":"topic","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","url":"\/documentation\/swift\/basicoperators","kind":"article","title":"Basic Operators"},"doc://com.apple.Swift/documentation/Swift/Functions":{"role":"article","type":"topic","title":"Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"kind":"article","url":"\/documentation\/swift\/functions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions"},"barcode_UPC":{"variants":[{"url":"\/images\/barcode_UPC@2x.png","traits":["2x","light"]}],"alt":null,"type":"image","identifier":"barcode_UPC"},"https://developer.apple.com/documentation/swift/caseiterable":{"title":"CaseIterable","url":"https:\/\/developer.apple.com\/documentation\/swift\/caseiterable","titleInlineContent":[{"text":"CaseIterable","type":"text"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swift\/caseiterable"},"doc://com.apple.Swift/documentation/Swift/Closures":{"role":"article","type":"topic","title":"Closures","abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","role":"article","url":"\/documentation\/swift\/advancedoperators","abstract":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","isActive":true},{"text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C.","type":"text"}],"title":"Advanced Operators","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Enumerations#Associated-Values":{"abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations#Associated-Values","title":"Associated Values","url":"\/documentation\/swift\/enumerations#Associated-Values","kind":"section","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"kind":"article","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","title":"Extensions","type":"topic","url":"\/documentation\/swift\/extensions"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"url":"\/documentation\/swift\/thebasics","title":"The Basics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"title":"Access Control","abstract":[{"inlineContent":[{"text":"Access control","type":"text"}],"type":"emphasis"},{"text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/accesscontrol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl"},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"type":"topic","role":"article","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"text":"Error handling","type":"text"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"title":"Error Handling","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","url":"\/documentation\/swift\/errorhandling"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"url":"\/documentation\/swift\/automaticreferencecounting","title":"Automatic Reference Counting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"text":"Automatic Reference Counting","type":"text"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Declarations#Failable-Initializers":{"url":"\/documentation\/swift\/declarations#Failable-Initializers","title":"Failable Initializers","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Declarations#Failable-Initializers","abstract":[],"type":"topic","kind":"section"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","role":"article","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","title":"Memory Safety","type":"topic","url":"\/documentation\/swift\/memorysafety"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"url":"\/documentation\/swift\/protocols","title":"Protocols","abstract":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"protocol","type":"text"}],"type":"emphasis"},{"text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be ","type":"text"},{"inlineContent":[{"type":"text","text":"adopted"}],"type":"emphasis"},{"text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"conform","type":"text"}]},{"text":" to that protocol.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/Enumerations#Matching-Enumeration-Values-with-a-Switch-Statement":{"url":"\/documentation\/swift\/enumerations#Matching-Enumeration-Values-with-a-Switch-Statement","abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations#Matching-Enumeration-Values-with-a-Switch-Statement","type":"topic","title":"Matching Enumeration Values with a Switch Statement","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"text":"subscripts","type":"text"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","title":"Subscripts","url":"\/documentation\/swift\/subscripts","role":"article","kind":"article","type":"topic"},"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"url":"\/documentation\/swift\/opaquetypes","title":"Opaque Types","abstract":[{"text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"title":"Swift","url":"\/documentation\/swift","role":"collection"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"title":"Deinitialization","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"deinitializer","type":"text"}]},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"code":"deinit","type":"codeVoice"},{"text":" keyword, similar to how initializers are written with the ","type":"text"},{"code":"init","type":"codeVoice"},{"text":" keyword. Deinitializers are only available on class types.","type":"text"}],"kind":"article","role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","role":"article","abstract":[{"inlineContent":[{"text":"Type casting","type":"text"}],"type":"emphasis"},{"text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy.","type":"text"}],"title":"Type Casting","url":"\/documentation\/swift\/typecasting","type":"topic"},"doc://com.apple.Swift/documentation/Swift/Properties":{"url":"\/documentation\/swift\/properties","title":"Properties","abstract":[{"type":"emphasis","inlineContent":[{"text":"Properties","type":"text"}]},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"role":"article","type":"topic","title":"Control Flow","abstract":[{"text":"Swift provides a variety of control flow statements. These include ","type":"text"},{"code":"while","type":"codeVoice"},{"text":" loops to perform a task multiple times; ","type":"text"},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"kind":"article","url":"\/documentation\/swift\/controlflow","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","abstract":[{"inlineContent":[{"text":"Structures","type":"text"}],"type":"emphasis"},{"text":" and ","type":"text"},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions.","type":"text"}],"title":"Structures and Classes","url":"\/documentation\/swift\/classesandstructures","role":"article"},"doc://com.apple.Swift/documentation/Swift/Methods":{"url":"\/documentation\/swift\/methods","title":"Methods","abstract":[{"inlineContent":[{"type":"text","text":"Methods"}],"type":"emphasis"},{"text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C.","type":"text"}],"type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","kind":"article","role":"article"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","title":"Collection Types","abstract":[{"text":"Swift provides three primary ","type":"text"},{"inlineContent":[{"text":"collection types","type":"text"}],"type":"emphasis"},{"text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/collectiontypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"url":"\/documentation\/swift\/initialization","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","type":"topic","title":"Initialization","kind":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use.","type":"text"}]},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"title":"Optional Chaining","kind":"article","role":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Optional chaining"}]},{"type":"text","text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the property, method, or subscript call returns "},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"code":"nil","type":"codeVoice"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic"},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"title":"Strings and Characters","abstract":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"string","type":"text"}]},{"type":"text","text":" is a series of characters, such as "},{"code":"\"hello, world\"","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"\"albatross\"","type":"codeVoice"},{"text":". Swift strings are represented by the ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type. The contents of a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" can be accessed in various ways, including as a collection of ","type":"text"},{"code":"Character","type":"codeVoice"},{"text":" values.","type":"text"}],"type":"topic","kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","role":"article","url":"\/documentation\/swift\/stringsandcharacters"},"doc://com.apple.Swift/documentation/Swift/Generics":{"role":"article","type":"topic","title":"Generics","kind":"article","abstract":[{"inlineContent":[{"type":"text","text":"Generic code"}],"type":"emphasis"},{"text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner.","type":"text"}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","url":"\/documentation\/swift\/generics"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"type":"topic","role":"article","kind":"article","abstract":[{"text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. ","type":"text"},{"inlineContent":[{"type":"text","text":"Asynchronous code"}],"type":"emphasis"},{"text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. ","type":"text"},{"inlineContent":[{"type":"text","text":"Parallel code"}],"type":"emphasis"},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"title":"Concurrency","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"role":"article","type":"topic","title":"Nested Types","abstract":[{"text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define ","type":"text"},{"inlineContent":[{"text":"nested types","type":"text"}],"type":"emphasis"},{"text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support.","type":"text"}],"kind":"article","url":"\/documentation\/swift\/nestedtypes","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes"}}}