{"variants":[{"paths":["\/documentation\/swift\/closures"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures","interfaceLanguage":"swift"},"seeAlsoSections":[{"identifiers":["doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators"],"title":"Language Guide","generated":true}],"metadata":{"roleHeading":"Article","modules":[{"name":"Swift"}],"role":"article","title":"Closures"},"hierarchy":{"paths":[["doc:\/\/com.apple.Swift\/documentation\/Swift"]]},"primaryContentSections":[{"content":[{"text":"Overview","anchor":"overview","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Closures can capture and store references to any constants and variables from the context in which they’re defined. This is known as "},{"type":"emphasis","inlineContent":[{"text":"closing over","type":"text"}]},{"type":"text","text":" those constants and variables. Swift handles all of the memory management of capturing for you."}],"type":"paragraph"},{"name":"Note","content":[{"inlineContent":[{"text":"Don’t worry if you aren’t familiar with the concept of capturing. It’s explained in detail below in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Capturing-Values","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside"},{"inlineContent":[{"type":"text","text":"Global and nested functions, as introduced in "},{"isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","type":"reference"},{"type":"text","text":", are actually special cases of closures. Closures take one of three forms:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Global functions are closures that have a name and don’t capture any values.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Nested functions are closures that have a name and can capture values from their enclosing function."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Closure expressions are unnamed closures written in a lightweight syntax that can capture values from their surrounding context.","type":"text"}]}]}],"type":"unorderedList"},{"inlineContent":[{"type":"text","text":"Swift’s closure expressions have a clean, clear style, with optimizations that encourage brief, clutter-free syntax in common scenarios. These optimizations include:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Inferring parameter and return value types from context","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implicit returns from single-expression closures"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Shorthand argument names"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Trailing closure syntax"}]}]}],"type":"unorderedList"},{"level":2,"text":"Closure Expressions","type":"heading","anchor":"Closure-Expressions"},{"inlineContent":[{"type":"text","text":"Nested functions, as introduced in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Nested-Functions","isActive":true},{"type":"text","text":", are a convenient means of naming and defining self-contained blocks of code as part of a larger function. However, it’s sometimes useful to write shorter versions of function-like constructs without a full declaration and name. This is particularly true when you work with functions or methods that take functions as one or more of their arguments."}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"Closure expressions"}],"type":"emphasis"},{"text":" are a way to write inline closures in a brief, focused syntax. Closure expressions provide several syntax optimizations for writing closures in a shortened form without loss of clarity or intent. The closure expression examples below illustrate these optimizations by refining a single example of the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method over several iterations, each of which expresses the same functionality in a more succinct way.","type":"text"}],"type":"paragraph"},{"level":3,"text":"The Sorted Method","type":"heading","anchor":"The-Sorted-Method"},{"inlineContent":[{"type":"text","text":"Swift’s standard library provides a method called "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":", which sorts an array of values of a known type, based on the output of a sorting closure that you provide. Once it completes the sorting process, the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method returns a new array of the same type and size as the old one, with its elements in the correct sorted order. The original array isn’t modified by the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The closure expression examples below use the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method to sort an array of ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" values in reverse alphabetical order. Here’s the initial array to be sorted:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method accepts a closure that takes two arguments of the same type as the array’s contents, and returns a ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" value to say whether the first value should appear before or after the second value once the values are sorted. The sorting closure needs to return ","type":"text"},{"code":"true","type":"codeVoice"},{"text":" if the first value should appear ","type":"text"},{"inlineContent":[{"text":"before","type":"text"}],"type":"emphasis"},{"text":" the second value, and ","type":"text"},{"code":"false","type":"codeVoice"},{"text":" otherwise.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example is sorting an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values, and so the sorting closure needs to be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way to provide the sorting closure is to write a normal function of the correct type, and to pass it in as an argument to the "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method:"}]},{"syntax":"swift","type":"codeListing","code":["func backward(_ s1: String, _ s2: String) -> Bool {","    return s1 > s2","}","var reversedNames = names.sorted(by: backward)","\/\/ reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the first string ("},{"code":"s1","type":"codeVoice"},{"type":"text","text":") is greater than the second string ("},{"code":"s2","type":"codeVoice"},{"type":"text","text":"), the "},{"code":"backward(_:_:)","type":"codeVoice"},{"type":"text","text":" function will return "},{"code":"true","type":"codeVoice"},{"type":"text","text":", indicating that "},{"code":"s1","type":"codeVoice"},{"type":"text","text":" should appear before "},{"code":"s2","type":"codeVoice"},{"type":"text","text":" in the sorted array. For characters in strings, “greater than” means “appears later in the alphabet than”. This means that the letter "},{"code":"\"B\"","type":"codeVoice"},{"type":"text","text":" is “greater than” the letter "},{"code":"\"A\"","type":"codeVoice"},{"type":"text","text":", and the string "},{"code":"\"Tom\"","type":"codeVoice"},{"type":"text","text":" is greater than the string "},{"code":"\"Tim\"","type":"codeVoice"},{"type":"text","text":". This gives a reverse alphabetical sort, with "},{"code":"\"Barry\"","type":"codeVoice"},{"type":"text","text":" being placed before "},{"code":"\"Alex\"","type":"codeVoice"},{"type":"text","text":", and so on."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, this is a rather long-winded way to write what is essentially a single-expression function ("},{"type":"codeVoice","code":"a > b"},{"type":"text","text":"). In this example, it would be preferable to write the sorting closure inline, using closure expression syntax."}]},{"level":3,"type":"heading","text":"Closure Expression Syntax","anchor":"Closure-Expression-Syntax"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure expression syntax has the following general form:"}]},{"type":"codeListing","syntax":"swift","code":["{ (parameters) -> return type in","    statements","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"parameters"}],"type":"emphasis"},{"type":"text","text":" in closure expression syntax can be in-out parameters, but they can’t have a default value. Variadic parameters can be used if you name the variadic parameter. Tuples can also be used as parameter types and return types."}]},{"type":"paragraph","inlineContent":[{"text":"The example below shows a closure expression version of the ","type":"text"},{"type":"codeVoice","code":"backward(_:_:)"},{"text":" function from above:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in","    return s1 > s2","})"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the declaration of parameters and return type for this inline closure is identical to the declaration from the "},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function. In both cases, it’s written as "},{"type":"codeVoice","code":"(s1: String, s2: String) -> Bool"},{"type":"text","text":". However, for the inline closure expression, the parameters and return type are written "},{"type":"emphasis","inlineContent":[{"type":"text","text":"inside"}]},{"type":"text","text":" the curly braces, not outside of them."}]},{"type":"paragraph","inlineContent":[{"text":"The start of the closure’s body is introduced by the ","type":"text"},{"code":"in","type":"codeVoice"},{"text":" keyword. This keyword indicates that the definition of the closure’s parameters and return type has finished, and the body of the closure is about to begin.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the body of the closure is so short, it can even be written on a single line:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"text":"This illustrates that the overall call to the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method has remained the same. A pair of parentheses still wrap the entire argument for the method. However, that argument is now an inline closure.","type":"text"}]},{"level":3,"type":"heading","text":"Inferring Type From Context","anchor":"Inferring-Type-From-Context"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the sorting closure is passed as an argument to a method, Swift can infer the types of its parameters and the type of the value it returns. The "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method is being called on an array of strings, so its argument must be a function of type "},{"code":"(String, String) -> Bool","type":"codeVoice"},{"type":"text","text":". This means that the "},{"code":"(String, String)","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Bool"},{"text":" types don’t need to be written as part of the closure expression’s definition. Because all of the types can be inferred, the return arrow (","type":"text"},{"type":"codeVoice","code":"->"},{"text":") and the parentheses around the names of the parameters can also be omitted:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s always possible to infer the parameter types and return type when passing a closure to a function or method as an inline closure expression. As a result, you never need to write an inline closure in its fullest form when the closure is used as a function or method argument."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nonetheless, you can still make the types explicit if you wish, and doing so is encouraged if it avoids ambiguity for readers of your code. In the case of the "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method, the purpose of the closure is clear from the fact that sorting is taking place, and it’s safe for a reader to assume that the closure is likely to be working with "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values, because it’s assisting with the sorting of an array of strings."}]},{"level":3,"type":"heading","text":"Implicit Returns from Single-Expression Closures","anchor":"Implicit-Returns-from-Single-Expression-Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Single-expression closures can implicitly return the result of their single expression by omitting the "},{"code":"return","type":"codeVoice"},{"type":"text","text":" keyword from their declaration, as in this version of the previous example:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, the function type of the "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method’s argument makes it clear that a "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" value must be returned by the closure. Because the closure’s body contains a single expression ("},{"code":"s1 > s2","type":"codeVoice"},{"type":"text","text":") that returns a "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" value, there’s no ambiguity, and the "},{"code":"return","type":"codeVoice"},{"type":"text","text":" keyword can be omitted."}]},{"level":3,"type":"heading","text":"Shorthand Argument Names","anchor":"Shorthand-Argument-Names"},{"type":"paragraph","inlineContent":[{"text":"Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names ","type":"text"},{"code":"$0","type":"codeVoice"},{"text":", ","type":"text"},{"code":"$1","type":"codeVoice"},{"text":", ","type":"text"},{"code":"$2","type":"codeVoice"},{"text":", and so on.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you use these shorthand argument names within your closure expression, you can omit the closure’s argument list from its definition. The type of the shorthand argument names is inferred from the expected function type, and the highest numbered shorthand argument you use determines the number of arguments that the closure takes. The "},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword can also be omitted, because the closure expression is made up entirely of its body:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { $0 > $1 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"$1"},{"type":"text","text":" refer to the closure’s first and second "},{"type":"codeVoice","code":"String"},{"type":"text","text":" arguments. Because "},{"type":"codeVoice","code":"$1"},{"type":"text","text":" is the shorthand argument with highest number, the closure is understood to take two arguments. Because the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" function here expects a closure whose arguments are both strings, the shorthand arguments "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"$1"},{"type":"text","text":" are both of type "},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]},{"level":3,"type":"heading","text":"Operator Methods","anchor":"Operator-Methods"},{"type":"paragraph","inlineContent":[{"text":"There’s actually an even ","type":"text"},{"inlineContent":[{"text":"shorter","type":"text"}],"type":"emphasis"},{"text":" way to write the closure expression above. Swift’s ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" type defines its string-specific implementation of the greater-than operator (","type":"text"},{"code":">","type":"codeVoice"},{"text":") as a method that has two parameters of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", and returns a value of type ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":". This exactly matches the method type needed by the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method. Therefore, you can simply pass in the greater-than operator, and Swift will infer that you want to use its string-specific implementation:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: >)"]},{"type":"paragraph","inlineContent":[{"text":"For more about operator methods, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Operator-Methods"},{"text":".","type":"text"}]},{"level":2,"type":"heading","text":"Trailing Closures","anchor":"Trailing-Closures"},{"type":"paragraph","inlineContent":[{"text":"If you need to pass a closure expression to a function as the function’s final argument and the closure expression is long, it can be useful to write it as a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"trailing closure","type":"text"}]},{"text":" instead. You write a trailing closure after the function call’s parentheses, even though the trailing closure is still an argument to the function. When you use the trailing closure syntax, you don’t write the argument label for the first closure as part of the function call. A function call can include multiple trailing closures; however, the first few examples below use a single trailing closure.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func someFunctionThatTakesAClosure(closure: () -> Void) {","    \/\/ function body goes here","}","","\/\/ Here's how you call this function without using a trailing closure:","","someFunctionThatTakesAClosure(closure: {","    \/\/ closure's body goes here","})","","\/\/ Here's how you call this function with a trailing closure instead:","","someFunctionThatTakesAClosure() {","    \/\/ trailing closure's body goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string-sorting closure from the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Closure-Expression-Syntax"},{"type":"text","text":" section above can be written outside of the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method’s parentheses as a trailing closure:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted() { $0 > $1 }"]},{"type":"paragraph","inlineContent":[{"text":"If a closure expression is provided as the function’s or method’s only argument and you provide that expression as a trailing closure, you don’t need to write a pair of parentheses ","type":"text"},{"type":"codeVoice","code":"()"},{"text":" after the function or method’s name when you call the function:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted { $0 > $1 }"]},{"type":"paragraph","inlineContent":[{"text":"Trailing closures are most useful when the closure is sufficiently long that it isn’t possible to write it inline on a single line. As an example, Swift’s ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":" type has a ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"text":" method, which takes a closure expression as its single argument. The closure is called once for each item in the array, and returns an alternative mapped value (possibly of some other type) for that item. You specify the nature of the mapping and the type of the returned value by writing code in the closure that you pass to ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After applying the provided closure to each array element, the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method returns a new array containing all of the new mapped values, in the same order as their corresponding values in the original array."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you can use the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method with a trailing closure to convert an array of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values into an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values. The array "},{"type":"codeVoice","code":"[16, 58, 510]"},{"type":"text","text":" is used to create the new array "},{"type":"codeVoice","code":"[\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let digitNames = [","    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",","    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"","]","let numbers = [16, 58, 510]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a dictionary of mappings between the integer digits and English-language versions of their names. It also defines an array of integers, ready to be converted into strings."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now use the "},{"type":"codeVoice","code":"numbers"},{"type":"text","text":" array to create an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values, by passing a closure expression to the array’s "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method as a trailing closure:"}]},{"type":"codeListing","syntax":"swift","code":["let strings = numbers.map { (number) -> String in","    var number = number","    var output = \"\"","    repeat {","        output = digitNames[number % 10]! + output","        number \/= 10","    } while number > 0","    return output","}","\/\/ strings is inferred to be of type [String]","\/\/ its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method calls the closure expression once for each item in the array. You don’t need to specify the type of the closure’s input parameter, "},{"type":"codeVoice","code":"number"},{"type":"text","text":", because the type can be inferred from the values in the array to be mapped."}]},{"type":"paragraph","inlineContent":[{"text":"In this example, the variable ","type":"text"},{"code":"number","type":"codeVoice"},{"text":" is initialized with the value of the closure’s ","type":"text"},{"code":"number","type":"codeVoice"},{"text":" parameter, so that the value can be modified within the closure body. (The parameters to functions and closures are always constants.) The closure expression also specifies a return type of ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", to indicate the type that will be stored in the mapped output array.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The closure expression builds a string called ","type":"text"},{"type":"codeVoice","code":"output"},{"text":" each time it’s called. It calculates the last digit of ","type":"text"},{"type":"codeVoice","code":"number"},{"text":" by using the remainder operator (","type":"text"},{"type":"codeVoice","code":"number % 10"},{"text":"), and uses this digit to look up an appropriate string in the ","type":"text"},{"type":"codeVoice","code":"digitNames"},{"text":" dictionary. The closure can be used to create a string representation of any integer greater than zero.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"The call to the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"text":" dictionary’s subscript is followed by an exclamation point (","type":"text"},{"code":"!","type":"codeVoice"},{"text":"), because dictionary subscripts return an optional value to indicate that the dictionary lookup can fail if the key doesn’t exist. In the example above, it’s guaranteed that ","type":"text"},{"code":"number % 10","type":"codeVoice"},{"text":" will always be a valid subscript key for the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"text":" dictionary, and so an exclamation point is used to force-unwrap the ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" value stored in the subscript’s optional return value.","type":"text"}]}],"type":"aside","style":"note","name":"Note"},{"type":"paragraph","inlineContent":[{"text":"The string retrieved from the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"text":" dictionary is added to the ","type":"text"},{"inlineContent":[{"text":"front","type":"text"}],"type":"emphasis"},{"text":" of ","type":"text"},{"code":"output","type":"codeVoice"},{"text":", effectively building a string version of the number in reverse. (The expression ","type":"text"},{"code":"number % 10","type":"codeVoice"},{"text":" gives a value of ","type":"text"},{"code":"6","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"16","type":"codeVoice"},{"text":", ","type":"text"},{"code":"8","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"58","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"0","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"510","type":"codeVoice"},{"text":".)","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"number","type":"codeVoice"},{"text":" variable is then divided by ","type":"text"},{"type":"codeVoice","code":"10"},{"text":". Because it’s an integer, it’s rounded down during the division, so ","type":"text"},{"type":"codeVoice","code":"16"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"1"},{"text":", ","type":"text"},{"type":"codeVoice","code":"58"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"5"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"510"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"51"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The process is repeated until ","type":"text"},{"code":"number","type":"codeVoice"},{"text":" is equal to ","type":"text"},{"code":"0","type":"codeVoice"},{"text":", at which point the ","type":"text"},{"code":"output","type":"codeVoice"},{"text":" string is returned by the closure, and is added to the output array by the ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"text":" method.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The use of trailing closure syntax in the example above neatly encapsulates the closure’s functionality immediately after the function that closure supports, without needing to wrap the entire closure within the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method’s outer parentheses."}]},{"type":"paragraph","inlineContent":[{"text":"If a function takes multiple closures, you omit the argument label for the first trailing closure and you label the remaining trailing closures. For example, the function below loads a picture for a photo gallery:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {","    if let picture = download(\"photo.jpg\", from: server) {","        completion(picture)","    } else {","        onFailure()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you call this function to load a picture, you provide two closures. The first closure is a completion handler that displays a picture after a successful download. The second closure is an error handler that displays an error to the user."}]},{"type":"codeListing","syntax":"swift","code":["loadPicture(from: someServer) { picture in","    someView.currentPicture = picture","} onFailure: {","    print(\"Couldn't download the next picture.\")","}"]},{"type":"paragraph","inlineContent":[{"text":"In this example, the ","type":"text"},{"code":"loadPicture(from:completion:onFailure:)","type":"codeVoice"},{"text":" function dispatches its network task into the background, and calls one of the two completion handlers when the network task finishes. Writing the function this way lets you cleanly separate the code that’s responsible for handling a network failure from the code that updates the user interface after a successful download, instead of using just one closure that handles both circumstances.","type":"text"}]},{"content":[{"inlineContent":[{"type":"text","text":"Completion handlers can become hard to read, especially when you have to nest multiple handlers. An alternate approach is to use asynchronous code, as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside","style":"note","name":"Note"},{"level":2,"type":"heading","text":"Capturing Values","anchor":"Capturing-Values"},{"type":"paragraph","inlineContent":[{"text":"A closure can ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture","type":"text"}]},{"text":" constants and variables from the surrounding context in which it’s defined. The closure can then refer to and modify the values of those constants and variables from within its body, even if the original scope that defined the constants and variables no longer exists.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, the simplest form of a closure that can capture values is a nested function, written within the body of another function. A nested function can capture any of its outer function’s arguments and can also capture any constants and variables defined within the outer function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a function called "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":", which contains a nested function called "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":". The nested "},{"type":"codeVoice","code":"incrementer()"},{"type":"text","text":" function captures two values, "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":", from its surrounding context. After capturing these values, "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":" is returned by "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" as a closure that increments "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" by "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" each time it’s called."}]},{"type":"codeListing","syntax":"swift","code":["func makeIncrementer(forIncrement amount: Int) -> () -> Int {","    var runningTotal = 0","    func incrementer() -> Int {","        runningTotal += amount","        return runningTotal","    }","    return incrementer","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The return type of "},{"code":"makeIncrementer","type":"codeVoice"},{"type":"text","text":" is "},{"code":"() -> Int","type":"codeVoice"},{"type":"text","text":". This means that it returns a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"function"}]},{"type":"text","text":", rather than a simple value. The function it returns has no parameters, and returns an "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" value each time it’s called. To learn how functions can return other functions, see "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Function-Types-as-Return-Types","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"makeIncrementer(forIncrement:)","type":"codeVoice"},{"type":"text","text":" function defines an integer variable called "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":", to store the current running total of the incrementer that will be returned. This variable is initialized with a value of "},{"code":"0","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"type":"text","text":" function has a single "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" parameter with an argument label of "},{"type":"codeVoice","code":"forIncrement"},{"type":"text","text":", and a parameter name of "},{"type":"codeVoice","code":"amount"},{"type":"text","text":". The argument value passed to this parameter specifies how much "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" should be incremented by each time the returned incrementer function is called. The "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" function defines a nested function called "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":", which performs the actual incrementing. This function simply adds "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":", and returns the result."}]},{"type":"paragraph","inlineContent":[{"text":"When considered in isolation, the nested ","type":"text"},{"code":"incrementer()","type":"codeVoice"},{"text":" function might seem unusual:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func incrementer() -> Int {","    runningTotal += amount","    return runningTotal","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"incrementer()","type":"codeVoice"},{"type":"text","text":" function doesn’t have any parameters, and yet it refers to "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" from within its function body. It does this by capturing a "},{"inlineContent":[{"type":"text","text":"reference"}],"type":"emphasis"},{"type":"text","text":" to "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" from the surrounding function and using them within its own function body. Capturing by reference ensures that "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" don’t disappear when the call to "},{"code":"makeIncrementer","type":"codeVoice"},{"text":" ends, and also ensures that ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"text":" is available the next time the ","type":"text"},{"code":"incrementer","type":"codeVoice"},{"text":" function is called.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"As an optimization, Swift may instead capture and store a "},{"inlineContent":[{"type":"text","text":"copy"}],"type":"emphasis"},{"type":"text","text":" of a value if that value isn’t mutated by a closure, and if the value isn’t mutated after the closure is created."}]},{"type":"paragraph","inlineContent":[{"text":"Swift also handles all memory management involved in disposing of variables when they’re no longer needed.","type":"text"}]}],"type":"aside","style":"note","name":"Note"},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of ","type":"text"},{"code":"makeIncrementer","type":"codeVoice"},{"text":" in action:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let incrementByTen = makeIncrementer(forIncrement: 10)"]},{"type":"paragraph","inlineContent":[{"text":"This example sets a constant called ","type":"text"},{"code":"incrementByTen","type":"codeVoice"},{"text":" to refer to an incrementer function that adds ","type":"text"},{"code":"10","type":"codeVoice"},{"text":" to its ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"text":" variable each time it’s called. Calling the function multiple times shows this behavior in action:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["incrementByTen()","\/\/ returns a value of 10","incrementByTen()","\/\/ returns a value of 20","incrementByTen()","\/\/ returns a value of 30"]},{"type":"paragraph","inlineContent":[{"text":"If you create a second incrementer, it will have its own stored reference to a new, separate ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"text":" variable:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let incrementBySeven = makeIncrementer(forIncrement: 7)","incrementBySeven()","\/\/ returns a value of 7"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Calling the original incrementer ("},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":") again continues to increment its own "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variable, and doesn’t affect the variable captured by "},{"type":"codeVoice","code":"incrementBySeven"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["incrementByTen()","\/\/ returns a value of 40"]},{"content":[{"type":"paragraph","inlineContent":[{"text":"If you assign a closure to a property of a class instance, and the closure captures that instance by referring to the instance or its members, you will create a strong reference cycle between the closure and the instance. Swift uses ","type":"text"},{"inlineContent":[{"text":"capture lists","type":"text"}],"type":"emphasis"},{"text":" to break these strong reference cycles. For more information, see ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures","isActive":true,"type":"reference"},{"text":".","type":"text"}]}],"type":"aside","style":"note","name":"Note"},{"level":2,"type":"heading","text":"Closures Are Reference Types","anchor":"Closures-Are-Reference-Types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, "},{"code":"incrementBySeven","type":"codeVoice"},{"type":"text","text":" and "},{"code":"incrementByTen","type":"codeVoice"},{"type":"text","text":" are constants, but the closures these constants refer to are still able to increment the "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" variables that they have captured. This is because functions and closures are "},{"type":"emphasis","inlineContent":[{"text":"reference types","type":"text"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you assign a function or a closure to a constant or a variable, you are actually setting that constant or variable to be a "},{"inlineContent":[{"type":"text","text":"reference"}],"type":"emphasis"},{"type":"text","text":" to the function or closure. In the example above, it’s the choice of closure that "},{"code":"incrementByTen","type":"codeVoice"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"refers to"}],"type":"emphasis"},{"type":"text","text":" that’s constant, and not the contents of the closure itself."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This also means that if you assign a closure to two different constants or variables, both of those constants or variables refer to the same closure."}]},{"type":"codeListing","syntax":"swift","code":["let alsoIncrementByTen = incrementByTen","alsoIncrementByTen()","\/\/ returns a value of 50","","incrementByTen()","\/\/ returns a value of 60"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above shows that calling "},{"code":"alsoIncrementByTen","type":"codeVoice"},{"type":"text","text":" is the same as calling "},{"code":"incrementByTen","type":"codeVoice"},{"type":"text","text":". Because both of them refer to the same closure, they both increment and return the same running total."}]},{"level":2,"type":"heading","text":"Escaping Closures","anchor":"Escaping-Closures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure is said to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"escape"}]},{"type":"text","text":" a function when the closure is passed as an argument to the function, but is called after the function returns. When you declare a function that takes a closure as one of its parameters, you can write "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" before the parameter’s type to indicate that the closure is allowed to escape."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way that a closure can escape is by being stored in a variable that’s defined outside the function. As an example, many functions that start an asynchronous operation take a closure argument as a completion handler. The function returns after it starts the operation, but the closure isn’t called until the operation is completed—the closure needs to escape, to be called later. For example:"}]},{"type":"codeListing","syntax":"swift","code":["var completionHandlers: [() -> Void] = []","func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {","    completionHandlers.append(completionHandler)","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"someFunctionWithEscapingClosure(_:)","type":"codeVoice"},{"text":" function takes a closure as its argument and adds it to an array that’s declared outside the function. If you didn’t mark the parameter of this function with ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"text":", you would get a compile-time error.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An escaping closure that refers to "},{"code":"self","type":"codeVoice"},{"type":"text","text":" needs special consideration if "},{"code":"self","type":"codeVoice"},{"type":"text","text":" refers to an instance of a class. Capturing "},{"type":"codeVoice","code":"self"},{"type":"text","text":" in an escaping closure makes it easy to accidentally create a strong reference cycle. For information about reference cycles, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Normally, a closure captures variables implicitly by using them in the body of the closure, but in this case you need to be explicit. If you want to capture "},{"type":"codeVoice","code":"self"},{"type":"text","text":", write "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly when you use it, or include "},{"type":"codeVoice","code":"self"},{"type":"text","text":" in the closure’s capture list. Writing "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly lets you express your intent, and reminds you to confirm that there isn’t a reference cycle. For example, in the code below, the closure passed to "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure(_:)"},{"type":"text","text":" refers to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly. In contrast, the closure passed to "},{"type":"codeVoice","code":"someFunctionWithNonescapingClosure(_:)"},{"type":"text","text":" is a nonescaping closure, which means it can refer to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly."}]},{"type":"codeListing","syntax":"swift","code":["func someFunctionWithNonescapingClosure(closure: () -> Void) {","    closure()","}","","class SomeClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { self.x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}","","let instance = SomeClass()","instance.doSomething()","print(instance.x)","\/\/ Prints \"200\"","","completionHandlers.first?()","print(instance.x)","\/\/ Prints \"100\""]},{"type":"paragraph","inlineContent":[{"text":"Here’s a version of ","type":"text"},{"code":"doSomething()","type":"codeVoice"},{"text":" that captures ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" by including it in the closure’s capture list, and then refers to ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" implicitly:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["class SomeOtherClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { [self] in x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is an instance of a structure or an enumeration, you can always refer to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly. However, an escaping closure can’t capture a mutable reference to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" when "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is an instance of a structure or an enumeration. Structures and enumerations don’t allow shared mutability, as discussed in "},{"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","isActive":true},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct SomeStruct {","    var x = 10","    mutating func doSomething() {","        someFunctionWithNonescapingClosure { x = 200 }  \/\/ Ok","        someFunctionWithEscapingClosure { x = 100 }     \/\/ Error","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The call to the ","type":"text"},{"code":"someFunctionWithEscapingClosure","type":"codeVoice"},{"text":" function in the example above is an error because it’s inside a mutating method, so ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" is mutable. That violates the rule that escaping closures can’t capture a mutable reference to ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" for structures.","type":"text"}]},{"level":2,"type":"heading","text":"Autoclosures","anchor":"Autoclosures"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"autoclosure"}]},{"type":"text","text":" is a closure that’s automatically created to wrap an expression that’s being passed as an argument to a function. It doesn’t take any arguments, and when it’s called, it returns the value of the expression that’s wrapped inside of it. This syntactic convenience lets you omit braces around a function’s parameter by writing a normal expression instead of an explicit closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s common to "},{"inlineContent":[{"type":"text","text":"call"}],"type":"emphasis"},{"type":"text","text":" functions that take autoclosures, but it’s not common to "},{"inlineContent":[{"type":"text","text":"implement"}],"type":"emphasis"},{"type":"text","text":" that kind of function. For example, the "},{"code":"assert(condition:message:file:line:)","type":"codeVoice"},{"type":"text","text":" function takes an autoclosure for its "},{"code":"condition","type":"codeVoice"},{"type":"text","text":" and "},{"code":"message","type":"codeVoice"},{"type":"text","text":" parameters; its "},{"code":"condition","type":"codeVoice"},{"type":"text","text":" parameter is evaluated only in debug builds and its "},{"code":"message","type":"codeVoice"},{"type":"text","text":" parameter is evaluated only if "},{"code":"condition","type":"codeVoice"},{"type":"text","text":" is "},{"code":"false","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"An autoclosure lets you delay evaluation, because the code inside isn’t run until you call the closure. Delaying evaluation is useful for code that has side effects or is computationally expensive, because it lets you control when that code is evaluated. The code below shows how a closure delays evaluation.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","print(customersInLine.count)","\/\/ Prints \"5\"","","let customerProvider = { customersInLine.remove(at: 0) }","print(customersInLine.count)","\/\/ Prints \"5\"","","print(\"Now serving \\(customerProvider())!\")","\/\/ Prints \"Now serving Chris!\"","print(customersInLine.count)","\/\/ Prints \"4\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even though the first element of the "},{"code":"customersInLine","type":"codeVoice"},{"type":"text","text":" array is removed by the code inside the closure, the array element isn’t removed until the closure is actually called. If the closure is never called, the expression inside the closure is never evaluated, which means the array element is never removed. Note that the type of "},{"code":"customerProvider","type":"codeVoice"},{"type":"text","text":" isn’t "},{"code":"String","type":"codeVoice"},{"type":"text","text":" but "},{"code":"() -> String","type":"codeVoice"},{"type":"text","text":"—a function with no parameters that returns a string."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You get the same behavior of delayed evaluation when you pass a closure as an argument to a function."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: { customersInLine.remove(at: 0) } )","\/\/ Prints \"Now serving Alex!\""]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"serve(customer:)","type":"codeVoice"},{"text":" function in the listing above takes an explicit closure that returns a customer’s name. The version of ","type":"text"},{"code":"serve(customer:)","type":"codeVoice"},{"text":" below performs the same operation but, instead of taking an explicit closure, it takes an autoclosure by marking its parameter’s type with the ","type":"text"},{"code":"@autoclosure","type":"codeVoice"},{"text":" attribute. Now you can call the function as if it took a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" argument instead of a closure. The argument is automatically converted to a closure, because the ","type":"text"},{"code":"customerProvider","type":"codeVoice"},{"text":" parameter’s type is marked with the ","type":"text"},{"code":"@autoclosure","type":"codeVoice"},{"text":" attribute.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: @autoclosure () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: customersInLine.remove(at: 0))","\/\/ Prints \"Now serving Ewa!\""]},{"content":[{"inlineContent":[{"text":"Overusing autoclosures can make your code hard to understand. The context and function name should make it clear that evaluation is being deferred.","type":"text"}],"type":"paragraph"}],"type":"aside","style":"note","name":"Note"},{"type":"paragraph","inlineContent":[{"text":"If you want an autoclosure that’s allowed to escape, use both the ","type":"text"},{"code":"@autoclosure","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"text":" attributes. The ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"text":" attribute is described above in ","type":"text"},{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Escaping-Closures","isActive":true,"type":"reference"},{"text":".","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Barry\", \"Daniella\"]","var customerProviders: [() -> String] = []","func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {","    customerProviders.append(customerProvider)","}","collectCustomerProviders(customersInLine.remove(at: 0))","collectCustomerProviders(customersInLine.remove(at: 0))","","print(\"Collected \\(customerProviders.count) closures.\")","\/\/ Prints \"Collected 2 closures.\"","for customerProvider in customerProviders {","    print(\"Now serving \\(customerProvider())!\")","}","\/\/ Prints \"Now serving Barry!\"","\/\/ Prints \"Now serving Daniella!\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, instead of calling the closure passed to it as its "},{"code":"customerProvider","type":"codeVoice"},{"type":"text","text":" argument, the "},{"code":"collectCustomerProviders(_:)","type":"codeVoice"},{"type":"text","text":" function appends the closure to the "},{"code":"customerProviders","type":"codeVoice"},{"type":"text","text":" array. The array is declared outside the scope of the function, which means the closures in the array can be executed after the function returns. As a result, the value of the "},{"code":"customerProvider","type":"codeVoice"},{"type":"text","text":" argument must be allowed to escape the function’s scope."}]}],"kind":"content"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"sections":[],"abstract":[{"inlineContent":[{"type":"text","text":"Closures"}],"type":"emphasis"},{"text":" are self-contained blocks of functionality that can be passed around and used in your code. Closures in Swift are similar to blocks in C and Objective-C and to lambdas in other programming languages.","type":"text"}],"kind":"article","references":{"doc://com.apple.Swift/documentation/Swift/OpaqueTypes":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OpaqueTypes","abstract":[{"type":"text","text":"A function or method with an opaque return type hides its return value’s type information. Instead of providing a concrete type as the function’s return type, the return value is described in terms of the protocols it supports. Hiding type information is useful at boundaries between a module and code that calls into the module, because the underlying type of the return value can remain private. Unlike returning a value whose type is a protocol type, opaque types preserve type identity—the compiler has access to the type information, but clients of the module don’t."}],"url":"\/documentation\/swift\/opaquetypes","type":"topic","role":"article","title":"Opaque Types","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Closures#Escaping-Closures":{"kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Escaping-Closures","abstract":[],"url":"\/documentation\/swift\/closures#Escaping-Closures","type":"topic","title":"Escaping Closures"},"doc://com.apple.Swift/documentation/Swift/Subscripts":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Subscripts","abstract":[{"type":"text","text":"Classes, structures, and enumerations can define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subscripts"}]},{"type":"text","text":", which are shortcuts for accessing the member elements of a collection, list, or sequence. You use subscripts to set and retrieve values by index without needing separate methods for setting and retrieval. For example, you access elements in an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someArray[index]"},{"type":"text","text":" and elements in a "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" instance as "},{"type":"codeVoice","code":"someDictionary[key]"},{"type":"text","text":"."}],"type":"topic","title":"Subscripts","role":"article","url":"\/documentation\/swift\/subscripts"},"doc://com.apple.Swift/documentation/Swift/NestedTypes":{"url":"\/documentation\/swift\/nestedtypes","type":"topic","title":"Nested Types","abstract":[{"type":"text","text":"Enumerations are often created to support a specific class or structure’s functionality. Similarly, it can be convenient to define utility classes and structures purely for use within the context of a more complex type. To accomplish this, Swift enables you to define "},{"type":"emphasis","inlineContent":[{"type":"text","text":"nested types"}]},{"type":"text","text":", whereby you nest supporting enumerations, classes, and structures within the definition of the type they support."}],"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/NestedTypes","role":"article"},"doc://com.apple.Swift/documentation/Swift/TypeCasting":{"abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Type casting"}]},{"type":"text","text":" is a way to check the type of an instance, or to treat that instance as a different superclass or subclass from somewhere else in its own class hierarchy."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TypeCasting","title":"Type Casting","type":"topic","kind":"article","role":"article","url":"\/documentation\/swift\/typecasting"},"doc://com.apple.Swift/documentation/Swift/Protocols":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Protocols","abstract":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"protocol","type":"text"}]},{"type":"text","text":" defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality. The protocol can then be "},{"type":"emphasis","inlineContent":[{"type":"text","text":"adopted"}]},{"type":"text","text":" by a class, structure, or enumeration to provide an actual implementation of those requirements. Any type that satisfies the requirements of a protocol is said to "},{"inlineContent":[{"type":"text","text":"conform"}],"type":"emphasis"},{"type":"text","text":" to that protocol."}],"type":"topic","title":"Protocols","role":"article","url":"\/documentation\/swift\/protocols"},"doc://com.apple.Swift/documentation/Swift/Extensions":{"type":"topic","kind":"article","title":"Extensions","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Extensions","role":"article","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"type":"text","text":" add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to extend types for which you don’t have access to the original source code (known as "},{"type":"emphasis","inlineContent":[{"text":"retroactive modeling","type":"text"}]},{"type":"text","text":"). Extensions are similar to categories in Objective-C. (Unlike Objective-C categories, Swift extensions don’t have names.)"}],"url":"\/documentation\/swift\/extensions"},"doc://com.apple.Swift/documentation/Swift/MemorySafety":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/MemorySafety","abstract":[{"type":"text","text":"By default, Swift prevents unsafe behavior from happening in your code. For example, Swift ensures that variables are initialized before they’re used, memory isn’t accessed after it’s been deallocated, and array indices are checked for out-of-bounds errors."}],"type":"topic","title":"Memory Safety","role":"article","url":"\/documentation\/swift\/memorysafety"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators":{"abstract":[{"type":"text","text":"In addition to the operators described in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators"},{"type":"text","text":", Swift provides several advanced operators that perform more complex value manipulation. These include all of the bitwise and bit shifting operators you will be familiar with from C and Objective-C."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators","title":"Advanced Operators","type":"topic","kind":"article","role":"article","url":"\/documentation\/swift\/advancedoperators"},"doc://com.apple.Swift/documentation/Swift/BasicOperators":{"type":"topic","kind":"article","title":"Basic Operators","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/BasicOperators","role":"article","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"operator"}]},{"type":"text","text":" is a special symbol or phrase that you use to check, change, or combine values. For example, the addition operator ("},{"type":"codeVoice","code":"+"},{"type":"text","text":") adds two numbers, as in "},{"type":"codeVoice","code":"let i = 1 + 2"},{"type":"text","text":", and the logical AND operator ("},{"type":"codeVoice","code":"&&"},{"type":"text","text":") combines two Boolean values, as in "},{"type":"codeVoice","code":"if enteredDoorCode && passedRetinaScan"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/basicoperators"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures":{"role":"article","type":"topic","url":"\/documentation\/swift\/classesandstructures","abstract":[{"inlineContent":[{"type":"text","text":"Structures"}],"type":"emphasis"},{"type":"text","text":" and "},{"inlineContent":[{"text":"classes","type":"text"}],"type":"emphasis"},{"type":"text","text":" are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your structures and classes using the same syntax you use to define constants, variables, and functions."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures","title":"Structures and Classes","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Functions#Nested-Functions":{"title":"Nested Functions","type":"topic","url":"\/documentation\/swift\/functions#Nested-Functions","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Nested-Functions","abstract":[]},"doc://com.apple.Swift/documentation/Swift/ErrorHandling":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ErrorHandling","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Error handling"}]},{"type":"text","text":" is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime."}],"type":"topic","title":"Error Handling","role":"article","url":"\/documentation\/swift\/errorhandling"},"doc://com.apple.Swift/documentation/Swift/Closures#Capturing-Values":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Capturing-Values","kind":"section","type":"topic","url":"\/documentation\/swift\/closures#Capturing-Values","title":"Capturing Values","abstract":[]},"doc://com.apple.Swift/documentation/Swift/StringsAndCharacters":{"role":"article","type":"topic","url":"\/documentation\/swift\/stringsandcharacters","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"text":"string","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a series of characters, such as "},{"type":"codeVoice","code":"\"hello, world\""},{"type":"text","text":" or "},{"type":"codeVoice","code":"\"albatross\""},{"type":"text","text":". Swift strings are represented by the "},{"type":"codeVoice","code":"String"},{"type":"text","text":" type. The contents of a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" can be accessed in various ways, including as a collection of "},{"type":"codeVoice","code":"Character"},{"type":"text","text":" values."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/StringsAndCharacters","title":"Strings and Characters","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types":{"title":"Structures and Enumerations Are Value Types","type":"topic","url":"\/documentation\/swift\/classesandstructures#Structures-and-Enumerations-Are-Value-Types","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ClassesAndStructures#Structures-and-Enumerations-Are-Value-Types","abstract":[]},"doc://com.apple.Swift/documentation/Swift/Enumerations":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Enumerations","abstract":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"enumeration"}]},{"type":"text","text":" defines a common type for a group of related values and enables you to work with those values in a type-safe way within your code."}],"url":"\/documentation\/swift\/enumerations","type":"topic","role":"article","title":"Enumerations","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Inheritance":{"role":"article","type":"topic","url":"\/documentation\/swift\/inheritance","abstract":[{"text":"A class can ","type":"text"},{"inlineContent":[{"type":"text","text":"inherit"}],"type":"emphasis"},{"text":" methods, properties, and other characteristics from another class. When one class inherits from another, the inheriting class is known as a ","type":"text"},{"inlineContent":[{"type":"text","text":"subclass"}],"type":"emphasis"},{"type":"text","text":", and the class it inherits from is known as its "},{"inlineContent":[{"type":"text","text":"superclass"}],"type":"emphasis"},{"type":"text","text":". Inheritance is a fundamental behavior that differentiates classes from other types in Swift."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Inheritance","title":"Inheritance","kind":"article"},"doc://com.apple.Swift/documentation/Swift/OptionalChaining":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/OptionalChaining","abstract":[{"inlineContent":[{"type":"text","text":"Optional chaining"}],"type":"emphasis"},{"text":" is a process for querying and calling properties, methods, and subscripts on an optional that might currently be ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":". If the optional contains a value, the property, method, or subscript call succeeds; if the optional is ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":", the property, method, or subscript call returns ","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":". Multiple queries can be chained together, and the entire chain fails gracefully if any link in the chain is "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}],"url":"\/documentation\/swift\/optionalchaining","type":"topic","role":"article","title":"Optional Chaining","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Functions":{"title":"Functions","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Functions"}]},{"type":"text","text":" are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to “call” the function to perform its task when needed."}],"url":"\/documentation\/swift\/functions"},"doc://com.apple.Swift/documentation/Swift/TheBasics":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/TheBasics","abstract":[{"type":"text","text":"Swift is a new programming language for iOS, macOS, watchOS, and tvOS app development. Nonetheless, many parts of Swift will be familiar from your experience of developing in C and Objective-C."}],"url":"\/documentation\/swift\/thebasics","type":"topic","role":"article","title":"The Basics","kind":"article"},"doc://com.apple.Swift/documentation/Swift/ControlFlow":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/ControlFlow","abstract":[{"type":"text","text":"Swift provides a variety of control flow statements. These include "},{"code":"while","type":"codeVoice"},{"type":"text","text":" loops to perform a task multiple times; "},{"code":"if","type":"codeVoice"},{"type":"text","text":", "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statements to execute different branches of code based on certain conditions; and statements such as "},{"type":"codeVoice","code":"break"},{"type":"text","text":" and "},{"type":"codeVoice","code":"continue"},{"type":"text","text":" to transfer the flow of execution to another point in your code."}],"type":"topic","title":"Control Flow","role":"article","url":"\/documentation\/swift\/controlflow"},"doc://com.apple.Swift/documentation/Swift":{"kind":"symbol","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift","abstract":[],"type":"topic","title":"Swift","role":"collection","url":"\/documentation\/swift"},"doc://com.apple.Swift/documentation/Swift/Generics":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Generics","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Generic code"}]},{"type":"text","text":" enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted manner."}],"url":"\/documentation\/swift\/generics","type":"topic","role":"article","title":"Generics","kind":"article"},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures":{"url":"\/documentation\/swift\/automaticreferencecounting#Strong-Reference-Cycles-for-Closures","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting#Strong-Reference-Cycles-for-Closures","kind":"section","abstract":[],"type":"topic","title":"Strong Reference Cycles for Closures"},"doc://com.apple.Swift/documentation/Swift/Initialization":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Initialization","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Initialization"}]},{"type":"text","text":" is the process of preparing an instance of a class, structure, or enumeration for use. This process involves setting an initial value for each stored property on that instance and performing any other setup or initialization that’s required before the new instance is ready for use."}],"url":"\/documentation\/swift\/initialization","type":"topic","role":"article","title":"Initialization","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Properties":{"role":"article","type":"topic","url":"\/documentation\/swift\/properties","abstract":[{"inlineContent":[{"type":"text","text":"Properties"}],"type":"emphasis"},{"type":"text","text":" associate values with a particular class, structure, or enumeration. Stored properties store constant and variable values as part of an instance, whereas computed properties calculate (rather than store) a value. Computed properties are provided by classes, structures, and enumerations. Stored properties are provided only by classes and structures."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Properties","title":"Properties","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Deinitialization":{"role":"article","type":"topic","url":"\/documentation\/swift\/deinitialization","abstract":[{"type":"text","text":"A "},{"inlineContent":[{"type":"text","text":"deinitializer"}],"type":"emphasis"},{"type":"text","text":" is called immediately before a class instance is deallocated. You write deinitializers with the "},{"type":"codeVoice","code":"deinit"},{"type":"text","text":" keyword, similar to how initializers are written with the "},{"type":"codeVoice","code":"init"},{"type":"text","text":" keyword. Deinitializers are only available on class types."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Deinitialization","title":"Deinitialization","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Methods":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Methods","abstract":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Methods"}]},{"type":"text","text":" are functions that are associated with a particular type. Classes, structures, and enumerations can all define instance methods, which encapsulate specific tasks and functionality for working with an instance of a given type. Classes, structures, and enumerations can also define type methods, which are associated with the type itself. Type methods are similar to class methods in Objective-C."}],"type":"topic","title":"Methods","role":"article","url":"\/documentation\/swift\/methods"},"doc://com.apple.Swift/documentation/Swift/AdvancedOperators#Operator-Methods":{"title":"Operator Methods","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AdvancedOperators#Operator-Methods","type":"topic","url":"\/documentation\/swift\/advancedoperators#Operator-Methods","abstract":[]},"doc://com.apple.Swift/documentation/Swift/AutomaticReferenceCounting":{"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AutomaticReferenceCounting","abstract":[{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Automatic Reference Counting"}]},{"type":"text","text":" (ARC) to track and manage your app’s memory usage. In most cases, this means that memory management “just works” in Swift, and you don’t need to think about memory management yourself. ARC automatically frees up the memory used by class instances when those instances are no longer needed."}],"url":"\/documentation\/swift\/automaticreferencecounting","type":"topic","role":"article","title":"Automatic Reference Counting","kind":"article"},"doc://com.apple.Swift/documentation/Swift/Functions#Function-Types-as-Return-Types":{"abstract":[],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Functions#Function-Types-as-Return-Types","title":"Function Types as Return Types","type":"topic","url":"\/documentation\/swift\/functions#Function-Types-as-Return-Types","kind":"section"},"doc://com.apple.Swift/documentation/Swift/Concurrency":{"title":"Concurrency","role":"article","kind":"article","type":"topic","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Concurrency","abstract":[{"type":"text","text":"Swift has built-in support for writing asynchronous and parallel code in a structured way. "},{"type":"emphasis","inlineContent":[{"type":"text","text":"Asynchronous code"}]},{"type":"text","text":" can be suspended and resumed later, although only one piece of the program executes at a time. Suspending and resuming code in your program lets it continue to make progress on short-term operations like updating its UI while continuing to work on long-running operations like fetching data over the network or parsing files. "},{"type":"emphasis","inlineContent":[{"text":"Parallel code","type":"text"}]},{"text":" means multiple pieces of code run simultaneously—for example, a computer with a four-core processor can run four pieces of code at the same time, with each core carrying out one of the tasks. A program that uses parallel and asynchronous code carries out multiple operations at a time; it suspends operations that are waiting for an external system, and makes it easier to write this code in a memory-safe way.","type":"text"}],"url":"\/documentation\/swift\/concurrency"},"doc://com.apple.Swift/documentation/Swift/CollectionTypes":{"role":"article","type":"topic","url":"\/documentation\/swift\/collectiontypes","abstract":[{"type":"text","text":"Swift provides three primary "},{"inlineContent":[{"type":"text","text":"collection types"}],"type":"emphasis"},{"type":"text","text":", known as arrays, sets, and dictionaries, for storing collections of values. Arrays are ordered collections of values. Sets are unordered collections of unique values. Dictionaries are unordered collections of key-value associations."}],"identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/CollectionTypes","title":"Collection Types","kind":"article"},"doc://com.apple.Swift/documentation/Swift/AccessControl":{"kind":"article","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/AccessControl","abstract":[{"inlineContent":[{"type":"text","text":"Access control"}],"type":"emphasis"},{"type":"text","text":" restricts access to parts of your code from code in other source files and modules. This feature enables you to hide the implementation details of your code, and to specify a preferred interface through which that code can be accessed and used."}],"type":"topic","title":"Access Control","role":"article","url":"\/documentation\/swift\/accesscontrol"},"doc://com.apple.Swift/documentation/Swift/Closures#Closure-Expression-Syntax":{"type":"topic","abstract":[],"title":"Closure Expression Syntax","kind":"section","identifier":"doc:\/\/com.apple.Swift\/documentation\/Swift\/Closures#Closure-Expression-Syntax","url":"\/documentation\/swift\/closures#Closure-Expression-Syntax"}}}